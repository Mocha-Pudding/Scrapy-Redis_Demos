{"title": "个税计算器 / 微信小程序开发 ", "author": "Rolan", "pub_time": "2019-1-2 00:36", "content": "019年1月1日即将到来，码农们除了关心自己的技能之外，还有薪资是不是可以多拿点。 每次算的时候 都要百度一下个人所得税，但是很多都是老的税率计算，找一个新的出来还是比较麻烦，所以个人开发了一个最新税率的小程序。解决和我有着一样痛苦的码农们的问题。根据最新税改后计算个人所得税的计算器。目前支持南京，后续开放 杭州 上海 北京等城市。 如果有疑问的可以加最下方 开发者微信。首先在微信官网下载微信小程序开发工具 https://mp.weixin.qq.com在https://mp.weixin.qq.com 注册小程序账号，完成个人实名认证。在小程序后台拿到appid，下面就可以开发了。实例查看二维码：先使用weui 小程序ui框架就行页面布局<button block type=\"dark\" bindtap='calculationBindtap'>计算</button>其次写JS代码（计算按钮逻辑代码）import data from './data'\r\n\r\nconst app = getApp;\r\n\r\nPage({\r\n    data: {\r\n        options1: data,\r\n        value: '1',\r\n        checked: true,\r\n        standard: 1,\r\n        marking: 5000,\r\n        beforetaxCount: 0,\r\n        specialitemCount: 0\r\n    },\r\n    \r\n\r\n    calculationBindtap:function(){\r\n        // 开始计算  计算完成把计算结果放在result对象中\r\n        var beforetaxCount = this.data.beforetaxCount;\r\n        var specialitemCount = this.data.specialitemCount;\r\n        var marking = this.data.marking;\r\n        if (beforetaxCount == null || beforetaxCount == 0 || beforetaxCount == ''){\r\n            wx.showToast({\r\n                title: '输入正确薪资',\r\n                mask: true,\r\n                icon: 'loading'\r\n            })\r\n            return;\r\n        }\r\n        if (specialitemCount == null || specialitemCount == ''){\r\n            specialitemCount = 0;\r\n        }\r\n        // 开始计算\r\n\r\n        var oldNum = 0.08;\r\n        var medNum = 0.02;\r\n        var unemNum = 0.005;\r\n        var workNum = 0;\r\n        var giveNum = 0;\r\n\r\n        var providentfundNum = 0.08;\r\n\r\n        var insuranceBase = 19935;\r\n        var providentfundBase = 25300;\r\n\r\n        var oldcount = 0;\r\n        var medcount = 0;\r\n        var unemcount = 0;\r\n        var workcount = 0;\r\n        var givecount = 0;\r\n\r\n        var providentfundcount = 0;\r\n\r\n        var privateFee = 0;\r\n        var plusFee = 0;\r\n\r\n        if(this.data.checked){\r\n            if (parseFloat(beforetaxCount) > parseFloat(insuranceBase)) {\r\n                oldcount = parseFloat(insuranceBase) * parseFloat(oldNum);\r\n                medcount = parseFloat(insuranceBase) * parseFloat(medNum);\r\n                unemcount = parseFloat(insuranceBase) * parseFloat(unemNum);\r\n                workcount = parseFloat(insuranceBase) * parseFloat(workNum);\r\n                givecount = parseFloat(insuranceBase) * parseFloat(giveNum);\r\n            } else {\r\n                oldcount = parseFloat(beforetaxCount) * parseFloat(oldNum);\r\n                medcount = parseFloat(beforetaxCount) * parseFloat(medNum);\r\n                unemcount = parseFloat(beforetaxCount) * parseFloat(unemNum);\r\n                workcount = parseFloat(beforetaxCount) * parseFloat(workNum);\r\n                givecount = parseFloat(beforetaxCount) * parseFloat(giveNum);\r\n            }\r\n\r\n            if (parseFloat(beforetaxCount) > parseFloat(providentfundBase)) {\r\n                providentfundcount = parseFloat(providentfundBase) * parseFloat(providentfundNum);\r\n            } else {\r\n                providentfundcount = parseFloat(beforetaxCount) * parseFloat(providentfundNum);\r\n            }\r\n        }\r\n\r\n        // 保险总费用\r\n        var totalInsuranceFee = parseFloat(oldcount) + parseFloat(medcount) + parseFloat(unemcount) + parseFloat(workcount) + parseFloat(givecount);\r\n        // 公积金费用 \r\n        var totalProvidentfundFee = providentfundcount;\r\n\r\n        // 下面的钱 交税\r\n        console.log(this.data.marking);\r\n        var otherFee = parseFloat(beforetaxCount) - parseFloat(totalInsuranceFee) - parseFloat(totalProvidentfundFee) - parseFloat(this.data.marking) - parseFloat(specialitemCount);\r\n        \r\n        if (parseFloat(otherFee) <= 3000 && parseFloat(otherFee) > 0) {\r\n            privateFee = parseFloat(otherFee) * 0.03;\r\n            plusFee = 0;\r\n        }\r\n        if (parseFloat(otherFee) <= 12000 && parseFloat(otherFee) > 3000) {\r\n            privateFee = parseFloat(otherFee) * 0.1;\r\n            plusFee = 210;\r\n        }\r\n        if (parseFloat(otherFee) <= 25000 && parseFloat(otherFee) > 12000) {\r\n            privateFee = parseFloat(otherFee) * 0.2;\r\n            plusFee = 1410;\r\n        }\r\n        if (parseFloat(otherFee) <= 35000 && parseFloat(otherFee) > 25000) {\r\n            privateFee = parseFloat(otherFee) * 0.25;\r\n            plusFee = 2660;\r\n        }\r\n        if (parseFloat(otherFee) <= 55000 && parseFloat(otherFee) > 35000) {\r\n            privateFee = parseFloat(otherFee) * 0.3;\r\n            plusFee = 4410;\r\n        }\r\n        if (parseFloat(otherFee) <= 80000 && parseFloat(otherFee) > 55000) {\r\n            privateFee = parseFloat(otherFee) * 0.35;\r\n            plusFee = 7160;\r\n        }\r\n        if ( parseFloat(otherFee) > 80000) {\r\n            privateFee = parseFloat(otherFee) * 0.45;\r\n            plusFee = 15160;\r\n        }\r\n\r\n        var result = {};\r\n        \r\n        result.insuranceCount = totalInsuranceFee;\r\n        result.providentfundCount = totalProvidentfundFee;\r\n        result.providentfundNum = parseFloat(providentfundNum) * 100;\r\n        result.money = parseFloat(beforetaxCount) - parseFloat(totalInsuranceFee) - parseFloat(totalProvidentfundFee) - parseFloat(privateFee) + parseFloat(plusFee);\r\n        result.privateFee = privateFee - parseFloat(plusFee);\r\n        result.specialitemCount = specialitemCount;\r\n        result.oldNum = parseFloat(oldNum) * 100;\r\n        result.medNum = parseFloat(medNum) * 100;\r\n        result.unemNum = parseFloat(unemNum) * 100;\r\n        result.workNum = parseFloat(workNum) * 100;\r\n        result.giveNum = parseFloat(giveNum) * 100;\r\n\r\n        result.oldcount = parseFloat(oldcount);\r\n        result.medcount = parseFloat(medcount);\r\n        result.unemcount = parseFloat(unemcount);\r\n        result.workcount = parseFloat(workcount);\r\n        result.givecount = parseFloat(givecount);\r\n\r\n        wx.setStorage({\r\n            key: 'result',\r\n            data: result,\r\n            success:function(){\r\n                wx.navigateTo({\r\n                    url: '../calculation/calculationResult',\r\n                })\r\n            }\r\n        })\r\n        \r\n    },\r\n\r\n})把计算好的结果放在result对象中 通过wx.setStorage 放在缓存中，传到下一个页面。最后展示出来。"}
{"title": "记一次mpvue开发完整小程序相关笔记 ", "author": "Rolan", "pub_time": "2019-2-28 00:21", "content": "通过一个月的小程序开发，记录下一点点小心得······先给各位大佬请安了~~~~~~1、wx.previewImage预览图片 关闭后会再次触发onShow方法：在全局变量里定义一个全局变量开关来控制，调用预览图片的时候将其取反不再触发 onShow的事件data(){\r\n    return {\r\n        isShow:true\r\n    }\r\n},\r\nonShow(){\r\nif(this.isShow){\r\n    ...处理事件\r\n}\r\nelse{\r\n    this.isShow = true; \r\n    return;\r\n}\r\n}\r\n复制代码调用 wx.previewImage() 方法前 ，this.isShow = false ; 思路就是用一个全局变量巧妙的阻止预览图片后再次执行，可以看出 wx.previewImage() 是跳到一个新的页面进行图片预览，关闭后又返回了上一个页面，从而导致了 onShow 再次触发。2、mpvue中路由参数获取在接收页面在页面生命周期函数的 onShow 或者 onLoad 函数里通过 this.$root.$mp.query.参数名 进行获取3、mpvue中路由跳转传参(1)、通过wx.navigateTo({\r\n      url: '/test/test?params='+paramsStr\r\n    })\r\n复制代码因为url的限制，当需要传递的参数过多的时候会出现被截取过滤丢失的情况，所以在这种情况下需要通过 encodeURIComponent() 把所有的参数字符串编码后进行传递，在接收页面在页面生命周期函数的onShow或者onLoad函数里通过 this.$root.$mp.query.params 获取到上一个页面传递的参数。再将该参数通过 decodeURIComponent() 方法进行解码处理，即可得到对应的参数hash值。 这里顺带把参数字符串拆分成对象的方法贴出来，方便大家直接使用。// 请求参数序列化\r\nfunction formatParams(params) {\r\n    let str = decodeURIComponent(params);\r\n    let paras = {};\r\n    str = str.split('&');\r\n    for (let n in str) {\r\n        let name = str[n].split('=')[0];\r\n        let val = str[n].split('=')[1];\r\n        paras[name] = val;\r\n    }\r\n    return paras;\r\n}\r\n复制代码eg:params = a=1&b=2&c=3//传递\r\nwx.navigateTo({\r\n      url: '/test/test?params='+encodeURIComponent(params)\r\n    })\r\n复制代码//接收\r\nonShow(){\r\nlet params = this.$root.$mp.query.params;\r\nlet {a,b,c } =  formatParams(params)\r\n//到这里就可以拿到上一个页面传递的多个参数了~奈斯~\r\n}\r\n复制代码PS:如果想要传递对象数据，则需要通过 JSON.stringify() 对数据进行处理一下（2）、通过数据缓存进行数据的页面传递//传递try{\r\n    wx.setStorage({\r\n        key:'',\r\n        data:{...},\r\n        success:()=>{\r\n            //缓存成功 ..进行跳转\r\n            wx.navigatorTo({\r\n            url:'/pages/test/main'\r\n            })\r\n        }\r\n    })\r\n}\r\ncatch(e){}\r\n复制代码//接收 在 onShow 或者 onLoad 页面生命函数里通过wx.getStorage({\r\nkey:'',\r\nsuccess:()=>{\r\n//接收成功\r\n//进行数据页面初始化\r\n}\r\n})\r\n复制代码或者wx.getStorageSync('key')\r\n复制代码获取到参数进行数据页面初始化4、页面数据在unLoad之后没有被初始化通过在main.js里通过Vue.mixin对数据进行恢复初始化Vue.mixin({\r\n  onUnload() {\r\n    if (typeof this.$options.data === 'function') {\r\n      try {\r\n        Object.assign(this.$data, this.$options.data());\r\n      } catch (e) {\r\n        console.log(e)\r\n      }\r\n    }\r\n  }\r\n})\r\n复制代码5、如何检查小程序版本更新进行更新版本？官方文档传送门=> developers.weixin.qq.com/miniprogram… 基本上官方文档的公共方法我都会做一层封装，包括 wx.showToast 等方法均会进行一个处理 检查版本更新也是一样 这边也是参考网上的结合自己封装的代码进行一个整合/* 小程序监听更新信息 */\r\nexport function checkUpdateVersion() {\r\n    //创建 UpdateManager 实例\r\n    const updateManager = wx.getUpdateManager();\r\n    //检测小程序版本更新\r\n    updateManager.onCheckForUpdate((res) => {\r\n        // 请求完新版本信息的回调\r\n        if (res.hasUpdate) {\r\n            //监听小程序有版本更新事件\r\n            updateManager.onUpdateReady(() => {\r\n                showConfirm({\r\n                title: '更新提示',\r\n                content: '新版本已经准备好，是否重启应用？',\r\n                ok(res) {\r\n                    // 新的版本下载完毕，调用 applyUpdate 应用新版本并重启\r\n                    updateManager.applyUpdate();\r\n                }\r\n                })\r\n            })\r\n            //监听小程序更新失败事件\r\n            updateManager.onUpdateFailed(() => {\r\n                // 新版本下载失败\r\n                showConfirm({\r\n                title: '已经有新版本咯~',\r\n                content: '请在微信 “发现-小程序” 页删除当前小程序，重新通过小程序名称搜索打开使用最新版本',\r\n                })\r\n            })\r\n        }\r\n    })\r\n}\r\n复制代码6、小程序获取页面栈信息和参数官网提供了 getCurrentPages() 来获取当前小程序打开的页面的所有页面栈信息，文档是这么写的，打印出来该结果，可以清晰的看到页面栈的相关信息，包括页面路径以及页面参数当我们打开多个对象的时候，这个页面结果也会有多条。 在实际开发中，我会碰到这样一个场景，在用户未登陆的情况下会记录下当前用户操作的页面，自动跳转登陆页，待用户登陆成功后自动跳回上一个未登陆的页面，这个时候就需要通过这个API进行操作处理了。 通过处理，分享一个可以获取当前所有打开的页面的任一页面的栈信息。/* \r\n获取页面栈信息和参数\r\n参数 page 默认获取当前页面 =1\r\n*/\r\nexport function getPagesInfo(page = 1) {\r\n  let routeHistory = getCurrentPages();\r\n\r\n  let length = routeHistory.length;\r\n  let route = routeHistory[length - page]['route']\r\n\r\n  let params = routeHistory[length - page]['options'];\r\n  let url = '';\r\n  let option = '';\r\n  Object.keys(params).forEach(key => {\r\n    option += `${key}=${params[key]}`;\r\n  })\r\n  url = `/${route}${option?'?'+option:''}`;\r\n  url = encodeURIComponent(url)\r\n\r\n  return url;\r\n}\r\n复制代码7、mpvue动态设置样式Style通过Mpvue官网，我们知道这时候当我们需要动态设置一系列样式给Dom渲染的时候，就出现了问题，所以需要多一步对 styleObject 进行处理。 这里也分享一下解决方案!export function styles(obj) {\r\n  let stylesStr = '';\r\n  for (let styleName in obj) {\r\n    if (obj.hasOwnProperty(styleName)) stylesStr += `${styleName.replace(/([A-Z])/g, \"-$1\").toLowerCase()}:${px2rpx(obj[styleName])};`;\r\n  }\r\n  return stylesStr;\r\n}\r\n\r\nexport function px2rpx(str) {\r\n  if (/rpx/.test(str)) return str\r\n  else if (/px/.test(str)) {\r\n    let val = str.substring(0, str.indexOf('px'))\r\n    return `${(val - 0) * 2}rpx`\r\n  } else return str\r\n}\r\n复制代码eg: <div :style='styleObject'></div>\r\n//在以前，可能我们只需要这样\r\ncomputed:{\r\n    styleObject(){\r\n        return {\r\n            backgroundColor:'#fff',\r\n            color:'#000'\r\n        }\r\n    }\r\n}\r\n//在mpvue中，这是不被支持的，所以我们需要通过上面的函数多一层转换，转成样式字符串才可以。\r\n//更改如下\r\ncomputed:{\r\n    styleObject(){\r\n        return styles({\r\n            backgroundColor:'#fff',\r\n            color:'#000'\r\n        })\r\n    }\r\n}\r\n复制代码8、mpvue中设置默认转发分享信息同样在main.js中通过Vue.mixin()里通过API里的 onShareAppMessage() 来设置分享//这里可以默认一套所有页面的默认分享信息\r\n  onShareAppMessage(e) {\r\n    return {\r\n      title: \"***商城\",\r\n      path: \"/pages/home/main\",\r\n      imageUrl: ../../图片路径,\r\n      success: res => {\r\n        showToast({\r\n          title: \"分享成功！\",\r\n          icon: \"success\"\r\n        });\r\n      },\r\n      fail: res => {\r\n        showToast({\r\n          title: \"分享失败！\"\r\n        });\r\n      }\r\n    };\r\n  }\r\n复制代码9、关于v-show使用的相关问题v-show做到的只是切换css样式属性显隐对元素不支持对v-else不支持在实际开发之中，很经常碰到一种情况就是通过 v-show 来控制组件显隐失效的问题，特别是直接对公共组件进行使用的时候，实际上已经直接创建了组件没有达到预期的效果。eg:<template>\r\n    <components v-show='show'></components>\r\n</template>\r\n复制代码这种时候，即使show是 true 组件也同样会被创建出来，没有办法通过该变量来响应对应的显示隐藏状态。最简单粗暴的 解决办法就是用 v-if 来代替 v-show 直接销毁组件。10、通过npm run dev 编译的时候，部分页面跳转提示不存在页面注意检查 dist/app.json 是否与 src/main.json 保持一致，保险方法直接copy一下main.json里的到app.json里即可第一次编译的时候发现找不到tabBar图标，依葫芦画瓢把 src/assets 下的图片拷贝到 dist/assets 即可11、新增页面没有被编译出来新增的页面需要重新通过npm run build 命令来生成对应的mpvue的文件目录，重新npm run dev才可以好了，差不多了，快想不出来还碰上什么问题了~~~~ 第一次发表文章，不喜轻喷..."}
{"title": "小程序开发中的单位如何布局使用？(经验) ", "author": "Rolan", "pub_time": "2019-2-28 00:42", "content": "小程序支持的单位？可以说小程序就是在微信体系网页的另一种表现方式。网页中的单位小程序基本都支持。但实际开发中，我常用到的是以下几种 ↓rpxrpx做为小程序自家系统里的单位，特性是可以根据屏幕宽度进行自适应。rpx官方介绍比如我写一个2:1比例的全屏轮播图，可以这样写：swiper {\r\n width:750rpx;\r\n height:375rpx;\r\n}1rpx = 0.5px = 1物理像素。网页开发中，默认字体一般设置为14px，在小程序中我们就可以设置小程序的默认字体大小为28rpx。px在小程序开发中 rpx基本就代替了px，但在一些特殊的场合，px的表现要比rpx好。兼容ipad时，由于ipad可以横屏和竖屏，并且屏幕宽度可以达到2K以上，如果你的小程序要考虑到兼容ipad，那么还是多考虑使用px吧。覆盖微信原生组件样式。em？？？？可以覆盖微信原生样式？？？是的，只有小程序老玩家才知道的秘密！小程序原生样式是可以覆盖美化的，以 <switch> 组件为例：switch代码片段导入代码片段到开发者工具中，并切换设备模式预览可以发现rpx表现不佳。使用px反而更好。em与remem与rem在H5的网页开发上可以大放异彩，但小程序中因为有rpx的存在，em与rem使用的就少了。基本只有在一些对字体宽度有特效的情况下才会使用。比如首行缩进。vw、vh和百分比vw：视窗宽度，1vw等于视窗宽度的1%。vh：视窗高度，1vh等于视窗高度的1%。%：父级容器的宽度百分百。——————————————————————***重点来了***————————————————————————————calc() 的使用前面讲了单位，那么我们现在来聊聊怎么使用这些单位了。小程序是网页的一种，支持css，也支持calc()。这里吃下书：calc() 函数用于动态计算长度值。 ● 需要注意的是，运算符前后都需要保留一个空格，例如：width: calc(100% - 10px)；\r\n\r\n ● 任何长度值都可以使用calc()函数进行计算；\r\n\r\n ● calc()函数支持 \"+\", \"-\", \"*\", \"/\" 运算；\r\n\r\n ● calc()函数使用标准的数学运算优先级规则；\r\n使用场景示例垂直导航页，常用于外卖订餐或者商城的二级分类页。上半部分是定死高度375rpx的轮播图区域，下半部分是可以随设备高度变化的可滚动的区域。容器高度可以这样写：{\r\n    height:calc(100vh - 375rpx)\r\n}原文地址：https://developers.weixin.qq.com/community/develop/article/doc/000c0e6fec44f8bec0287dcd656813"}
{"title": "小程序的奇技淫巧之 computed 计算属性 ", "author": "Rolan", "pub_time": "2019-2-28 00:53", "content": "小程序的出身，基于安全和管控的考虑，使用了双线程的设计，同时对于 DOM 操作、动态创建 DOM 这些都隔离了。在写代码的时候，模版语法不支持函数计算等，computed 的方法就显得十分重要了。自定义组件小程序的自定义组件涉及功能很多，这篇只针对computed展开来讲。computed比较适合较复杂逻辑的计算，同时在小程序无法在模板里使用methods这样的场景下，计算属性的需求就更强烈了。behaviors自定义组件中，提供了behaviors的使用和定义。从官方文档我们能看到：behaviors是用于组件间代码共享的特性，类似于一些编程语言中的“mixins”或“traits”。每个behavior可以包含一组属性、数据、生命周期函数和方法，组件引用它时，它的属性、数据和方法会被合并到组件中，生命周期函数也会在对应时机被调用。每个组件可以引用多个behavior。简单来说，我们能通过behaviors来重构Component的能力。如果说，我们能“混入”Component，其实基本很多能力都能实现啦。其实我们自己封装一层的MyComponent也能达到一定的效果，但是这样的拓展性会变得很糟。通过behaviors的方式，每个组件可以按需引入自己需要的behavior啦。computed 实现我们来梳理下这里的逻辑，我们需要一个computed能力，需要处理的主要是：setData的时候，根据computed来计算哪些数据需要处理。所以我们要做的是：记下来需要computed的变量。在每次setData之前，看看是否包含到需要computed的变量，匹配到了就进行computed处理。使用处理后的数据，进行setData。官方已经提供了计算属性实现的behavior，大家也可以尽情翻看实现的源码，和使用这种拓展能力。Page 的超集hack 实现 Page computed 能力想必大家都会有疑惑，Component里支持behaviors，但是Page依然写起来很不方便呀。虽然所有的Page最终也能通过Component来实现，但是这样是否需要多包装一层呢？答案是不用。使用 Component 构造器构造页面Component是Page的超集，因此可以使用Component构造器构造页面。同样的，我们来看看官方文档：事实上，小程序的页面也可以视为自定义组件。因而，页面也可以使用Component构造器构造，拥有与普通组件一样的定义段与实例方法。但此时要求对应json文件中包含usingComponents定义段。也就是说，我们这样的页面：123456789101112131415Page({  data: {    logs: []  },  onLoad(query) {    // 如访问页面`/pages/index/index?paramA=123&paramB=xyz`，如果声明有属性(`properties`)`paramA`或`paramB`，则它们会被赋值为`123`或`xyz`    query.paramA // 页面参数 paramA 的值    query.paramA // 页面参数 paramB 的值    this.setData({      logs: (wx.getStorageSync(\"logs\") || []).map((log: number) => {        return formatTime(new Date(log));      })    });  }});可以这么写：123{  \"usingComponents\": {}}12345678910111213141516171819202122Component({  // 组件的属性可以用于接收页面的参数  properties: {    paramA: Number,    paramB: String,  },  data: {    logs: []  },  methods: {    onLoad() {      // 如访问页面`/pages/index/index?paramA=123&paramB=xyz`，如果声明有属性(`properties`)`paramA`或`paramB`，则它们会被赋值为`123`或`xyz`      this.data.paramA // 页面参数 paramA 的值      this.data.paramB // 页面参数 paramB 的值      this.setData({        logs: (wx.getStorageSync(\"logs\") || []).map((log: number) => {          return formatTime(new Date(log));        })      });    }  }});这样，我们就能愉快地使用behaviors啦。12345678910111213141516171819202122232425262728const computedBehavior = require(\"miniprogram-computed\");Component({  behaviors: [computedBehavior],  data: {    logs: []  },  computed: {    logsAfterComputed() {      // 计算属性同样挂在 data 上，每当进行 setData 的时候会重新计算      // 比如此字段可以通过 this.data.b 获取到      return this.data.logs.map(x => {        return {          log: x,          logAfterCompute: x + \"logAfterCompute\"        };      });    }  },  methods: {    onLoad() {      this.setData({        logs: (wx.getStorageSync(\"logs\") || []).map((log: number) => {          return formatTime(new Date(log));        })      });    }  }});使用Component构造器构造页面，需要注意：组件的属性可以用于接收页面的参数，如访问页面/pages/index/index?paramA=123&paramB=xyz，如果声明有属性(properties)paramA或paramB，则它们会被赋值为123或xyz。（可参考官方代码示例）页面的生命周期方法（即on开头的方法，如上面的onLoad），应写在methods定义段中。这样，你就能愉快地在代码里面使用computed计算属性啦~更多的，也可以参考本人的wxapp-typescript-demo中的log page，后续也会持续更新方便好用的能力 demo。参考Component构造器behaviors结束语小程序提供的能力其实挺多的，但是很多时候由于文档很多、查找不方便，会导致我们有些很好用的功能没有发现，然后苦逼地一边吐槽一边悲壮地撸代码。官方提供的目前只有computed，大家可以看看，是不是还可以做watch之类的能力呢？查看Github有更多内容噢：https://github.com/godbasin"}
{"title": "小程序开发之影分身术 ", "author": "Rolan", "pub_time": "2019-3-1 00:12", "content": "前言影分身术，看过火影的都知道，一个本体，多个分身。大家肯定要问了，那小程序开发跟影分身术也能扯上关系？没错，那自然就是：一套代码，多个小程序啦。各位先别翻白眼，且听我细细说来。。。如今小程序发展如日中天，再加上微信的力推，很多公司的业务也都慢慢的转向小程序，这让我这个安卓开发，也不得不开始了小程序开发之旅。然而随着公司的发展，客户越来越多，核心功能相同的小程序，需要上架多个小程序分别给不同的客户使用，每个小程序之间又存在这一小部分的定制化，比如界面展示的不同、小功能的差异等等。这可让我这个刚接触小程序开发的前端菜鸟抓狂了，每个小程序复制一份代码出来，然后做定制化的修改？这岂不是如果哪天核心业务有改动，我得对每套代码分别改动一次？不行，即使是菜鸟，对这种弄出多套重复代码的行为也是无法容忍的！！于是，就有了针对这种场景下的一个解决方案：给小程序开发来个影分身术。Github地址： https://github.com/BakerJQ/WeAppBunXin该项目基于 Taro 框架，由 凹凸实验室 开源，非常感谢他们的努力付出。之所以选用Taro，主要是因为它采用React语法标准，而本人之前有过ReactNative开发经验。由于本人接触前端开发时间不长，文中若出现了错误或者有更好的方案，欢迎各位包容和指正，万分感谢。影分身之基础配置影分身的能力，主要来源于Taro所提供的编译能力，所以需要对Taro的 编译配置 和 编译配置详情 有所了解。我们先来看看配置的相关文件目录：config目录为Taro初始化后的默认配置目录，图中蓝色框框内的三个文件（dev、index、prod）为默认生成的配置文件，剩下的文件，则为分身所需的配置。图中配置了三个分身，我们以channel1为例，config是该分身的一些配置，project.config.json就是该分身小程序的基本配置，如：{\r\n    \"miniprogramRoot\": \"./\",\r\n    \"projectname\": \"channel1\",\r\n    \"description\": \"channel1\",\r\n    \"appid\": \"wx8888888888888\",\r\n    ...\r\n}\r\nchannel.js文件，则是用来指定，当前需要编译哪个小程序，如：module.exports = {\r\n  channel: 'channel1'\r\n}\r\n在默认的编译配置入口文件index.js中，我们需要配置小程序的输出目录，配置如下：const channelInfo = require('./channel')\r\nconst config = {\r\n    ...\r\n    //输入目录为dist_channel1\r\n    outputRoot: 'dist_' + channelInfo.channel,\r\n    ...\r\n    //讲config/channel1/project.config.json文件拷贝到dist_channel1下\r\n    copy: {\r\n    patterns: [\r\n      {\r\n        from: 'config/' + channelInfo.channel + '/project.config.json',\r\n        to: 'dist_' + channelInfo.channel + '/project.config.json'\r\n      }\r\n    ],\r\n    ...\r\n    }\r\n    ...\r\n}\r\n执行Taro的 小程序编译命令 后，将会生成该分身对应的小程序代码文件夹dist_channel1，直接使用小程序开发者工具打开该目录，就可以进行channel1小程序的预览了。通过这些配置，我们就可以通过同一套代码，生成多个不同的小程序啦！当然，这些小程序的内容是完全一样的，顶多就是project.config.json中配置的名字、appid有不同而已。那么下面，我们就开始看看如何实现生成多个有差异化的小程序。在具体实现之前，我们需要知道Taro两个重要的配置： 全局变量”defineConstants” 和 别名”alias” 。影分身之样式分身首先，我们来看看最常见的一种需求，那就是不同小程序之间，样式上的差别。我们先来看两张图。小程序A小程序B在样式上，这两个小程序目前的区别有：主色调不同对应图片资源不同排列样式不同建立分身目录第一步，在src下为每个分身小程序建立一个目录，名字最好与channel.js中的配置一样，如下图：放置样式差异以之前的“小程序A”来举例：其中assets文件夹就是该小程序的资源文件，即各种蓝色的图标。app.less为全局的样式文件，内容如下：@main_color: #1296db;\r\n.main_color_txt {\r\n  color: @main_color\r\n}\r\nChannelStyle.ts文件则为可能在代码中需要用到的样式：const ChannelStyle = {\r\n  mainColor: '#1296db'\r\n}\r\nexport default ChannelStyle\r\n配置别名在放置好各类样式差异后，就可以进行全局变量和别名的配置了，在项目的config下的index.js中做如下配置const config = {\r\n  ...\r\n  alias: {\r\n    '@/channel': path.resolve(__dirname, '..', 'src/channel/' + channelInfo.channel),\r\n    '@/assets': path.resolve(__dirname, '..', 'src/channel/' + channelInfo.channel + '/assets'),\r\n    '@/app_style': path.resolve(__dirname, '..', 'src/channel/' + channelInfo.channel + '/app.less'),\r\n  }\r\n  ...\r\n}\r\n这样，在代码中就可以通过别名进行引用了//代码中需要用到ChannelStyle中的样式\r\nimport ChannelStyle from '@/channel/ChannelStyle'\r\n//app.tsx入口文件引用全局样式\r\nimport '@/app_style'\r\n//引用资源图片\r\n<Image src={require('@/assets/icon.png')} />\r\n另外请注意，由于目前Taro还未在.less等样式文件中支持别名，所以无法通过类似@import ‘@/app_style’的方式进行引用，所以目前需要在每个分身包下放置全量的差异样式配置全局变量由于对于TabBar的配置，是纯字符串的形式，无法通过别名配置，所以需要使用另一种配置方式，也就是全局变量，在index.js的配置方式如下：const config = {\r\n  defineConstants: {\r\n    ASSETS_PATH: 'channel/'+channelInfo.channel+'/assets'\r\n  }\r\n}\r\n但是主色调每个分身都不一样，所以需要在分身的配置文件中配置，就是基础配置中，分身文件夹下的config.js，在其中加入全局变量的配置：module.exports = {\r\n  ...\r\n  defineConstants: {\r\n    MAIN_COLOR: '#1296db'\r\n  },\r\n  ...\r\n}\r\n全局变量在代码中可以直接使用，如app.tsx中TabBar的配置：config: Config = {\r\n    ...\r\n    tabBar: {\r\n      ...\r\n      selectedColor: MAIN_COLOR,\r\n      list: [\r\n        {\r\n          pagePath: 'pages/index/index',\r\n          text: '首页',\r\n          iconPath: ASSETS_PATH + '/home_u.png',\r\n          selectedIconPath: ASSETS_PATH + '/home_s.png'\r\n        },\r\n        ...\r\n      ]\r\n    }\r\n  }\r\n配置合并在配置完成之后，在index.js文件最后的合并代码中，加上我们定义的分身配置：module.exports = function (merge) {\r\n  ...\r\n  //默认的原始代码为return merge({}, config, envConfig)\r\n  return merge({}, config, envConfig, require('./' + channelInfo.channel + \"/config\"))\r\n}\r\n样式分身小结如此，根据“小程序B”的资源文件和主题色配置之后，通过修改channel.js中的编译分身名，就可以生成这两个小程序了。我们可能还发现，“小程序A”和“小程序B”的样式差异，除了资源图片和主题色之外，“开发”页面的布局方式也有差异，这该怎么处理呢？没错，还是通过别名指定less文件的方式，为各页面指定对应的样式文件。如果说在实际业务中，不同的小程序存在明显的主题样式风格差异的话，建议可以建立主题包，然后为不同的小程序分身配置不同的主题包，如：//分身配置\r\nmodule.exports = {\r\n  ...\r\n  alias: {\r\n    '@/theme': path.resolve(__dirname, '..', '../src/theme/theme1'),\r\n    ...\r\n  }\r\n  ...\r\n}\r\n//文件引用\r\nimport '@/theme/dev.less'\r\n影分身之功能分身除了样式差异之外，有定制化属性的小程序一定也会存在一定的功能性差异。细心的小伙伴可能发现了，“小程序A”和“小程序B”开发页面的条目数是不一样的。“小程序A”并没有FireWall这一项，而且，这两个小程序的前两个条目Java和JSX的顺序是不一样的。不仅如此，如果运行小程序，点击各项的话你会发现，点击C++这一项，“小程序B”是跳转到条目详情页面，而“小程序A”则是跳转到“管理”Tab页。类似这种功能性的差异，我们该如何处理呢？定义页面配置我所想到的思路是，给具有差异化的页面，提供差异化的配置项，然后通过合并的方式，合并具有差异的分身配置。我们先来看定义完成后的配置目录，该目录在src下：以“开发“页面为例，在DevConfig.ts中，我定义了如下的配置：import Taro from \"@tarojs/taro\";\r\n//页面配置\r\nexport default {\r\n  dev: {\r\n    items: {//条目\r\n      item1: {//条目1\r\n        img: require('@/assets/jsx.png'),//图片\r\n        txt: 'JSX',//文字\r\n        onItemClick: () => {//点击跳转事件\r\n          toPage('JSX', require('@/assets/jsx.png'))\r\n        }\r\n      },\r\n      item2: {...},\r\n      ...\r\n    }\r\n  }\r\n}\r\n//页面跳转\r\nfunction toPage(title, img){\r\n  Taro.navigateTo({url: '/pages/dev/DevInfo?title='+title+'&img='+img})\r\n}\r\n定义差异合并同时，diff包下的ChannelConfigDiff.ts文件，作为差异配置文件，其内容如下：export default (config, merge)=>{\r\n  return merge([{}, config])\r\n}\r\n可以看出，这其实就是把传入的config原封不动的返回了，因为对于项目主体来说，config是不需要改变的，具体的用途，会在下面说明。而MultiChannelConfig.ts则为最终的各页面配置，内容如下：import merge from 'deepmerge'\r\nimport ChannelConfigDiff from '@/diff/ChannelConfigDiff'\r\n//开发页面配置\r\nimport DevConfig from './pages/DevConfig'\r\n//合并基本页面配置\r\nconst baseConfig = Object.assign({}, DevConfig)\r\n//合并差异页面配置\r\nconst config = ChannelConfigDiff(baseConfig, merge.all)\r\n//开发页面最终配置\r\nexport const devConfig = config.dev\r\n定义差异配置在上面的定义中，我们发现ChannelConfigDiff是根据别名引用的，现在大家应该明白ChannelConfigDiff.ts文件的作用了吧？没错，就是通过在各分身中加入这个文件，并编写配置。以“小程序A”为例，diff目录如下：在channel2的ChannelConfigDiff.ts中，只需要配置具体的差异项即可，未配置的则采用默认的配置:const dev = {\r\n  dev: {\r\n    items: {\r\n      item1: {//定义第一个item为java内容\r\n        img: require('@/assets/java.png'),\r\n        txt: 'Java',\r\n        onItemClick: () => {\r\n          toPage('Java', require('@/assets/java.png'))\r\n        }\r\n      },\r\n      item2: {...},//第二个item为jsx内容\r\n      item5: null,//第五个item（FireWall）为空\r\n      item8: {\r\n        onItemClick: () => {//最后一个item（C++）点击后跳转TAB\r\n          Taro.switchTab({url: '/pages/index/Manage'})\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n//将dev配置合并到原始整体配置\r\nexport default (config, merge) => {\r\n  return merge([{}, config, dev])\r\n}\r\n可以看到，该配置中，将item1（原jsx）和item2（原java）的内容对调，将item5（原FireWall）置空，将item8（原C++）点击事件改变。通过这些配置，以达到实现“小程序A”中的功能差异。最后，别忘了别名的定义，在index.js中，别名配置为：'@/diff': path.resolve(__dirname, '..', 'src/config/diff'),\r\n在channel2的config.js中，别名配置为：'@/diff': path.resolve(__dirname, '..', '../src/channel/channel2/diff'),\r\n功能分身小结如果有了其他的页面差异的话，通过类似的增加配置，来进行差异化处理，文件的目录格式并无要求，只需要保证配置文件名一致、别名配置正确就可以了。这时，编译过后，生成的“小程序A”就拥有样式和功能差异化的“开发”页面了。通过这种方式进行差异化配置，就要求对业务有较好的理解和对组件的合理拆分，并且定义出合理的配置项。影分身之大差异分身即便使用了样式分身和功能分身，依然可能出现一些巨大差异的定制化需求，这些巨大的差异导致样式分身和功能分身的配置成本过大，那这种情况下，该如何是好呢？如果真的出现这种情况，那也只好断臂求生了 —— 那就是整体页面的替换。我们来看看“小程序A”和“小程序B”的“管理页面”：我们假设“小程序B”的“管理”页很难通过配置的方式去做差异化，那么这时，我们只有专门写一个新页面，目录如下：编写新页面其中pages下的就是专属于channel3的页面页面替换替换页面的方式，其实也是通过全局变量。index.js:defineConstants: {\r\n  PAGE_MANAGE: 'pages/index/Manage',\r\n}\r\nchannel3的config.js:defineConstants: {\r\n  PAGE_MANAGE: 'channel/channel3/pages/index/Manage'\r\n},\r\napp.tsx的页面配置:config: Config = {\r\n  pages: [\r\n    ...\r\n    PAGE_MANAGE\r\n  ],\r\n  ...\r\n  tabBar: {\r\n    ...\r\n    list: [\r\n      ...\r\n      {\r\n        pagePath: PAGE_MANAGE,\r\n        ...\r\n      }\r\n    ]\r\n  }\r\n}\r\n如此，编译后，channel3生成“小程序B”的“管理”页面，就是channel3独有的页面了。总结本文所提供的，只是我能够想到的一种解决“多个核心功能类似的小程序需要维护多套代码”这种窘境的方法，如果有更好的方法，希望各位能够告诉我，非常感谢。由于本人只是一个刚接触前端不久的安卓开发，还有许多需要学习的地方，如果文中有误，欢迎指正批评。具体的代码可以到Github查阅，也欢迎各位Star和提Issue。最后，再次贴一下Github地址： https://github.com/BakerJQ/WeAppBunXin"}
{"title": "从前端程序员的视角看小程序的稳定性保障 ", "author": "Rolan", "pub_time": "2019-3-1 00:31", "content": "当我们谈业务稳定性的时候，通常是指后端工程师从架构的角度来看的，例如限流和降级、流量调度、业务开关、容量压测等，但监控也是整个业务稳定性建设中不可或缺的一环，例如对业务和前端的监控，以保证出现问题的时候，可以第一时间找到根因所在。今天，我们就结合小程序的场景，来看看如何做好小程序的监控。本文转载至InfoQ大前端技术号「前端之巅」，作者慕扉，阿里巴巴高级前端工程师。小程序与 H5 的不同小程序和 H5 都属于移动端场景下的技术选择方案，那么这里介绍一下小程序与 H5 的不同。1. 运行环境的不同传统的 H5 的运行环境是浏览器，包括 webview，其中浏览器提供 window、document 等 BOM 对象；小程序的逻辑层和渲染层是分开的，逻辑层运行在 JSCore 中，并没有一个完整的浏览器对象，所以缺少相关的 DOM API 和 BOM API。2. 开发成本的不同H5 的开发，涉及到开发工具、前端框架、模块管理工具、任务管理工具、UI 库的选择、接口调用工具及浏览器兼容性等；小程序的开发，指定环境的小程序会提供开发者工具、API 及规范的开发标准。由于小程序是跑在指定的环境下的，同时 API 是指定环境下提供的，所以不用考虑浏览器的兼容性。在 H5 开发中，前端常用的 HTML/CSS 在不同的小程序中都有指定的文件标准。例如：在微信小程序中使用 WXML/WXSS；在支付宝小程序、钉钉 E 应用中使用 AXML/ACSS；在百度智能小程序中使用 SWAN/CSS；......开发规范在指定的官方文档中都会有明确的使用介绍，使用方法与原来 H5 的开发大同小异，所以上手开发相对容易。3. 使用体验的不同H5 页面需要在浏览器中渲染，在复杂的业务逻辑或者丰富的页面交互时会有卡顿情况；小程序除首次使用略慢，页面切换及跳转等非常顺滑，接近 Native。通过以上几点小程序和 H5 的不同的介绍，我们可以发现原来针对 H5 页面的监控无法直接监控小程序；同时由于小程序封闭性较强，不同的小程序在标准上也略有不同，如微信小程序、支付宝小程序及钉钉 E 应用等等小程序在使用标准及开放的 API 方面也会有一些差异，所以针对小程序的监控与针对 Web 应用的监控会有所不同。小程序监控的现状现在针对小程序监控的大概分为以下几类：1. 小程序的数据统计分析，助力小程序运营相关产品: 微信小程序助手、阿拉丁小程序统计平台等；特点：大部分是针对微信小程序提供相应的数据统计分析能力，从多维度分析小程序相关用户数据，适用于小程序运营，但缺乏对于用户体验，小程序性能的监控。2. 小程序错误监控相关产品: FunDebug 等；特点：监控小程序使用户出现的错误，帮助开发者发现并解决小程序错误，但缺乏对于小程序全局性能的监控，对于缓慢请求，缓慢页面没法监测。3. 小程序性能监控相关产品: FrontJS、听云小程序监控等；特点：主要提供性能相关数据，包括 JS 错误、网络请求响应情况等。但是只支持微信小程序，而且没有办法把小程序的性能与后台应用的性能关联起来，没法形成端到端的监控。通过上面对现有的小程序监控产品分析，存在以下问题：无法支持所有的小程序监控，主要支持微信小程序；支持多类小程序监控的产品，提供的小程序相关数据较少，主要集中在错误监控；没有后台应用服务的性能监控，无法从小程序上的性能问题追溯到后台应用代码和数据库，无法形成端到端的监控。基于以上情况，阿里云 ARMS 前端监控重磅推出小程序监控，旨在帮助端到端的快速定位小程序问题，提升小程序的用户体验。小程序监控提供的能力阿里云 ARMS 前端监控此次重点推出的小程序监控有以下特点：1. 覆盖各类符合标准规范的小程序首先解释一下这里所说的\"标准规范的小程序\"，即包含 App 和 Page 两层:App 用来描述整体程序，包含: onError 事件；Page 用来描述各个页面，包含: onShow、onHide、onUnload 事件。小程序的运行环境依赖于对应的客户端，各类小程序的 DSL 设计看起来很像，但细节上的差别还是比较多，并且已有了分化的趋势。在这种情况下，阿里云 ARMS 前端监控为了更好的支持小程序的监控诉求，提供以下小程序监控的场景：微信小程序支付宝小程序钉钉 E 应用其他类别小程序由于小程序发展迅速，现在无法针对各类小程序都提供对应的监控 SDK，所以不属于微信小程序、支付宝小程序和钉钉 E 应用的小程序可选择其他类别小程序的场景接入进行监控，但要满足上面说的\"标准规范的小程序\"前提，同时支持 npm 包。2. 完善的性能监控指标基础业务指标，帮助了解小程序应用的使用情况：应用总 PV/UV页面维度的 PV/UV小程序各维度指标：手机型号操作系统版本微信 / 支付宝等相应的 APP 版本网络等JS 错误分析：JS 错误率、错误聚类、JS 错误堆栈及错误定位等API 请求追踪：API 请求成功率、API 请求耗时及 API 请求的链路追踪自定义事件统计支持业务上自定义事件 sum/avg 统计3. 可通过配置选择上报方式由于业务方使用监控的诉求不同，我们不仅支持优雅的静默数据上报，也支持使用开放的统计能力进行自定义上报。具体可查看官网的前端监控接入概述中的小程序场景相关文档：https://help.aliyun.com/document_detail/106086.html"}
{"title": "利用 Webpack 实现小程序多项目管理 ", "author": "Rolan", "pub_time": "2019-2-25 00:23", "content": "故事是这样的产品小姐姐：“我要做一堆小程序，一周上线一到两个没问题吧”码畜小哥哥：“你他喵是不是傻，做那么多干什么”产品小姐姐：“蹭些流量呀，用户量多了就可以考虑转化流量给公司的 App”码畜小哥哥：“fuck好的”码畜小哥开始架构小程序杂，放一个项目方便管理小程序多，代码要能够复用团队开发，代码风格要统一码畜小哥开始建项目这是单个小程序的基本目录结构，没问题当一个项目有多个小程序的时候，好像也没问题当多个小程序都用到同一个组件 com3 时，小哥发现代码没法复用，需要复制黏贴思考了一下，那么把组件目录移到外面，这样不就可以复用了吗感觉很好，小哥这时在微信开发者工具打开 demo1，发现报错了原来小程序是以当前项目作为根目录，components 目录已经不在 demo1 目录范围内，所以是引用不到的小哥想到了 Webpack1. 整理目录apps/：存放全部小程序build/：存放构建脚本common/：存放公共方法components/：存放公共组件styles/：存放公共样式templates/：存放公共模板大概长这样2. 编写构建脚本package.jsonscript: {\r\n  \"dev\": \"webpack --config build/webpack.config.js\"\r\n}build/webpack.config.js思路就是利用 CopyWebpackPlugin 同步指定的文件到小程序目录下const CopyWebpackPlugin = require('copy-webpack-plugin')\r\nconst utils = require('./utils')\r\n\r\n// 获取 apps 目录下的小程序并指定公共文件目录命名\r\nfunction copyToApps(dir) {\r\n  let r = []\r\n\r\n  utils\r\n    .exec(`cd ${utils.resolve('apps')} && ls`)\r\n    .split('\\n')\r\n    .map(app => {\r\n      r.push({\r\n        from: utils.resolve(dir),\r\n        to: utils.resolve(`apps/${app}/_${dir}`)\r\n      })\r\n    })\r\n\r\n  return r\r\n}\r\n\r\nmodule.exports = {\r\n  watch: true,\r\n\r\n  // 监听入口文件，保存便会刷新\r\n  entry: utils.resolve('index.js'),\r\n\r\n  output: {\r\n    path: utils.resolve('.tmp'),\r\n    filename: 'bundle.js'\r\n  },\r\n\r\n  plugins: [\r\n    // 同步指定的公共文件到所有小程序目录下\r\n    new CopyWebpackPlugin([\r\n      ...copyToApps('styles'),\r\n      ...copyToApps('common'),\r\n      ...copyToApps('templates'),\r\n      ...copyToApps('components')\r\n    ])\r\n  ]\r\n}3. 启动本地开发npm run dev现在公用的代码已经自动同步到小程序目录下，以下划线开头，当改动公共代码也会自动同步给小程序调用调用方式长这样import utils from './_common/utils'\r\nimport com3 from './_components/com3'@import './_styles/index.wxss';<import src=\"./_templates/index.wxml\" />代码风格校验package.jsonscript: {\r\n  \"lint\": \"eslint apps/\"\r\n}.eslintrc.jsmodule.exports = {\r\n  extends: 'standard',\r\n\r\n  // 将小程序特有的全局变量排除下\r\n  globals: {\r\n    Page: true,\r\n    Component: true,\r\n    App: true,\r\n    getApp: true,\r\n    wx: true\r\n  },\r\n\r\n  rules: {\r\n    'space-before-function-paren': ['error', 'never'],\r\n    'no-unused-vars': [\r\n      'error',\r\n      {\r\n        // 小程序还没支持 ES7，这个是用来兼容 async/await\r\n        varsIgnorePattern: 'regeneratorRuntime'\r\n      }\r\n    ]\r\n  }\r\n}然后借助 husky 在每次 git commit 前执行校验script: {\r\n  \"precommit\": \"npm run lint\"\r\n},\r\n\r\ndevDependencies: {\r\n  \"husky\": \"^0.14.3\"\r\n}清理最后小哥还加了个清理命令， 便于重新生成公共代码package.jsonscript: {\r\n  \"clean\": \"node build/clean.js\"\r\n}build/clean.jsconst rimraf = require('rimraf')\r\nconst utils = require('./utils')\r\n\r\nfunction log(dir) {\r\n  console.log(`cleaning ${dir}`)\r\n}\r\n\r\nrimraf(utils.resolve('.tmp'), () => log('.tmp'))\r\n\r\nutils\r\n  .exec(`cd ${utils.resolve('apps')} && ls`)\r\n  .split('\\n')\r\n  .map(app => {\r\n    ;[\r\n      `${app}/_styles`,\r\n      `${app}/_common`,\r\n      `${app}/_templates`,\r\n      `${app}/_components`\r\n    ].map(m => {\r\n      rimraf(utils.resolve(`apps/${m}`), () => log(m))\r\n    })\r\n  })码畜小哥心满意足“可以少加班了”"}
{"title": "canvas绘图按照contain或者cover方式适配，并居中显示 ", "author": "Rolan", "pub_time": "2019-2-19 00:42", "content": "canvas绘图时drawImage，需要绘制的图片大小不同，比例各异，所以就需要像html+css布局那样，需要contain和cover来满足不同的需求。contain保持纵横比缩放图片，使图片的长边能完全显示出来。也就是说，可以完整地将图片显示出来。图片按照contain模式放到固定盒子的矩形内，则需要对图片进行一定的缩放。原则是：如果图片宽高不等，使图片的长边能完全显示出来，则原图片高的一边缩放后等于固定盒子对应的一边，等比例求出另外一边，如果图片宽高相等，则根据固定盒子的宽高来决定缩放后图片的宽高，固定盒子的宽大于高，则缩放后的图片高等于固定盒子的高度，对应求出另外一边即可，反之亦然。        /**\r\n         * @param {Number} sx 固定盒子的x坐标,sy 固定盒子的y左标\r\n         * @param {Number} box_w 固定盒子的宽, box_h 固定盒子的高\r\n         * @param {Number} source_w 原图片的宽, source_h 原图片的高\r\n         * @return {Object} {drawImage的参数，缩放后图片的x坐标，y坐标，宽和高},对应drawImage(imageResource, dx, dy, dWidth, dHeight)\r\n         */\r\n        function containImg(sx, sy , box_w, box_h, source_w, source_h){\r\n            var dx = sx,\r\n                dy = sy,\r\n                dWidth = box_w,\r\n                dHeight = box_h;\r\n            if(source_w > source_h || (source_w == source_h && box_w < box_h)){\r\n                dHeight = source_h*dWidth/source_w;\r\n            dy =  sy + (box_h-dHeight)/2;\r\n\r\n            }else if(source_w < source_h || (source_w == source_h && box_w > box_h)){\r\n                dWidth = source_w*dHeight/source_h;\r\n                dx = sx + (box_w-dWidth)/2;\r\n            }\r\n            return{\r\n                dx,\r\n                dy,\r\n                dWidth,\r\n                dHeight\r\n            }\r\n        }\r\n\r\n\r\n        var c=document.getElementById(\"myCanvas\");\r\n        var ctx=c.getContext(\"2d\");\r\n        ctx.fillStyle = '#e1f0ff';\r\n        //固定盒子的位置和大小--图片需要放在这个盒子内\r\n        ctx.fillRect(30, 30, 150, 200);\r\n\r\n        var img = new Image();\r\n        img.onload = function () {\r\n            console.log(img.width,img.height);\r\n            \r\n            var imgRect = containImg(30,30,150,200,img.width,img.height);\r\n            console.log('imgRect',imgRect);\r\n            ctx.drawImage(img, imgRect.dx, imgRect.dy, imgRect.dWidth, imgRect.dHeight); \r\n            \r\n        }\r\n        img.src = \"./timg2.jpg\";  \r\n        //注：img预加载模式下，onload应该放在为src赋值的上面，以避免已有缓存的情况下无法触发onload事件从而导致onload中的事件不执行的情况发生cover保持纵横比缩放图片，只保证图片的短边能完全显示出来。也就是说，图片通常只在水平或垂直方向是完整的，另一个方向将会发生截取。原理：按照固定盒子的比例截取图片的部分        /**\r\n         * @param {Number} box_w 固定盒子的宽, box_h 固定盒子的高\r\n         * @param {Number} source_w 原图片的宽, source_h 原图片的高\r\n         * @return {Object} {截取的图片信息}，对应drawImage(imageResource, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)参数\r\n        */\r\n        function coverImg(box_w, box_h, source_w, source_h){\r\n            var sx = 0,\r\n                sy = 0,\r\n                sWidth = source_w,\r\n                sHeight = source_h;\r\n            if(source_w > source_h || (source_w == source_h && box_w < box_h)){\r\n                sWidth = box_w*sHeight/box_h;\r\n                sx = (source_w-sWidth)/2;\r\n            }else if(source_w < source_h || (source_w == source_h && box_w > box_h)){\r\n                sHeight = box_h*sWidth/box_w;\r\n                sy = (source_h-sHeight)/2;\r\n            }\r\n            return{\r\n                sx,\r\n                sy,\r\n                sWidth,\r\n                sHeight\r\n            }\r\n        }\r\n\r\n\r\n        var c=document.getElementById(\"myCanvas\");\r\n        var ctx=c.getContext(\"2d\");\r\n        ctx.fillStyle = '#e1f0ff';\r\n        //固定盒子的位置和大小--图片需要放在这个盒子内\r\n        ctx.fillRect(30, 30, 150, 200);\r\n\r\n        var img = new Image();\r\n        img.onload = function () {\r\n            console.log(img.width,img.height);\r\n            \r\n            var imgRect = coverImg(150,200,img.width,img.height);\r\n            console.log('imgRect',imgRect);\r\n            ctx.drawImage(img, imgRect.sx, imgRect.sy, imgRect.sWidth, imgRect.sHeight, 30, 30, 150, 200); \r\n        }\r\n        img.src = \"./timg2.jpg\";  \r\n        //注：img预加载模式下，onload应该放在为src赋值的上面，以避免已有缓存的情况下无法触发onload事件从而导致onload中的事件不执行的情况发生"}
{"title": "玩转小程序转发——小程序探索 ", "author": "Rolan", "pub_time": "2019-2-19 00:32", "content": "转发的意义转发即是分享，分享带动了事物去中心化，实现网络化，最终走向云处理化通过微信平台，转发即是聊天流量时代，转发即是引流官方转发示例onShareAppMessage(Object)监听用户点击页面内转发按钮（<button> 组件 open-type=\"share\"）或右上角菜单“转发”按钮的行为，并自定义转发内容。注意：只有定义了此事件处理函数，右上角菜单才会显示“转发”按钮Object 参数说明：此事件需要 return 一个 Object，用于自定义转发内容，返回内容如下：自定义转发内容Page({\r\n  onShareAppMessage(res) {\r\n    if (res.from === 'button') {\r\n      // 来自页面内转发按钮\r\n      console.log(res.target)\r\n    }\r\n    return {\r\n      title: '自定义转发标题',\r\n      path: '/page/user?id=123'\r\n    }\r\n  }\r\n})常规转发，只需上面示例即可在onShareAppMessage中定义转发内容和必要参数，如?id=123在相应页面的onLoad(Object query)中可以获取根据场景值区分对于小程序，可以在 App 的 onLaunch 和 onShow，或wx.getLaunchOptionsSync 中获取 场景值由于onLaunch全局只触发一次和热启动的原因，在onShow中获取、设置相关参数比较合理，尤其是转发，从微信消息过来，必然会触发onShow通过app.onShow回调，获取场景值App({\r\n  onShow(res) {\r\n    console.log('app---onShow');\r\n    console.log(res.scene);\r\n    //1044是群聊，1007是私聊\r\n  }\r\n})wx.onAppShow(function callback)基础库 2.1.2 开始支持，低版本需做兼容处理监听小程序切前台事件。该事件与 App.onShow 的回调参数一致Object resreferrerInfo 的结构返回有效 referrerInfo 的场景注意小程序分享票据shareTickets通常开发者希望转发出去的小程序被二次打开的时候能够获取到一些信息，例如群的标识。现在通过调用 wx.showShareMenu 并且设置 withShareTicket 为 true ，当用户将小程序转发到任一群聊之后，此转发卡片在群聊中被其他用户打开时，可以在 App.onLaunch 或 App.onShow 获取到一个 shareTicket。通过调用 wx.getShareInfo() 接口传入此 shareTicket 可以获取到转发信息。和场景值scene一样，shareTicket也是在App.onShow中获取比较合理必须在分享前调用wx.showShareMenu方法，否则不会带分享票据//分享前share.js\r\nPage({\r\n  onLoad: function () {\r\n    wx.showShareMenu({\r\n      withShareTicket: true\r\n    })\r\n  }\r\n})\r\n//分享后app.js\r\nApp({\r\n  onShow(res) {\r\n    console.log('app---onShow');\r\n    console.log(res.shareTicket);\r\n  }\r\n})只有分享到任一群聊，shareTicket才会有值，否则是undefinedshareTicket也可以用来区分转发消息的场景shareTicket主要用来获取转发详情，传入wx.getShareInfo()中获取加密数据，需要后端配合，返回解密数据注意：注意：注意类似如下代码，现在已不支持回调此次调整可能影响到三种分享功能的用法第一种:判断用户是否分享成功，进而给予用户奖励。例如：小程序提示用户“分享到5个群，可以获得一张20元的优惠券”。这类诱导用户分享的行为是我们平台所不倡导的，后续将没有办法实现。第二种:分享完成后变更当前的页面状态例如：赠送礼品场景下，用户点击“赠送”按钮，将礼品分享出去，分享成功后，界面展示“等待领取”。这类场景，我们建议可以适当调整交互方案。例如在分享后继续保留“赠送”按钮，但在页面上提示用户一个礼品只能被一人领取，重复赠送无效。第三种：通过用户分享之后的 shareTicket 获取群唯一标识 openGId ，以显示对应群的相关信息。例如：通过分享小程序到某个群里，可以查看该群内成员的排行榜。此次调整后，用户分享完成后无法立刻显示该群的排行榜信息，但仍可在用户从群消息点击进入小程序时显示该群的排行榜信息。详情请查看 分享监听能力调整转发动态消息从基础库 2.4.0 开始，支持转发动态消息。动态消息对比普通消息，有以下特点：消息发出去之后，开发者可以通过后台接口修改部分消息内容消息有对应的提醒按钮，用户点击提醒按钮可以订阅提醒，开发者可以通过后台修改消息状态并推送一次提醒消息给订阅了提醒的用户简要步骤如下（后端调用）每条动态消息可以理解为一个活动，活动发起前需要通过 createActivityId 接口创建 activity_id 后续转发动态消息以及更新动态消息都需要传入这个 activity_id通过调用 wx.updateShareMenu 接口，传入 isUpdatableMessage: true等参数（后端调用）动态消息发出去之后，可以通过 setUpdatableMsg 修改消息内容像拼团这样的活动，可以考虑优化成动态消息，需要后端配合，实战的时再补充总结分享监听能力调整后，对于分享的骚操作基本在App.onShow中进行，相当于授权那样，必须打开转发消息才能获取转发详情，这也是符合设计准则的可以看出，不管是从设计准则，还是用户隐私，微信都在向着IOS看齐，黑暗法则已过去，我们也该注重规范和隐私了"}
{"title": "微信小程序开发系列教程第七章：编辑名片页面开发 ", "author": "admin", "pub_time": "2016-10-12 22:14", "content": "编辑名片有两条路径，分为新增名片流程与修改名片流程。用户手填新增名片流程：首先跳转到我们的新增名片页面 1 需要传递用户的当前 userId，wx.navigateTo 带值跳转。Manual 为 true 设置用户走的是新增路线。新增名片页面 1 基本布局如下：取到 userId。使用微信自带的 input 组件验证也非常好用，如 maxLength 属性，可以限制用户输入长度，如我这的姓名长度是最大 5 位，直接数字 5 即可。也可以自定义一些验证效果，具体可以根据需求进行一些验证配置，取到用户输入的值，进行操作。这里绑定了自带的模态框提示组件。其中 modalHidden2 是模态框开关。另外 proptText 是需要提示的内容。即使很多输入框也支持数据动态改变，非常方便。实际效果，非常快捷，比以前省去很多事情，编写小程序，发现最大的好处可能就是我们不必去考虑一系列兼容性问题。最后还有个头像上传图片，测试了下目前上传到后台服务器还有点问题，应该是内测版本不太完善导致吧。设置的直接是背景图片。提交表单与跳转。提交表单使用的是自带的 bindsubmit 事件组件，在 button 组件上添加 formType=”submit” 即可，还有点需注意的是使用表单提交功能时 input 需加上 name 属性，这个传递方式是以键值对的形式传递的。这时候跳转到编辑页 2 页面，这个页面是根据用户填写的手机号码识别到匹配的公司，页面非常简单，一个数据循环而已，单选框日后可能还需要美化一下。同样也是一些数据绑定以及验证效果。实际渲染效果可以看到。这个和第一个编辑页面逻辑基本不相上下，一些基本验证与提交，这里就讲到前面两步骤即可，编辑页面3也是同理，这里不再过多啰嗦。修改名片流程效果图与需求，修改名片是一次性把以前填写的个人信息全部渲染出来，供用户来改动：名片图片模块，上传图片暂时还有点问题，这里就是模仿了个跳转组件，比较建议需要跳转的页面还是使用 wx.navigateTo 控制好一点，wx.navigateTo 提供了给我们不同的 3 个跳转路由，封装的都很好，而且跳转页面很多牵连到传值之类的，可以达到统一管理也可以避免一些看不到的 bug 吧，总之还是根据业务需求来定：姓名手机必填模块：个人信息模块，直接循环（block）出来：Onload 时我们请求必填与选填数据：* requiredGroup 必填中文信息* notRequiredGroup 选题中文信息* requiredGroupEn 必填英文信息* notRequiredGroupEn 选题英文信息```//请求名片对应的公司的中文信息的属性组数据，分为必填和选填//选题项变量以 no 开头requester.getOfflineCardInfoGroupFields(userId, cardId,function (res) {//debuggervar userName = res.card.userName;var mobile = res.card.mobile;var requiredGroup = res.requiredGroupCh;var notRequiredGroup = res.notRequiredGroupCh;var requiredGroupEn = res.requiredGroupEn;var notRequiredGroupEn = res.notRequiredGroupEn;var reqLen = requiredGroup.fields.length;var nreqLen = notRequiredGroup.fields.length;var reqLenEn = requiredGroupEn.fields.length;var nreqLenEn = notRequiredGroupEn.fields.length;self.setData({userName: userName,mobile: mobile,requireFields: requiredGroup.fields,notRequireFields: notRequiredGroup.fields,requireFieldsEn: requiredGroupEn.fields,notRequireFieldsEn: notRequiredGroupEn.fields,l1: reqLen,l2: nreqLen + reqLen,l3: reqLenEn + nreqLen + reqLen});self.forceUpdate();}, function (code, msg) {console.info(\"code=\" + code + \"&msg=\" + msg);});```中英文信息必填与选填渲染：这里表单提交数据转换有点复杂（大家根据业务需求来做，不必花时间研究这里的方法），获取的是数组，按照后台需要的数据格式进行转换传递过去。今天再回去理下首页 A、B、C 定点跳转功能实现方法。首先是右边小索引布局以及数据绑定，数据绑定和名片夹列表上的字母一样，该字母下面有名片则渲染出来，没有则不需要渲染，id同样是当前字母与右边显示的内容一样：数据 sort，和 group.name 数据一样：这里是因为 # 不支持设为 id（就是 id=”#”），故而进行了一个转化。点击事件：获取到当前 ID，以及绑定数据 toView 为当前 ID。首先名片列表，名片上的字母索引都在 scroll-view 里面，这个 scroll-view 必须设置好固定的高度，设置成 100% 与 100vh 是无效的，y 轴的滚动开关打开，scroll-into-view 需要跳转到它子元素的 id 上。可以看下：这个 group.name==sortmsg，等于就是 A==A,B==B 同理。在这里如顶部有些菜单栏的话，你就要注意好布局了，不然会出现向下偏移这个菜单栏的高度，其实你只要和字母索引同级下即可避免此问题（这里的顶部菜单以模板分离出去了，分离模板的时候需注意下，需要在这里绑定模板的一些数据会出现失效，具体没有继续深入研究下去）。跳转功能基本实现（ohter 就是 # 底部）。"}
{"title": "文字超出显示区域后隐藏并显示省略号 ", "author": "Rolan", "pub_time": "2018-11-28 00:29", "content": "单行文字超出后隐藏首先容器需要有固定的宽高，其次加入以下代码即可。view {\r\n  overflow: hidden;\r\n  text-overflow: ellipsis;\r\n  white-space: nowrap;\r\n}多行文字超出后隐藏容器不需要有固定的宽高，只需加入以下代码即可。无需指定高度，只需指定最多显示几行，属性 -webkit-line-clamp。本示例中最多显示3行，超出3行后，在第三行末尾用省略号代替显示。view {\r\n  display: -webkit-box;\r\n  overflow: hidden;\r\n  text-overflow: ellipsis;\r\n  word-break: break-all;\r\n  -webkit-box-orient: vertical;\r\n  -webkit-line-clamp: 3;\r\n}"}
{"title": "怎么掌握微信小程序的取值、传值、数据存储 ", "author": "Rolan", "pub_time": "2018-12-10 00:12", "content": "小程序界面设定如下父级页面：A界面子级页面：B界面异级页面：C界面 一.本页面取值（A界面→A界面）a.例如：input输入文字获取到value（键盘输入时触发）wxml：<input type='text' name=\"userName\" maxlength=\"11\" bindinput=\"userPhoneInput\" ></input>js:data: {\r\n    userPhone: '',\r\n  },\r\n  //手机号输入框事件键盘输入时触发(文字提醒)\r\n  userPhoneInput: function (e) {\r\n    this.setData({\r\n      userPhone: e.detail.value\r\n    })\r\n  },\r\n  //接口取值格式\r\n  onShow: function () {\r\n    .....\r\n    data:{\r\n        UserPhoneNum:that.data.userPhone,\r\n    },\r\n    .....\r\n  }, b.例如：input不输入文字获取到全部的value（键盘不输入时触发）wxml：<form bindsubmit=\"formSubmit\">\r\n        <input type='text' value='{{putdata.name}}' name=\"companyname\" placeholder='请输入你的姓名/公司名称'></input>\r\n        <input type='text' value='{{putdata.bankName}}' name=\"openbank\" placeholder='请输入你的开户行全称'></input>\r\n        <button formType=\"submit\">完成</button>\r\n</form>注：form表单与button绑定获取input的内容js://按钮点击事件\r\n  formSubmit: function (e) {\r\n    var companyname = e.detail.value.companyname;\r\n    var openbank = e.detail.value.openbank;\r\n    //根据name取input的value\r\n    wx.request({\r\n      url: aaaaaa,\r\n      data: {\r\n        name: companyname,\r\n        bankName: openbank,\r\n      },\r\n      header: {\r\n        'content-type': 'application/json',\r\n      },\r\n      success: function (res) {\r\n\r\n      },\r\n      fail: function () {\r\n\r\n      }\r\n    })\r\n  } 二.异页面传值取值（A界面→B界面，A界面→C界面）a.url传值用 navigator标签或 wx.navigator传值，A界面向B界面传值；（不懂的自行安利小程序api和组件）wxml:// navigator标签传值\r\n<navigator url=\"/page/index/index?id=1432&name=qima&password=hj1234\" >传值</navigator>\r\n\r\n//wx.navigator传值\r\nwx.navigateTo({\r\n      url: '/page/index/index?id=' + id +'&username='+ username+'&password='+ password\r\n})下一个页面取值方法：js:data: {\r\n    id : \"\" ,\r\n    name : \"\" ,\r\n    password : \"\",\r\n  },\r\nonLoad: function (options) {\r\n    var id = options.id;\r\n    var name = options.name;\r\n    var password = options.password;\r\n    this.setData({\r\n      id:id,\r\n      name:name,\r\n      password:password,\r\n    })\r\n},一般小程序能不用接口解决的就不要用到接口呈现数据，可以用URL传值，到下一个页面取值，然后呈现到页面即可； b.数据存储我们会用到小程序的api,通过调用微信提供的方法：wx.setStorage、wx.setStorageSync、wx.getStorage、wx.getStorageSync、wx.clearStorage、wx.clearStorageSync、实现对数据本地缓存、获取、清除。js缓存:我们获取接口传回的数据，id,code之类的，我们做全局储存，命名一个key和内容value；wx.request({\r\n        url: aaaaa,\r\n        data: {\r\n          UserPhoneNum: '86//' + that.data.userPhone,\r\n          Password: that.data.passWd,\r\n          IP: that.data.IP,\r\n        },\r\n        header: {\r\n          'content-type': 'application/json',\r\n        },\r\n        success: function (res) {\r\n          console.log(res.data),\r\n          //存储格式 wx.setStorageSync('key命名', value内容);\r\n          wx.setStorageSync('salemanId', res.data.salemanId);\r\n          wx.setStorageSync('salemanLevel', res.data.salemanLevel);\r\n          if (res.data.state == 200){\r\n            \r\n          }else{\r\n           \r\n          }\r\n        },\r\n })js获取：根据key获取到数据，缓存到本地或上传到接口；//根据key获取到缓存的值\r\nvar salemanId= wx.getStorageSync(\"salemanId\");js清除：从本地缓存中同步移除指定 key。这里具体使用同步或是异步需要根据你存储时的方法，或是同步清理本地数据缓存；//清除数据\r\nwx.removeStorageSync(\"salemanId\") 查看自己缓存数据地点：（如图） c.全局App对象在我们的app.js文件里面，我们需要写好我们需要全局使用的数据；//用户学校数据\r\n globalData: {\r\n     school:null,\r\n }我们需要给它赋值，赋值代码如下：var self = this\r\n......\r\nself.globalData.school = res.data.schoolID在我们需要取值的地方引用全局的app.js,然后取值：var app = getApp();\r\nonLoad: function () {\r\n    var that = this; \r\n    //调用应用实例的方法获取全局数据  \r\n    app.getUserSchool(function (school) {\r\n      //更新数据  \r\n    })\r\n},\r\n//取值\r\n......\r\nschool: app.globalData.school,\r\n...... 三.总结小程序了解到这些传值取值过程，接通接口，呈现数据就快多了，还有哪些可以传值取值的方法，欢迎大家留言哦，交流才能让人进步，有什么错误的地方也欢迎大家指正，我将进行更改，觉得博主写的还可以的，欢迎点个关注，以后有空常来我的博客逛逛，虽然可能写的东西不是很高级，但是对于初级的人来说，还是能帮助到很多东西的，我的博文能帮助到大家我就很开心了，谢谢您百忙之中的观看，一起加油进步，哇哈哈哈"}
{"title": "兼容小程序的canvas画图组件jmGraph ", "author": "Rolan", "pub_time": "2018-12-14 00:22", "content": "基于CANVAS的简单画图组件让你用类似于dom的方式，在canvas上画图，感觉会不会很爽。主页：http://graph.jm47.com/示例：http://graph.jm47.com/example/index.html安装直接从github下载https://github.com/jiamao/jmgraph\r\n入门下载jmGraph.min.js代码，并引用到你的html中。1<script type=\"text/javascript\" src=\"../dist/jmGraph.min.js\"></script>  　　在dom中添加一个div或canvas，然后初始化jmGraph。<div id=\"mycanvas_container\"></div>\r\n<script type=\"text/javascript\">    \r\n    //也可以是一个dom对象或一个jquery对象 \r\n    //例如：$('#mycanvas_container') || document.getElementById('mycanvas_container')\r\n    var container = 'mycanvas_container';\r\n\r\n    // 用Promise方式\r\n    /*jmGraph(container, {\r\n        width: 800,\r\n        height: 600\r\n    }).then((g)=>{\r\n        //g就是一个jmGraph实例\r\n        init(g);\r\n    });    */\r\n    \r\n    var g = new jmGraph(container, {\r\n        width: 800,\r\n        height: 600,\r\n        //样式，规则请参照样式说明\r\n        style: {\r\n            fill: '#000' //指定背景色\r\n        }\r\n    });\r\n</script> 在画布上画一个方块function init(g){\r\n    var style = {\r\n        stroke:'#46BF86',\r\n        lineWidth: 2\r\n    };\r\n    style.shadow = '0,0,10,#fff';//阴影\r\n    //style.opacity = 0.2;            \r\n    //style.lineCap = 'round';\r\n\r\n    //创建一个方块\r\n    var rect = g.createShape('rect',{\r\n        style:style,\r\n        position: {x:100,y:100}, //左上角坐标\r\n        width:100,\r\n        height:100\r\n    });\r\n    g.children.add(rect);\r\n\r\n    //绘制，可以用requestAnimationFrame动态刷新\r\n    function update() {\r\n        g.redraw();\r\n        //requestAnimationFrame(update);\r\n    }\r\n    update();\r\n} 样式样式可以直接用canvas支持的名称，也可以用本组件简化后的。样式一览事件的绑定函数：bind/unbind事件示例：//创建一条线\r\nvar line = graph.createLine({x:10,y:200},{x:80,y:120},style);\r\n//鼠标移到上面显示不同的样式            \r\nline.bind('mouseover',function(evt) {\r\n    this.style.stroke = 'rgba(39,72,188,0.5)';\r\n    this.cursor('pointer');\r\n    this.neadUpdate = true; //需要刷新\r\n}); 事件一览Path控件path是多数图形的基类，可以指定一个points数组来绘制一个路径。在线示例var path = graph.createPath(null,style);\r\npath.points.push({x:10,y:10});\r\npath.points.push({x:10,y:60});\r\npath.points.push({x:80,y:20});\r\npath.points.push({x:90,y:80});\r\npath.points.push({x:80,y:80}); 圆arc可以创建椭圆、圆弧和圆，circle调用的是原生的arc函数绘制，harc可以绘制一个圆环。 具体请参考示例。 在线示例//创建一个椭圆，指定不同的宽高就为椭圆。如果相同或指定半径则为圆。\r\nvar arc1 = g.createShape('arc', {\r\n    style: style,\r\n    center: {x:100, y:150},\r\n    width: 120,\r\n    height: 80\r\n});         箭头arraw为创建一个箭头， arrawline是一条带箭头的直线。具体请参考示例。 在线示例//带箭头的直线\r\nvar shape = g.createShape('arrawline',{\r\n    style:style,\r\n    start: {x:100,y:100},\r\n    end: {x: 200, y: 350}\r\n});    \r\n//一起结束点和一个角度angle可以决定一个箭头，如果不填angle，则会用start和end来计算角度\r\nvar arraw = g.createShape('arraw',{\r\n    style:style,\r\n    start: {x:150, y:120},\r\n    end: {x: 160, y: 150}\r\n    //angle: Math.PI/2, //箭头角度  可以不填\r\n    //offsetX: 5, //箭头X偏移量\r\n    //offsetY: 8 //箭头Y偏移量\r\n});     贝塞尔曲线bezier可以指定无隐个控制点，绘制复杂的曲线。 具体请参考示例。 在线示例//一个固定的bezier曲线\r\nvar bezier = g.createShape('bezier', { style: style, points: [p0, p1, p2, p3, p4] }); 图片img是用来承载一张图片的控件，可以用style.src来指定图片url。 具体请参考示例。 在线示例var style = {\r\n    src: 'http://mat1.gtimg.com/www/qq2018/imgs/qq_logo_2018x2.png'\r\n};\r\nstyle.shadow = '0,0,10,#fff';\r\n//style.opacity = 0.2;        \r\n\r\n//创建一个image\r\nvar img = g.createShape('image',{\r\n    style:style,\r\n    position: {x:100,y:100}\r\n});    \r\n//设置图片可以用鼠标移动        \r\nimg.canMove(true); 文字label可以用来绘制文字，通过style指定样式。 具体请参考示例。 在线示例var style = {\r\n    stroke: '#effaaa',\r\n    fill: '#fff',\r\n    textAlign: 'center', //水平居中\r\n    textBaseline: 'middle', //垂直居中\r\n    font: '20px Arial',\r\n    border: {left:1,top:1,right:1,bottom:1}, //边框\r\n    shadow: '0,0,10,#fff'\r\n};\r\n//style.opacity = 0.2;        \r\n\r\n//创建一个label\r\nvar label = g.createShape('label',{\r\n    style:style,\r\n    position:{x:200,y:150},\r\n    text:'test label',\r\n    width:120,\r\n    height:80\r\n});         棱形prismatic具体请参考示例。 在线示例var prismatic = g.createShape('prismatic',{\r\n    style:style,\r\n    center:{x:200,y:150},\r\n    width:120,\r\n    height:80\r\n});         可缩放控件resize 可以自由放大缩小的控件。 具体请参考示例。 在线示例var style = {\r\n    stroke: 'red',\r\n    fill: 'yellow',\r\n    lineWidth: 2, //边线宽\r\n    //小方块样式\r\n    rectStyle: {\r\n        stroke: 'green', //小方块边颜色\r\n        fill: 'transparent',//小方块填充色\r\n        lineWidth: 1, //小方块线宽\r\n        close: true\r\n    }\r\n};\r\n//style.opacity = 0.2;        \r\n\r\n//创建一个resize\r\nvar resize = g.createShape('resize', {\r\n    style: style,\r\n    position: {x:200, y:150},\r\n    width: 120,\r\n    height: 80\r\n});    \r\n//大小改变事件\r\nresize.on('resize', function() {\r\n    console.log(arguments);\r\n});     自定义控件大多数控件直接继承jmPath即可，然后通过实现initPoints来绘制当前控件。当需要从某点重新开始画时，给点指定m属性为true，表示移到当前点。示例来画一个X在线示例：http://graph.jm47.com/example/controls/test.htmlfunction jmTest(graph,params) {\r\n    if(!params) params = {};\r\n    this.points = params.points || [];\r\n    var style = params.style || {};\r\n    \r\n    this.type = 'jmTest';\r\n    this.graph = graph;\r\n        \r\n    this.center = params.center || {x:0,y:0};\r\n    this.radius = params.radius || 0;\r\n\r\n    this.initializing(graph.context, style);\r\n}\r\njmUtils.extend(jmTest, jmPath);//jmPath\r\n\r\n//定义属性\r\n\r\n/**\r\n * 中心点\r\n * point格式：{x:0,y:0,m:true}\r\n * @property center\r\n * @type {point}\r\n */\r\njmUtils.createProperty(jmTest.prototype, 'center');\r\n\r\n/**\r\n * 半径\r\n * @property radius\r\n * @type {number}\r\n */\r\njmUtils.createProperty(jmTest.prototype, 'radius', 0);\r\n\r\n\r\n/**\r\n * 初始化图形点\r\n * 控件都是由点形成\r\n * \r\n * @method initPoint\r\n * @private\r\n * @for jmArc\r\n */\r\njmTest.prototype.initPoints = function() {\r\n    //可以获取当前控件的左上坐标，可以用来画相对位置\r\n    var location = this.getLocation();//获取位置参数\r\n    \r\n    var cx = location.center.x ;\r\n    var cy = location.center.y ;\r\n    \r\n    this.points = [];\r\n\r\n    //简单的画一个X\r\n\r\n    //根据半径计算x,y偏移量\r\n    //由于是圆，偏移量相同\r\n    var offw = Math.sqrt(location.radius * location.radius / 2);\r\n    //左上角到右下角对角线\r\n    this.points.push({x:cx - offw, y:cy-offw}, {x:cx + offw, y:cy+offw});\r\n\r\n    //左下角到右上角对角线\r\n    //画完上面的线后，需要重新移到这条线的起点，指定m:true即可\r\n    this.points.push({x:cx - offw, y:cy+offw, m:true}, {x:cx + offw, y:cy-offw});\r\n\r\n    return this.points;\r\n} 微信小程序支持微信小程序稍有差别，因为无需压缩，请直接把dist中的jmgraph.js合并后的文件引用到你的小程序中。示例wxml<canvas style=\"width: 400px; height: 600px;background:#000;\" \r\n    canvas-id=\"mycanvas\" \r\n    bindtouchstart=\"canvastouchstart\" \r\n    bindtouchmove=\"canvastouchmove\" \r\n    bindtouchend=\"canvastouchend\" \r\n    bindtouchcancel=\"canvastouchcancel\">\r\n</canvas> javascript/**\r\n   * 生命周期函数--监听页面初次渲染完成\r\n   */\r\n  onReady: function () {\r\n    \r\n    //这里引用jmgraph\r\n    let jmGraph = require('../../utils/jmgraph');\r\n\r\n    var self = this;\r\n\r\n    jmGraph('mycanvas', {\r\n      width: 400,\r\n      height: 600\r\n    }).then((g) => {\r\n      init(g)\r\n    });\r\n\r\n    function init(g) {\r\n      //g.style.fill = '#000'; //画布背景\r\n      var style = {\r\n        stroke: '#46BF86',\r\n        fill: '#556662',\r\n        lineWidth: 2\r\n      };\r\n      style.shadow = '0,0,10,#fff';\r\n      //style.opacity = 0.2;            \r\n      //style.lineCap = 'round';\r\n\r\n      //创建一个方块\r\n      var rect = g.createShape('rect', {\r\n        style: style,\r\n        position: { x: 100, y: 100 },\r\n        width: 100,\r\n        height: 100\r\n      });\r\n      rect.canMove(true);\r\n      g.children.add(rect);\r\n\r\n      function update() {\r\n        if (g.needUpdate) g.redraw();\r\n        setTimeout(update, 20);\r\n      }\r\n\r\n      update();\r\n\r\n      //初始化jmGraph事件\r\n      //把小程序中的canvas事件交给jmGraph处理\r\n      self.canvastouchstart = function() {\r\n        return g.eventHandler.touchStart.apply(this, arguments);\r\n      }\r\n      self.canvastouchmove = function() {\r\n        return g.eventHandler.touchMove.apply(this, arguments);\r\n      }\r\n      self.canvastouchend = function() {\r\n        return g.eventHandler.touchEnd.apply(this, arguments);\r\n      }\r\n      self.canvastouchcancel = function() {\r\n        return g.eventHandler.touchCancel.apply(this, arguments);\r\n      }\r\n    }\r\n  }"}
{"title": "微信小程序解码工具 ", "author": "Rolan", "pub_time": "2019-1-4 00:40", "content": "项目地址起因  前段时间想学习微信小程序开发但是又没有什么深厚前端功底，看到很多很好玩的小程序想要做一个类似的学习学习，所以想着借鉴一下现有的小程序。但是苦于没有源码，抓包也没有办法获取源码。  google后知道可以用安卓模拟器安装微信然后安装小程序，然后在文件系统中找到小程序对应的wxapkg文件，拿到压缩包解压后就可以得到小程序源码。  但是压缩包是2进制文件，找了一遍后发现一个现有现有的开源项目可以直接解压小程序压缩包。废话不多说，直接开干～使用源码安装安装golang没有用过golang的人可以直接去官网下载go get github.com/sjatsh/unwxapkgcd ~/go/src/github.com/sjatsh/unwxapkg使用可执行文件下载地址使用unwxapkg -f dest/102.wxapkg图片发自简书App项目地址"}
{"title": "小程序 - 验证码倒计时组件 ", "author": "Rolan", "pub_time": "2018-12-27 00:08", "content": "发送验证码倒计时的方法很常见，在项目里面也经常会多次用到，这时就要把倒计时封装为组件，需要用到的时候方便使用。\r\n\r\n自定义组件\r\n需要封装一个组件，首先要熟悉小程序自定义组件的文档。官方文档在这里\r\n倒计时组件\r\n为了方便描述，我把页面定义为父组件，把倒计时组件定义为子组件吧。\r\n\r\n首先需要清楚子组件与父组件之间事件的响应方法，例如：子组件响应父组件的事件，子组件修改父组件的data属性等。\r\n\r\n小程序没有像Vue里面的watch模式也没有computed计算属性，但是还好小程序properties里有observer，官方文档说observer表示属性值被更改时的响应函数，那这样就好办了。\r\n当子组件倒计时完成之后，需要告诉父组件，子组件已经完成了倒计时，这里可以用到方法传递的e.detail来处理。\r\n\r\n\r\n子组件代码\r\ncountdown.js\r\nComponent({\r\n  /**\r\n   * 组件的属性列表\r\n   */\r\n  properties: {\r\n    // 是否开始倒计时\r\n    start: {\r\n      type: Boolean,\r\n      value: false,\r\n      observer(newVal){\r\n        if (newVal === true) {\r\n          this.countdownFunc()\r\n        }\r\n      }\r\n    }\r\n  },\r\n\r\n  /**\r\n   * 组件的初始数据\r\n   */\r\n  data: {\r\n    timerText: '获取验证码'\r\n  },\r\n\r\n  /**\r\n   * 组件的方法列表\r\n   */\r\n  methods: {\r\n    /**\r\n     * 触发页面点击事件\r\n     */\r\n    _getCountdownEvent(){\r\n      this.triggerEvent(\"getCountdownEvent\")\r\n    },\r\n\r\n    /**\r\n     * 触发页面修改data事件\r\n     */\r\n    _setStartDataEvent() {\r\n      this.triggerEvent(\"setStartDataEvent\", this.data.start)\r\n    },\r\n\r\n    /**\r\n     * 倒计时\r\n     */\r\n    countdownFunc() {\r\n\r\n      this.setData({\r\n        timerText: 60\r\n      })\r\n      let target = this\r\n      let countdownNum = target.data.timerText\r\n\r\n      let timer = setInterval(() => {\r\n        countdownNum--\r\n\r\n        target.setData({\r\n          timerText: countdownNum\r\n        })\r\n\r\n        if (countdownNum == 0) {\r\n          target.setData({\r\n            timerText: '重新发送',\r\n            start: false\r\n          })\r\n\r\n          this._setStartDataEvent() //倒计时为0时，让父组件的start重新设置为false\r\n          \r\n          clearInterval(timer) //清除定时器\r\n        }\r\n\r\n      }, 1000)\r\n    }\r\n  }\r\n})\r\n复制代码显示的倒计时（timerText）可以根据自己需求重新修改。\r\ncountdown.wxml\r\n<view bindtap=\"_getCountdownEvent\">{{timerText}}{{start?'s后重试':''}}</view>\r\n复制代码页面使用\r\n调用组件需要在相应的json文件里面注册，这个我就不说了。\r\n父组件代码\r\nsendRandom.wxml\r\n<countdown id=\"sendRandom\" \r\n    start=\"{{start}}\"\r\n    bind:getCountdownEvent=\"_getCountdownEvent\"\r\n    bind:setStartDataEvent=\"_setStartDataEvent\"\r\n    >\r\n</countdown>\r\n复制代码sendRandom.js\r\nPage({\r\n\r\n  /**\r\n   * 页面的初始数据\r\n   */\r\n  data: {\r\n    start: false\r\n  },\r\n\r\n  /**\r\n   * 点击获取验证码\r\n   */\r\n  _getCountdownEvent(e) {\r\n  \r\n  // todo: 点击获取验证码之后，可以根据自己的需求，通知子组件可以开始倒计时了\r\n  // 如： 向后台请求发送验证码的方法，请求成功之后将start设置为true，表示倒计时开始了。\r\n    \r\n    if (this.data.start === true) {\r\n      return\r\n    }\r\n    this.setData({\r\n      start: true\r\n    })\r\n  },\r\n\r\n  /**\r\n   * 倒计时结束 设置setData为false\r\n   */\r\n  _setStartDataEvent(e){\r\n    if (e.detail === false) {\r\n      this.setData({\r\n        start: false\r\n      })\r\n    }\r\n  }\r\n  \r\n})\r\n复制代码结语\r\n以上是根据自己公司的需求封装的倒计时组件，写得不够优雅，只是想记录一下小程序自定义组件的互相传值和事件响应。如有更好的方法可以提供下思路。"}
{"title": "在小程序中集成赞赏 ", "author": "Rolan", "pub_time": "2019-1-11 00:18", "content": "好吧，我承认我标题党了，如果你是进来找如何搭建小程序中的支付流程的，请你下车吧~ 这篇文章是介绍个人小程序如何集成赞赏功能的，利用微信小程序提供的支付接口必须具有公司资质才可以。或者你也可以集成有赞，不过会抽取一定的手续费。 言归正传，让我们一步一步来集成赞赏吧，让那些喜欢你的用户也可以打赏你一下。生成一个赞赏码。打开微信，点击右上角加号->收付款->赞赏码，这里你可以进行一些赞赏设置，然后点击保存赞赏码。这样你就拥有了你专属的赞赏码了。获取一个图片地址如果你有服务器或者其他的存储空间，你可以把你的赞赏码上传到你的存储空间，然后拿到图片的htts地址，后面会用到。 如果你没有，那么还可以利用小程序给我们提供的免费的云开发。下面先来说一下如何将图片上传到云存储中。1、打开小程序开发工具，找到云开发后点击，如果你没有开通，则会提示你开通，需要在控制台中开通，路径是：开发->开发者设置->腾讯云。2、开通后再点击云开发，打开控制台，找到存储管理->上传文件,上传上一步你的专属赞赏码图片。上传完成后，就能看到文件了，将fileid字段复制下来，后面会用到。图片预览这一步需要根据实际情况分开来处理了，下面针对上一步说的两种形式一一讲解。1. 使用其他云存储拿到图片的https链接后，在你的小程序wxml添加一个打赏的按钮，然后给按钮添加如下点击事件：wx.previewImage({     urls: ['https://xxxxx/admire-qrcode.jpg'],});写到这里相信大家应该就很清楚了，不错，我们就是利用微信的图片预览功能来加载网络图片。当加载出预览大图二维码后，用户就可以长按识别二维码，弹出微信的识别图中二维码功能，最终跳转到微信自带的赞赏页面，是不是很赞呢~2. 使用云开发存储使用云开发存储的思路是一致的，只不过需要在代码中初始化一些云开发环境。初始化云开发 在app.js中加入如下代码进行初始化：onLaunch: function() {    wx.cloud.init({      traceUser: true    });}添加按钮点击事件 点击事件中传入的url就是第二步获取到的fileid。previewImage: function() {    wx.previewImage({        urls: ['cloud://carutil-007.6361-carutil-007/admire-qrcode.jpg'],    });  },大功告成，最终效果如下图所示。你可以扫描下方的小程序码来体验该功能，在首页最底部有个打赏按钮~"}
{"title": "Hybrid小程序混合开发之路 - 数据交互 ", "author": "Rolan", "pub_time": "2019-1-23 00:34", "content": "很多应用在原生界面中混杂着HTML界面记得xp时代的QQ，有些界面偶尔会弹出熟悉的js错误对话框，还能右键弹出熟悉的IE6的右键菜单，伪装的挺好，差点没认出来，现在的QQ就不知道了。美团、淘宝这些拥有几乎无限界面的手机App，顶部进度条一亮，这是一个H5 没谁了！Electron！好嗨哟~数据交互使用了HTML作界面，那么和原生程序之间的数据交互基本上是少不了的~（仅仅当做浏览器性质来用的就算了）~。如原生程序要控制H5界面变化，就需要由原生程序传出数据到H5。如H5界面用户点击动作触发涉及原生程序业务逻辑的调用，就需要由H5传入数据到原生程序。这两种数据传输组合在一起就成了交互。在自行嵌入浏览器内核、Electron都可以有自己的接口实现，Android、水果~（滑稽，本文与此物种无关，下同）~都有成熟的解决方案。小程序\" style=\"font-size: 21px; line-height: 1.5; margin: 1.3rem 0rem; border-bottom: 3px solid rgb(0, 102, 153); color: rgb(47, 47, 47); font-family: Roboto, \"Hiragino Sans GB\", \"Microsoft Yahei\", \"WenQuanYi Micro Hei\", SimSun, Tahoma, Arial, Helvetica, STHeiti; background-color: rgb(255, 255, 255);\">Hybrid App 与 Hybrid 小程序Hybrid App并非一定是和H5的混合开发，但本文所说的专指H5。同一界面，编写一次代码，就能同时运行在Android、水果、浏览器之上，说没有诱惑力是假的。小程序并非一定指的的某家的小程序，但本文所说的专指微信小程序。拥有一个强大的流量入口，嗯，就只这一点 ~（看好PWA）~。自从微信小程序开放了webview，和Hybrid App就有了共性，然后生了个“Hybrid 小程序”，是我一个人这么叫吗？我不管，我就要叫！然鹅，开发者对小程序底层的话语权几乎为0，小程序给什么我们就吃什么，嗯，真香。虽然提供了webview，但未提直接的供交互手段（记得要双向才能算交互吗，单向传递数据一边玩球）。似乎Hybrid之路已然折戟。Hybrid 小程序数据交互终极手段，合理合法！注：发现有人采用的是websocket来实现的数据交互，原生小程序和H5都通过服务器来中转数据，点评：这也是个好办法。数据传入基本原理：H5使用wx.miniProgram.navigateTo传递数据给小程序原生程序代码。数据传出基本原理：通过改变webview src中的hash，来实现无刷新数据传入原生小程序。最初开放webview时可用，后面有版本不行了，改变src中任意字符会导致重新加载界面，神奇的是现在又恢复了改变hash不会刷新。升级版：通过改变后台webview src中的hash，实现数据传入我们后台页面，不管有没有重新加载，hash始终能被我们的H5代码接收（而且省去了处理url变化的问题）。然后由后台页面传输数据给前台页面。实战举个支付吧，点击H5内的支付按钮，执行完业务逻辑，支付条件准备完毕，现在需要调起微信支付。小程序启动小程序启动。启动Response.wxml，webview加载后台页面。启动Main.wxml，保留Response.wxml后台页面在后台运行，前台主界面加载页面。启动完毕。开始支付主界面请求jssdk wx.miniProgram.navigateTo接口向Request.wxml界面发起请求，path中携带请求数据。Request.wxml原生程序接收到请求，发现支付请求并不需要保留界面，立马返回上一个界面(前台主界面)；然后后台继续处理支付请求，调起微信支付。前台主界面H5此时应该是在等待Request.wxml的响应结果，并且微信已经弹出支付功能。用户支付完成，Request.wxml残留代码收到支付响应结果，立马通知Response.wxml修改后台页面src中的hash，响应结果数据包含在其中。后台页面监听到hash change事件，或 页面刚刚加载完毕事件。从hash中拿到响应数据。后台页面把响应数据写入localStroage，前台页面监听到localStroage数据。成功得到支付响应数据。问题缺陷第2步虽然立即返回了，但还是会有一个短暂的界面切换动画，不过这种数据交互本来就是重量级的，也不可能频繁调用，Android和水果都是一样的，所以用户体验就是这么可观。改变webview src hash产生的行为是不可预测的 ，任性的版本，如果会刷新页面，延迟会比较大，甚至导致两次调用之间相互覆盖结果。应用案例笔者最近开发的小程序《祝福贺卡助手》，主功能采用的纯web网页，底层和微信小程序的数据交互就是本文介绍的这套模式。有2个比较重要的交互接口，一个是获取用户数据、另外一个是调起分享；当然还有一堆其他辅助类的接口。扫码体验网页版：小程序版：界面和功能开发一遍，网页、小程序通吃~ 这就是Hybrid小程序的魅力！围绕着小程序《祝福贺卡助手》的开发和审核上线过程，对于其中一些有趣的东西，我会分享出来。下篇内容预告：Hybrid小程序混合开发之路 - H5录音和水果的对抗。"}
{"title": "口袋工具之历史上的今天 - 小程序云开发实战 ", "author": "Rolan", "pub_time": "2019-2-11 00:25", "content": "本项目是一个基于云开发的小程序。本文选取项目中的一个页面 -- 历史上的今天 来做一个云开发的分享，会涉及云函数和云数据库。由于是实战项目，关于小程序的基础知识请移步官方文档，本文不再赘述。项目地址github.com/GoKu-gaga/t…项目预览微信搜索： 口袋工具y扫一扫：前期遇到的问题数据来源： 没有数据，寸步难行呀如何解决数据来源编写爬虫将需要的数据爬取并保存下来找一些提供数据的平台，如阿凡达数据、聚合数据等等。由于本人偷懒，所以选择第二种方式，并最终选择了聚合数据平台API。项目开始新建项目新建项目，配置好名称、目录、AppID等信息，后端服务选择 小程序·云开发 ，点击新建。关于AppID: 请自行修改为你注册的小程序AppID。点击新建即可完成项目初始化，得到一个云开发模板：目录结构：+-- cloudfunctions|[指定的环境]  // 存放云函数的目录\r\n  +-- miniprogram                 // 小程序代码编写目录\r\n  |-- README.md                   // 项目描述文件\r\n  |-- project.config.json         // 项目配置文件\r\n复制代码新建云开发环境点击左上角菜单项 云开发点击创建资源环境，环境名称及环境ID请自行设置：点击确定即可完成创建编写云函数1. 新建云函数在目录 cloudfunctions 上右键新建云函数，填入新建云函数的名称（如 todayInHistory ）回车或失去焦点即会自动创建并上传。2. 安装依赖云函数目前执行环境仅支持node，所以需要使用js来编写云函数的逻辑。 在控制台中进入该云函数的目录，执行npm i -S axios\r\n复制代码本项目使用 axios 来执行请求的发送，可以使用其他如 request-promise 等等的库来替换3. 编写云函数新建 config.js 文件，添加代码如下：exports.key = YOUR_JUHE_KEY // 在聚合数据平台申请的key\r\nexports.baseUrl = 'http://v.juhe.cn/todayOnhistory/queryEvent.php'\r\n复制代码打开 index.js 文件，编写代码：// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\nconst axios = require('axios')\r\n\r\ncloud.init()\r\nconst db = cloud.database()\r\n\r\n// 聚合数据\r\nconst { baseUrl, key } = require('./config')\r\n\r\n// 云函数入口函数\r\nexports.main = async(event, context) => {\r\n  const {\r\n    month,\r\n    day\r\n  } = event\r\n \r\n  const resp = await axios.get(baseUrl, {\r\n    params: {\r\n      key,\r\n      date: `${month}/${day}`\r\n    }\r\n  }).then(res => {\r\n    return res.data\r\n  })\r\n\r\n  return resp.result\r\n}\r\n复制代码编写页面1. 新建页面在开发小程序的过程中，新建一个页面是很常见的操作，有两个非常方便的方式在 app.json 文件中，在pages项添加我们需要的页面路径，直接保存即可。如：\"pages\": [\r\n  \"pages/today-in-history/index\"\r\n]\r\n复制代码在 pages 目录下新建目录 today-in-history ，在新建的目录上右键 -> 新建page， 填入名称如 index , 回车即可完成页面下四个文件的创建2. 编写 index.wxml<!--pages/today-in-history/index.wxml-->\r\n<view class=\"container\">\r\n  <view class=\"header full-width\">\r\n    <view>{{year}}年{{month}}月{{day}}日</view>\r\n  </view>\r\n  <view class=\"content full-width\">\r\n    <view class=\"list-view\">\r\n      <block wx:for=\"{{list}}\" wx:key=\"index\">\r\n        <navigator url=\"{{'/pages/history-detail/index?id=' + item.e_id}}\" class=\"list-item\">\r\n          <view class=\"item-title\">{{item.title}}</view>\r\n          <view class=\"item-date\">{{item.date}}</view>\r\n        </navigator>\r\n      </block>\r\n    </view>\r\n  </view>\r\n</view>\r\n复制代码3. 编写 index.js// pages/today-in-history/index.js\r\nPage({\r\n\r\n  /**\r\n   * 页面的初始数据\r\n   */\r\n  data: {\r\n    year: 1990,\r\n    month: 1,\r\n    day: 1,\r\n    list: []\r\n  },\r\n\r\n  /**\r\n   * 生命周期函数--监听页面加载\r\n   */\r\n  onLoad: function() {\r\n    const now = new Date();\r\n    const year = now.getFullYear();\r\n    const month = now.getMonth() + 1;\r\n    const day = now.getDate();\r\n    this.setData({\r\n      year,\r\n      month,\r\n      day\r\n    });\r\n    this.doGetList();\r\n  },\r\n\r\n  /**\r\n   * 执行数据获取\r\n   */\r\n  doGetList: function() {\r\n    const {\r\n      month,\r\n      day\r\n    } = this.data;\r\n    wx.cloud.callFunction({\r\n        name: 'todayInHistory',\r\n        data: {\r\n          month,\r\n          day\r\n        }\r\n      }).then(res => {\r\n        let list = res.result.reverse();\r\n        this.setData({\r\n          list\r\n        });\r\n      })\r\n      .catch(console.error)\r\n  }\r\n})\r\n复制代码4. 编写 index.wxss/* pages/today-in-history/index.wxss */\r\n.container {\r\n  padding-bottom: 20rpx;\r\n  background-color: #E8D3A9;\r\n}\r\n\r\n.header {\r\n  display: flex;\r\n  justify-content: space-around;\r\n  align-items: center;\r\n  height: 80rpx;\r\n  color: #FFF;\r\n}\r\n\r\n.content {\r\n  flex: 1;\r\n}\r\n\r\n.list-view {\r\n  height: 100%;\r\n  display: flex;\r\n  flex-direction: column;\r\n  padding: 0 20rpx;\r\n}\r\n\r\n.list-item {\r\n  display: flex;\r\n  flex-direction: column;\r\n  border-radius: 10rpx;\r\n  padding: 16rpx 0;\r\n  box-sizing: border-box;\r\n  margin-top: 20rpx;\r\n  background-color: #fff;\r\n  text-align: center;\r\n  box-shadow: 1px 1px 5px 1px rgb(207, 207, 207);\r\n}\r\n\r\n.item-title {\r\n  font-size: 36rpx;\r\n  padding: 10rpx 16rpx;\r\n  color: #262626;\r\n  line-height: 48rpx;\r\n}\r\n\r\n.item-date {\r\n  font-size: 24rpx;\r\n  height: 30rpx;\r\n  line-height: 30rpx;\r\n  border-top: 2rpx solid #eee;\r\n  padding: 10rpx 16rpx 0;\r\n  color: #595959;\r\n  margin-top: 6rpx;\r\n}\r\n复制代码补充项目中也使用了部分的有赞的小程序组件库vant-weapp由于聚合数据平台API非会员调用次数有限（100次/天），明显是不太够用的。因此，我们可以考虑在请求到数据时，将数据存在云数据库中，其实也就实现了一个类似爬虫的功能啦。流程如下：代码实现：修改 cloudfunctions/todayInHistory/index.js// ... 省略其他无需改动的代码\r\nexports.main = async(event, context) => {\r\n  const {\r\n    month,\r\n    day\r\n  } = event\r\n\r\n  const ret = await db.collection('todayInHistory').where({\r\n    date: `${month}/${day}`\r\n  }).get()\r\n\r\n  if (ret.data.length > 0) {\r\n    return ret.data[0].result\r\n  }\r\n\r\n  const resp = await axios.get(baseUrl, {\r\n    params: {\r\n      key,\r\n      date: `${month}/${day}`\r\n    }\r\n  }).then(res => {\r\n    return res.data\r\n  })\r\n  \r\n  await db.collection('todayInHistory').add({\r\n    data: {\r\n      date: `${month}/${day}`,\r\n      result: resp.result\r\n    }\r\n  })\r\n\r\n  return resp.result\r\n}\r\n复制代码以上即为 历史上的今天 页面的数据获取及展示，其他页面使用到云开发的模式基本大同小异。结语目前只开发了两个小功能 历史上的今天 和 周公解梦 ，后续会继续开发新的功能，希望可以做成一个小工具集合，这也是 口袋工具 这个名称的由来。感谢各位读者的阅读，由于本人水平有限，文章中如有错误或不妥之处，请不吝赐教！如果你喜欢这篇文章或是这个项目，不妨进去点个Star支持下 today 。"}
{"title": "小程序页面动态配置实现 ", "author": "Rolan", "pub_time": "2019-2-11 11:04", "content": "小程序可以根据管理后台配置动态更新展示内容，如实现下面新鲜事栏目图片的来源的可配置，点击跳转url的可配置。实现方案1后端创建一个map结构的数据表，表结构如下：2 管理后台根据不同业务设定不同的key和value，更新数据库如key：ad1url value：a.png如果需要更新页面图片，只需更新ad1url对应的value3 小程序根据对应业务key获取对应的配置项，更新页面显示技术栈后端接口服务：SpringBoot Mybatis MySql管理后台：vue前端：小程序代码实现后端接口为了保证key的唯一性，key在数据库设置为unique属性，新增和更新功能通过以下sql语句实现，主要通过replace into实现配置项的唯一@Insert(\"<script>\"  +\r\n         \"REPLACE INTO `rental`.`t_config`(`key`, `value`) VALUES\" +\r\n         \"<foreach\" +\r\n         \" collection=\\\"list\\\" item=\\\"item1\\\" index=\\\"index\\\"  separator=\\\",\\\">\" +\r\n         \"(#{item1.key}, #{item1.value})\" +\r\n         \"</foreach>\" +\r\n       \"</script>\")\r\n @Options(useGeneratedKeys = true, keyProperty = \"configId\", keyColumn = \"configId\")\r\n复制代码api设计一开始想通过传如list数据给后端实现配置项的批量插入功能，发现后端数据一直接受不到，故而退而求其次，通过json字符串实现vue（网络库使用axios）调用后端接口@ApiOperation(value = \"新增或更新配置列表\")\r\n@RequestMapping(value = \"/add_or_update_config_list\", method = RequestMethod.POST, \r\n                produces =    MediaType.APPLICATION_JSON_UTF8_VALUE)\r\npublic ResponseBean<String> addOrUpdateConfigList(String list) {\r\n    long result =  configService.batchInsertOrUpdate(JSONObject.parseArray(\r\n        list,Config.class));\r\n    ......\r\n}\r\n复制代码管理平台管理平台用vue开发，网络框架采用axios，列表数据通过json字符串传递给后端let config1 = {key: \"ad1Url\", value: this.formData.ad1Url};\r\nlet config2 = {key: \"ad2Url\", value: this.formData.ad2Url};\r\nlet config3 = {key: \"adClick1\", value: this.formData.adClick1};\r\nlet config4 = {key: \"adClick2\", value: this.formData.adClick2};\r\nlet configList = [config1, config2, config3, config4];\r\nlet result = await addConfigList({list: JSON.stringify(co\r\nnfigList)});\r\n......\r\n复制代码小程序小程序调用后端接口返回所有配置项，具体业务根据具体业务key获取配置项getConfigList: function () {\r\n    var that = this;\r\n    wx.request({\r\n      url: constant.HOST + '/config/get_config_list',\r\n      method: 'GET',\r\n      header: {\r\n        'content-type': 'application/json'\r\n      },\r\n      complete: function (res) {\r\n  \r\n      },\r\n      success: function (res) {\r\n        console.log(\"config list response:\" + JSON.stringify(res));\r\n        that.setData({ configList: res.data.data});\r\n      }\r\n    });\r\n },\r\n     \r\ngoAd1: function(){\r\n    wx.navigateTo({\r\n      url: '/pages/webview/webview?url=' + this.data.configList.adClick1\r\n    })\r\n},\r\n\r\n复制代码总结这个功能我在自己的小程序开发过程中设计的页面配置实现思路，主要遇到了两个小问题：1 如果保证key的唯一性 2 前后端批量数据的传输问题；希望能给遇到同样问题的小伙伴一些启示，如果有更好的方案，欢迎一起讨论。"}
{"title": "微信小程序 TypeScript 尝试 ", "author": "Rolan", "pub_time": "2019-2-12 00:08", "content": "自从去年开始在项目里写了一段时间 Javascript 后，感觉没有类型检查的语言还是不太适合我，所以一直想尝试下 TypeScript，然而由于项目庞大，人员协作问题，一时半会没办法切成 TypeScript。正好最近有小程序的需求和小程序去年 11 月开始官方支持了 TypeScript，所以拿来练练手。\r\nWhy TypeScript？\r\n大概是我这半年写的 Swift 比较多，而 Swift 中的静态类型和协议是我很喜欢的特性。正好 TypeScript 为 JavaScript 带来了静态类型和接口。\r\n可选的静态类型\r\n“动态类型一时爽，代码重构火葬场“，对于我这种极度喜欢重（xia）构（gai）代码的人来说，JavaScript 毫无类型提示，类型全靠命名猜测是极度不友好的。而 TypeScript 加上了灵活的类型系统，不仅可以编码期检查，还能增强代码的可读性，并提供了 any 类型进行缓冲。\r\n接口\r\n接口和协议，只是不一样的叫法而已，Java、C#、TypeScript 叫 Interface，Swift、Kotlin 叫 Protocol，就是一种规则声明。项目中，和后端接口数据交互，页面传递数据，数据持有，方法代理的地方，有了接口就会更加方便，易重构。TypeScript 的 Interface + JavaScript 简单的对象就让数据构建变得简单又不容易出错。\r\n小程序对 TypeScript 的支持\r\nTypeScript 有一个很重要的东西，就是 d.ts 文件。d.ts 文件其实相当于 C 系语言里面的 .h 头文件，声明了对外暴露的方法和属性。而小程序官方对 TypeScript 的支持，意味着官方会维护小程序本身 API 的 d.ts 文件，也就是 typing 库，这样当 API 发生变动时，就可以即时变更。\r\n使用也很简单，更新微信开发者工具到最新版，在创建新项目时选择 TypeScript 模板。\r\n\r\n创建后，我们可以看到项目里带上了 typings 库，以及 TypeScript 的配置文件 tsconifg。之后，保存时就不会自动编译了，要点击小程序工具栏的编译按钮才可以。\r\n这里有一个坑，笔者电脑安装的 TypeScript 版本是 3.2.2 版本。编译时会被找不到全局类型 CallableFunction 和 NewableFunction。\r\n\r\n解决方法也很简单，到 node_modules 路径下的 TypeScript 包的 bin 目录下，lib.es5.d.ts 文件里面把这两个类型的 Interface 拷贝到，小程序 typing 目录下的 lib.wa.es6.d.ts 里面就可以了。小程序模板里这个文件应该是拷贝 TypeScript 官方的，但没有随着官方升级而改变。\r\n事件\r\n视图的事件，对应的类型笔者在 typings 中并没有看到有 Interface 定义，所以只能暂时用 any，然后自己再用\r\nas 转一下 event 携带的数据的类型。\r\nPage&Data\r\n每个 Page 对象，在 typing 里是这么定义的。\r\ndeclare const Page: Page.PageConstructor\r\n\r\ninterface PageConstructor {\r\n    <D extends IAnyObject, T extends IAnyObject & PageInstance>(\r\n      options: PageInstance<D, T> & T\r\n    ): void\r\n  }\r\n复制代码也就是说，它支持 D 和 T 两个范型。这两个范型是什么呢？小程序里，Page 是这么写的。\r\nPage({});\r\n复制代码也就是说，options 参数就是一个 PageInstance，范型也被传入了。\r\ninterface PageInstance<D extends IAnyObject = any, T extends IAnyObject = any> extends PageInstanceBaseProps<D>\r\n复制代码PageInstance 里面定义了 Page 声明周期的方法，而且继承自 PageInstanceBaseProps，并将范型 D 传入。\r\ninterface PageInstanceBaseProps<D extends IAnyObject = any> {\r\n    data?: D\r\n    //...\r\n}\r\n复制代码所以这个 D 范型，其实就是 data 的类型接口。因为 data 不是必须实现的，所以这里是可选型 ？。\r\n那么 T 是什么呢？\r\nT extends IAnyObject & PageInstance\r\n复制代码T 其实就是对 PageInstance 的拓展，PageInstance 是 Page 的实例接口，那么 T 其实就是在 Page 里面 this 的类型接口了，也就是说，需要在 Page 里新增的方法和属性，都在 T 里定义。\r\n所以，对于一个普通页面我们可以声明两个接口，一个代表 data， 一个代表 page，举个例子。\r\ninterface IIntroPage {\r\n\tnextButtonTap(event: any): void;\r\n    isLoading: boolean;\r\n}\r\n\r\ninterface IIntroData {\r\n    test: string;\r\n}\r\n\r\nPage<IIntroData, IIntroPage>({\r\n    isLoading: false,\r\n\tnextButtonTap(event: any) {\r\n        this.isLoading = true;\r\n\t}\r\n});\r\n复制代码如果这个页面不需要 data 或者不需要扩展 page，用 IAnyObject 代替 D 或者 T 即可。\r\ninterface PageInstanceBaseProps<D extends IAnyObject = any> {\r\n    data?: D\r\n    setData?<K extends keyof D>(\r\n      data: D | Pick<D, K> | IAnyObject,\r\n      callback?: () => void\r\n    ): void\r\n}\r\n复制代码同时，由于 setData 和 data 都被声明为可选项，使用时需要加上！，this.setData!({}) 和 this.data!。\r\n其他就没什么了，用上 TypeScript 之后，官方的 API 都可以直接看参数和返回值的类型，再也不用去查文档猜测类型了。\r\n调用 JavaScript\r\n为 JavaScript 编写一个简单的 .d.ts 文件，将需要调用的类和方法暴露出来。详情见如何编写一个d.ts文件。\r\n最后\r\n虽然笔者用了 TypeScript 不久，但严格的检查的确让我在增删改接口字段能快速全局重构，而且方法调用联想，API 查看也方便了不少。小程序对 TypeScript 的支持日常使用开发是没有什么问题了，就是官方的文档指引比较少。"}
{"title": "微信小程序-wepy-侧滑删除组件，支持自定义内容区在 ", "author": "Rolan", "pub_time": "2019-2-14 00:04", "content": "在最近的微信小程序开发过程中需要用到侧滑删除的功能，微信小程序官方是没有提供这样的组件，再加上我们的微信小程序使用的是wepy组件开发框架开发的，wepy也没有提供这样的组件，之前也在github上搜索这方面的组件，没有发现合适的，当时只发现了一个开源的: github.com/GeoffZhu/we… 只不过该组件功能单一已经被作者废弃了，无奈自己动手撸了一个侧滑删除组件，现在把它开源出来吧。传送门: github.com/hu670014125…Requirementswepy: \"^1.7.3\"支持功能和特点自定义内容区域：支持之定义内容区域，组件内使用 slot占位。自定义滚动高度：可以自定义scroll-view的高度，默认为屏幕的高度。自定义menu ：如果默认的menu样式不喜欢可以自定义，也可以显示或者隐藏指定的menu。左右滑动：支持左右滑动也可以设置只左右或者右滑。效果如下：如何使用目前支持两种使用模式：1.page页面模式优点：可定制化高，扩展性强。\r\n缺点：集成复杂，代码复用性差。复制代码2.component 组件模式优点：集成简单，代码复用性强，减少包的大小。\r\n缺点：可定制到低。复制代码不建议使用page页面模式，下面详细介绍component 组件模式的使用如何使用// 导入组件\r\nimport SwipeDeleteView from '@/components/wepy-swipe-delete-view'\r\n\r\n// 声明组件\r\n\r\n components = {\r\n      swipeDelete: SwipeDeleteView\r\n    }\r\n    \r\n  // 引用组件\r\n  <template>\r\n  <swipeDelete :list.sync=\"list\">\r\n      <view class=\"item\">{{item.userName}}</view>\r\n    </swipeDelete>\r\n  </template>复制代码配置如下：<swipeDelete   :list.sync=\"list\"\r\n               :scrollHeight=\"scrollHeight\"\r\n               @deleteTap.user=\"deleteTap\"\r\n               @deleteLongTap.user=\"deleteLongTap\"\r\n               @editTap.user=\"editTap\"\r\n               @editLongTap.user=\"editLongTap\"\r\n               @addTap.user=\"addTap\"\r\n               @addLongTap.user=\"addLongTap\"\r\n               @markTap.user=\"markTap\"\r\n               @markLongTap.user=\"markLongTap\">复制代码每个点击事件或者长按事件都会返回两个参数methods = {\r\n      deleteTap(view, item) {\r\n        console.log(item)\r\n        view.deleteItem()\r\n      },\r\n      deleteLongTap(view, item) {\r\n        console.log(item)\r\n        wx.showModal({\r\n          title: '提示',\r\n          content: '确定要删除吗？',\r\n          success: function (res) {\r\n            if (res.confirm) {\r\n              view.deleteItem()\r\n            } else {\r\n              view.closeItem()\r\n            }\r\n          }\r\n        })\r\n      }\r\n   }复制代码view ：view 是SwipeDeleteView对象的本身，可以通过view来做一些其他操作，如:删除当前的itemitem : item 就是当前操作的原始数据，可以通过item获取真正需要的数据当前SwipeDeleteView对外暴露的函数有：如果在使用的过程中遇到什么问题可以告诉我，我及时修复。邮箱：hu670014125@163.com"}
{"title": "用vue重构小程序踩坑之旅(1) --- 微信sdk验签 ", "author": "Rolan", "pub_time": "2019-2-14 00:15", "content": "问题:验签失败　　惨景:用微信sdk实现h5页面的分享,且每个页面分享内容需要自定义.坑1:在Android和ios的系统中,同一个页面Android验签成功,ios验签失败解决方案:因为在使用vue的router时 ios复制出来的页面地址永远都是xxxx.com 而Android系统则是xxx.com/index,这就是照成验签失败的原因;　　查阅解决方案:　　https://www.jianshu.com/p/a470403de789　　大佬写的很详细坑2:某一页面Android验签失败,ios验签成功; --- 脑壳疼解决方案:　　在填埋了坑1后,ios就基本不用考虑单页面验签,但是在某页面中发现Android 验签失败,查出原因是因为url中拼接了中文的埋点.(做小程序跳转时 一般都会加到query中)　　vue中是会把query拼接到url上.建议吧这些数据后期用vuex来保存,(emmm,vue菜鸟,没测过此方案)　 invalid signature签名错误坑3:调用微信sdk的分享接口时,ios成功分享,Android分享失败解决方案(应急解决):　　微信jssdk 1.4使用新的2个分享接口: wx.updateAppMessageShareData 和 wx.updateTimelineShareData 不知道为什么 用了新的接口后就会产生以上问题,所以目前解决方案就是　　用旧的接口wx.onMenuShareTimeline(即将废弃);---脑壳又疼了"}
{"title": "理解小程序的安全与管控 ", "author": "Rolan", "pub_time": "2019-2-14 00:23", "content": "作为一个平台，管控和安全是很有必要性的。虽然说这些是开发自己需要进行防范的，但是平台如果能解决，也算是皆大欢喜了。双线程到底解决了什么先给小程序团队的双线程设计鼓个掌，关于双线程大家也可以回顾下《小程序的底层框架》。H5 的隐患要知道，Web 技术是非常开放灵活的，开发者可以利用 JavaScript 脚本随意地操作 DOM，这是会带来以下的问题：随意地跳转网页，改变界面上的任意内容开发者可以利用 JavaScript 脚本随意地跳转网页，或是改变界面上的任意内容。当然，恶意攻击者也能利用这种便利。获取页面数据小程序也提供可一种可以展示敏感数据的组件，<open-data>能展示包括用户昵称、头像、性别、地理位置等信息（无需用户授权）。如果开发者可以操作 DOM，意味着他们可以随意拿到用户的敏感信息。常见的前端漏洞开发者们普遍重视的安全漏洞，在前端常见的有 XSS 和 CSRF，XSS 是通过注入 JavaScript 脚本的方式来达到特定目的，而 CSRF 则是利用了 cookie。XSS 在双线程的设计中就被过滤了，而 CSRF 会在后面讲到。难以实现的管控为了解决管控与安全问题，小程序需要禁用掉：危险的 HTML 标签或者相关属性，如外跳 url 的 a 标签危险的 API，如操作界面的 API、动态运行脚本的 API如果要一个一个禁止，JavaScript 的灵活性以及浏览器接口的丰富性，会导致很容易遗漏一些危险的接口。并且浏览器内核在不断更新，或许下一版本会新增一个可能会在这套体系下产生漏洞的接口，无法完全避免。安全的逻辑层要怎么彻底解决这些问题呢？给大家点提示：没错，就是沙箱环境。通过提供一个纯 JavaScript 的解释执行环境，这个环境没有浏览器相关接口，当然也不用担心操作 DOM、跳转等问题了。在 iOS 下是用内置的 JavaScriptCore 框架，在安卓下是 JsCore 环境（旧版是腾讯 x5 内核提供，新版是 v8 提供）。一起来回顾下小程序的双线程长什么样子：客户端系统有 JavaScript 的解释引擎，则可以创建一个单独的线程去执行 JavaScript，这个环境下只执行有关小程序业务逻辑的代码。界面渲染相关的任务呢，就丢到 webview 线程里面，通过逻辑层代码去控制渲染哪些界面。把开发者的 JS 逻辑代码放到单独的线程去运行，因为不在 Webview 线程里，所以这个环境没有 Webview 任何接口，自然的开发者就没法直接操作 DOM，也就没法动态去更改界面或者抓取页面数据。同时小程序不支持动态载入脚本，XSS 漏洞自然也无缝可钻。审核机制的管控审核机制，故事要从公众号讲起了。WebView的飞速发展当年随着公众号的出现和繁荣，WebView 的使用频率也越来越高。不少的企业或是小商家、外包公司开始做 H5 页面，各式各样的 H5 活动页、小商城、小测试、小游戏满天飞。当微信中的 WebView 逐渐成为移动 Web 的一个重要入口时，微信就有相关的 JS API 了。2015年初，微信发布了一整套网页开发工具包，开放了拍摄、录音、语音识别、二维码、地图、支付、分享、卡券等几十个API，称之为 JS-SDK。到这个时候，web开发者可以使用到微信的原生能力，去完成一些之前做不到或者很难做到的事情。难管控的 JSSDK由于使用 WebView 和 JSSDK 的人越来越多，微信上越来越多干坏事的人，有人做假红包，有人诱导分享，有伪造一些官方活动，他们会利用 JSSDK 的分享能力变相的去裂变分享到各个群或者朋友圈。由于 JSSDK 是根据域名来赋予 api 权限的，运营人员封了一个域名后，他们立马用别的域名又继续做坏，注册一个新的域名的成本是很低的。小程序的审核机制为了保证小程序的质量，以及符合相关的规范，小程序的发布是需要经过审核的。经过审核的小程序才能对外发布，同时在出现问题时，小程序会被下架停用。另外，每个微信小程序需要事先设置一个通讯域名，小程序只可以跟指定的域名与进行网络通信，包括普通 HTTPS 请求、上传文件、下载文件和 WebSocket 通信，参考框架-网络。这些通讯域名，也都必须要求通过备案。同时，小程序必须使用 HTTPS 发起网络请求。请求时系统会对服务器域名使用的 HTTPS 证书进行校验，如果校验失败，则请求不能成功发起。这些种种的限制和管理模式，都进一步保障了用户的数据和隐私安全。安全的登录机制想必在座的各位前端开发者，都清楚 CSRF 安全漏洞。危险的 cookie跨站请求攻击（CSRF），简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去运行。这利用了 web 中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。通常的罪魁祸首则是浏览器的 cookie 登录态。除了检查 Referer 字段来防范，更有效的一种方式是使用 token。小程序也是这么做的。小程序登录小程序可以通过微信官方提供的登录能力方便地获取微信提供的用户身份标识，快速建立小程序内的用户体系。参考官方时序图：在小程序中调用wx.login()，能拿到一个code作为用户登录凭证（有效期五分钟）。在开发者服务器后台，开发者可使用code换取openid和session_key等信息（code只能使用一次）。可靠的 code假设现在有个接口，请求 https://test.com/getUserInfo?id=1 拉取到微信用户 id 为 1 在我们业务侧的个人信息，那么黑客就可以通过遍历所有的 id，把整个业务侧的个人信息数据全部拉走，会给业务带来很大的安全风险。由于code 5 分钟后会过期，如果黑客要冒充一个用户的话，那他就必须在 5 分钟内穷举所有的身份证 id，然后去开发者服务器换取真实的用户身份。而code在成功换取一次信息之后也会立即失效，即便凭证code生成时间还没过期。显然，黑客要付出非常大的成本才能获取到一个用户信息，同时，开发者服务器也可以通过一些技术手段检测到5分钟内频繁从某个 ip 发送过来的登录请求，从而拒绝掉这些请求。需要保护的 AppSecret开发者的后台就拿到了前边wx.login()所生成的微信登录凭证code，此时就可以拿这个code到微信服务器换取微信用户身份。微信服务器为了确保拿code过来换取身份信息的人就是刚刚对应的小程序开发者，到微信服务器的请求要同时带上AppId和AppSecret。AppId和AppSecret是微信鉴别开发者身份的重要信息，AppId是公开信息，泄露AppId不会带来安全风险，但是AppSecret是开发者的隐私数据不应该泄露，开发者需要好好保护。参考《小程序开发指南》结束语作为一个开放的平台，小程序在提供微信加持、体验加持的能力给开发者使用的同时，也替用户和开发者做了很多安全性上的保障。或许有人说，这是牺牲了开发者的开放性换来的，而我认为这样才是个有灵魂的平台。"}
{"title": "解剖小程序的 setData ", "author": "Rolan", "pub_time": "2019-2-14 00:32", "content": "小程序的双线程，之前也有详细讲过了。而双线程的设计，使得逻辑层和渲染层无法直接进行数据传输。那双线程的渲染机制、通信机制，setData 的出现、工作原理、使用建议等，应该要怎么去理解呢？无处不在的 setData几乎每个开发者都会用到setData，要是在复杂的页面中，写了很多的setData，然后我们会发现页面真的是延迟严重，甚至卡顿、假死。官方在性能优化中有提到：避免频繁的去 setData。避免每次 setData 都传递大量新数据。后台态页面进行 setData。但是到底是为什么呢？setData的出现、设计方案是怎样的，又为何要这么设计呢？一切都还是要从双线程说起。小程序的虚拟 DOM双线程的难题我们知道，小程序的双线程设计，主要为了管控安全，避免操作 DOM。（可参考《小程序的底层框架》）把开发者的 JS 逻辑代码放到单独的线程去运行，因为不在 Webview 线程里，所以这个环境没有 Webview 任何接口，自然开发者就没法直接操作 DOM，也就没法动态去更改界面。但是，这样就产生了新的问题。没法操作 DOM，那用户交互需要界面变化的话怎么办呢？模板数据绑定模版数据绑定的方案，已经成为前端框架中最基础的功能。数据绑定的过程其实不复杂：解析语法生成 AST。根据 AST 结果生成 DOM。将数据绑定更新至模板。浏览器会把 HTML 解析成一棵树，最后渲染出来。整个界面是对应着一棵 DOM 树。其实浏览器页面的 DOM 结构树，也是 AST 的一种，把 HTML DOM 语法解析并生成最终的页面。而模板引擎中常用的，则是将模板语法解析生成 HTML DOM。而最容易引发性能问题的，主要是第三点。而关于数据更新的解决方案，React 首先提出了虚拟 DOM 的设计，而现在也基本被大部分框架吸收，小程序也不例外。虚拟 DOM 机制说到数据更新的 Diff，更多的则是Diff + 更新模板这样一个过程。虚拟 DOM 解决了常见的局部数据更新的问题，例如数组中值位置的调换、部分更新。一般来说计算过程如下：用JS对象模拟DOM树。一个真正的DOM元素非常庞大，拥有很多的属性值。而其中很多的属性对于计算过程来说是不需要的，所以我们的第一步就是简化 DOM 对象。我们用一个 JavaScript 对象结构表示 DOM 树的结构。比较两棵虚拟DOM树的差异。当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异。通常来说这样的差异需要记录，最后得到一组差异记录。把差异应用到真正的DOM树上。对差异记录要应用到真正的 DOM 树上，例如节点的替换、移动、删除，文本内容的改变等。小程序里，由于无法直接操作 DOM，主要也是通过数据传递的方式来进行相关的模版更新。模版绑定的机制、数据更新的机制，都可以参照上面的说明，想更具体理解也可以参考《前端模板引擎》。那么既然不在一个线程，数据的通信是怎么做的呢？小程序的数据通信与渲染机制双线程通信方式小程序的视图层目前使用 WebView 作为渲染载体，而逻辑层是由独立的 JavascriptCore 作为运行环境。在架构上，WebView 和 JavascriptCore 都是独立的模块，并不具备数据直接共享的通道。一个小程序存在多个界面，所以渲染层存在多个 WebView 线程。 逻辑层和渲染层的通信会经由微信客户端（Native）做中转，逻辑层发送网络请求也经由 Native 转发 ，小程序的通信模型如图：当前，视图层和逻辑层的数据传输，实际上通过两边提供的 evaluateJavascript 所实现。即用户传输的数据，需要将其转换为字符串形式传递，同时把转换后的数据内容拼接成一份 JS 脚本，再通过执行 JS 脚本的形式传递到两边独立环境。而 evaluateJavascript 的执行会受很多方面的影响，数据到达视图层并不是实时的。所以我们的setData函数将数据从逻辑层发送到视图层，是异步的。有了线程之间的通信，我们来看看小程序的渲染机制。双线程渲染机制双线程的渲染，其实是结合了前面的一系列机制（模版绑定、虚拟 DOM、线程通信），最后整合的一个执行步骤。1. 通过模版数据绑定和虚拟 DOM 机制，小程序提供了带有数据绑定语法的 DSL 给到开发者，用来在渲染层描述界面的结构。就是我们常见的这些：123<view> {{ message }} </view><view wx:if=\"{{condition}}\"> </view><checkbox checked=\"{{false}}\"> </checkbox>噢，这里顺便吐个槽，wx:if竟然不支持[].indexOf(xx) > -1等等相关的函数运算（摔！）。2. 小程序在逻辑层提供了设置页面数据的 api。不用问就是setData了：123this.setData({  key: value})setData函数用于将数据从逻辑层发送到视图层（异步），同时改变对应的this.data的值（同步）。3. 逻辑层需要更改界面时，只要把修改后的 data 通过 setData 传到渲染层。传输的数据，会转换为字符串形式传递，故应尽量避免传递大量数据。4. 渲染层会根据前面提到的渲染机制重新生成 VD（虚拟 DOM）树，并更新到对应的 DOM 树上，引起界面变化。原生组件的出现原生组件的出现，其实与 setData 的机制也有那么点关系，那么就当题外话一块补充下。频繁交互的性能我们知道，用户的一次交互，如点击某个按钮，开发者的逻辑层要处理一些事情，然后再通过 setData 引起界面变化。这样的一个过程需要四次通信：渲染层 -> Native（点击事件）。Native -> 逻辑层（点击事件）。逻辑层 -> Native（setData）。Native -> 渲染层（setData）。在一些强交互的场景（表单、canvas等），这样的操作流程会导致用户体验卡顿。引入原生组件前面也说过，小程序是 Hybrid 应用，除了 Web 组件的渲染体系（上面讲到），还有由客户端原生参与组件（原生组件）的渲染。引入原生组件主要有 3 个好处：绕过 setData、数据通信和重渲染流程，使渲染性能更好。扩展 Web 的能力。比如像输入框组件（input, textarea）有更好地控制键盘的能力。体验更好，同时也减轻 WebView 的渲染工作。比如像地图组件（map）这类较复杂的组件，其渲染工作不占用 WebView 线程，而交给更高效的客户端原生处理。而原生组件的渲染过程：组件被创建，包括组件属性会依次赋值。组件被插入到 DOM 树里，浏览器内核会立即计算布局，此时我们可以读取出组件相对页面的位置（x, y坐标）、宽高。组件通知客户端，客户端在相同的位置上，根据宽高插入一块原生区域，之后客户端就在这块区域渲染界面。当位置或宽高发生变化时，组件会通知客户端做相应的调整。简单来说，就是 原生组件在 WebView 这一层只需要渲染一个占位元素，之后客户端在这块占位元素之上叠了一层原生界面。有利必有弊，原生组件也是有限制的：最主要的限制是一些 CSS 样式无法应用于原生组件由于客户端渲染，原生组件的层级会比所有在 WebView 层渲染的普通组件要高参考setData《小程序开发指南–6.3 原生组件》结束语总而言之，这一节内容主要是围绕 setData 展开，包括双线程的渲染机制、通信机制，setData 的出现（逻辑层通知渲染层）、工作原理（evaluateJavascript 字符串传递）、使用建议（setData 交互性能）、性能优化（原生组件出现）。小程序乍一看是简单的双线程设计，但仔细研究就会发现设计过程中也遇到了不少问题，不断探索解决才有了现在的美好样子。我们在开发过程中会踩的一些坑，其实在理解原理之后便很容易懂了。现在再来看，官方在性能优化中说到的优化建议，你都能深刻理解了吗？"}
{"title": "node配置微信小程序解密消息以及推送消息 ", "author": "Rolan", "pub_time": "2019-2-15 00:08", "content": "上一篇文章介绍过 微信小程序配置消息推送，没有看过的可以先去查看一下，这里就直接去把那个客服消息接口去解密那个消息了。　　在这里我选择的还是json格式的加密。　　也就是给小程序客服消息发送的消息都会被微信转发到这里配置的地址和接口上面。　　在页面中使用客服消息也就是如下这个效果，是需要用到微信提供的button标签上面的open-type的　　　　点击进入客服消息也就是如下这个效果。　　　　然后你发送的消息就会被转发到上面你配置的那个服务器的端口和那个接口上面，也就是例子中的 　　只不过配置确认的时候的接口是get请求方式，而微信转发消息到这里的接口这里是post请求方式。　　在聊天窗口中发送消息，微信就会把加密后的消息转发到我们的接口  也就是 /checkPushMsg 上面，post请求方式。　　在node中的代码接收，看看微信给我们转发了什么东西呢 1 // 配置前后端的推送消息\r\n 2 router.get('/checkPushMsg', wx_msg.check_push);\r\n 3 \r\n 4 // 那个函数就是如下的处理\r\n 5 exports.handle_customer_sevice = (req, res) => {\r\n 6     console.log('接收到了消息，请求体中');\r\n 7     console.log(req.body);\r\n 8     console.log('接收到了消息，请求url中');\r\n 9     console.log(req.query);\r\n10 }　　我们来查看一下发送过来的什么，我再用文档来比对一下哈。　　现在我在手机上面那个页面里面发送一条消息，任意内容。 　　这里服务器的图片太小了，可以 按住 ctrl + 鼠标滚轮把这里放大看一下，我相信你肯定知道的。　　　　请求url中的内容如下  　　请求体中的内容一个是发送者的 openid，另外一个加密的就是消息内容，它的构成是由  16个字节的随机字符串，4个字节的消息长度，发送的消息，appId由基于AES加解密算法加密而成的。　　这里咱们先不着急解密发送的内容，我们要在解密之前先判断一下是不是微信发送过来的呢，如果不是你在这里解密半天然后发出去那不就难受了。　　上面的图片中也详细的介绍了如何去判断是不是微信发送过来的消息。　　我什么也不想解释了，直接上代码啦。　　 1 exports.handle_customer_sevice = (req, res) => {\r\n 2     console.log('接收到了消息，请求体中');\r\n 3     console.log(req.body);\r\n 4     console.log('接收到了消息，请求url中');\r\n 5     console.log(req.query);\r\n 6     let signature = req.query.signature,\r\n 7         timestamp = req.query.timestamp,\r\n 8         nonce = req.query.nonce,\r\n 9         openid = req.query.openid,\r\n10         encrypt_type = req.query.encrypt_type,\r\n11         msg_signature = req.query.msg_signature,\r\n12         msg_encrypt = req.body.Encrypt; // 密文体\r\n13     \r\n14     // 开发者计算签名\r\n15     let devMsgSignature = sha1(pushToken, timestamp, nonce, msg_encrypt); // 这里的pushToken是 上面那个 配置消息推送 里面设置的Token令牌\r\n16    \r\n17     if(devMsgSignature == msg_signature){\r\n18         console.log('验证成功,是从微信服务器转发过来的消息');\r\n19         \r\n20         res.send('success');\r\n21     }else{\r\n22         console.log('error');\r\n23         res.send('error');\r\n24     }\r\n25 };　　上面的那个sha1函数是这样的 1 /*\r\n 2     @explain sh1加密\r\n 3     @version 1.0.1\r\n 4     \r\n 5     @author : Z\r\n 6     @data : 2019-2-13\r\n 7     \r\n 8     @params : a,b,c……\r\n 9     @return : String 加密完成后的字符串\r\n10  */\r\n11 exports.sha1 = function (...arr) {\r\n12     return crypto.createHash('sha1').update(arr.sort().join('')).digest('hex');\r\n13 };　　上面就可以验证出来如果那个加密的东西确实是那样的就可以验证出来消息确实是由微信发送过来的。  　　然后就要开始解密了，这里我遇到了好多坑，说实话我也不知道下面的代码是谁第一个写出来的，因为官网上面根本就没有Node.js的代码，所以我也是看到了加密消息的构成部分，然后使用下面封装的函数解密。　　 1 /*\r\n 2     @explain: 微信的消息密文解密方法\r\n 3     @version 1.0.1\r\n 4         修复部分消息解析失败的情况\r\n 5     @author: Z\r\n 6     @data :2019-02-14\r\n 7     @params:\r\n 8         obj.AESKey:解密的aesKey值  这里的key就是配置消息推送的那部分\r\n 9         obj.text: 需要解密的密文\r\n10         obj.corpid: 企业的id / 微信小程序的appid\r\n11   \r\n12     @return\r\n13         obj.noncestr  随机数\r\n14         obj.msg_len   微信密文的len\r\n15         obj.msg       解密后的明文\r\n16 */\r\n17 \r\n18 exports.decrypt = function (obj) {\r\n19     let aesKey = Buffer.from(obj.AESKey + '=', 'base64');\r\n20     const cipherEncoding = 'base64';\r\n21     const clearEncoding = 'utf8';\r\n22     const cipher = crypto.createDecipheriv('aes-256-cbc',aesKey,aesKey.slice(0, 16));\r\n23     cipher.setAutoPadding(false); // 是否取消自动填充 不取消\r\n24     let this_text = cipher.update(obj.text, cipherEncoding, clearEncoding) + cipher.final(clearEncoding);\r\n25     /*\r\n26         密文的构成\r\n27             Base64_Encode(AES_Encrypt[random(16B) + msg_len(4B) + msg + $appId])\r\n28         但是由于部分消息是不满足那个 32 位的，所以导致上面那个 cipher.final() 函数报错，所以修改为了自动填充，所以 appId后面还跟着一些字符\r\n29             就无法正常解析了，所以就不返回 corpid 了，然后返回我们想要的东西。\r\n30      */\r\n31     return {\r\n32         noncestr:this_text.substring(0,16),\r\n33         msg_len:this_text.substring(16,20),\r\n34         msg:this_text.substring(20,this_text.lastIndexOf(\"}\")+1)\r\n35     }\r\n36 };　　其中的坑就是我遇到了那个  cipher.setAutoPadding(false) 这里填充的问题，但是有的消息是可以解密出来的，但是有的消息是不可以解密出来的，会报错，所以我就让所有的消息都填充了。　　let this_tex = cipher.update(obj.text, cipherEncoding, clearEncoding) + cipher.final(clearEncoding); 　　解密消息这里的问题是，这是一个加法，前面的那个更新函数会改变 cipher的值，然后导致后面的那个值发生改变，当时找这个错误出现了很多问题。这个问题就是当字体的内容的长度不是32个字节还是什么的倍数的时候，这个函数会报一个500的错误码，然后不知道是哪里的问题，所以我就取消自动填充设置为了false，我就让它一直填充，然后处理那个消息，最后那个明文我再把最后的一个 } 后面截取掉。就可以展示出来了，但是这个里面就无法获取到小程序 appId 了，但是这又有什么必要呢？你后台肯定是知道appId的。　　我把消息处理的完整代码发出来。 1 /*\r\n 2     消息体验证和解密\r\n 3         客服接收到的消息\r\n 4         handle_customer_sevice\r\n 5         \r\n 6 */\r\n 7 \r\n 8 exports.handle_customer_sevice = (req, res) => {\r\n 9     console.log('接收到了消息，请求体中');\r\n10     console.log(req.body);\r\n11     console.log('接收到了消息，请求url中');\r\n12     console.log(req.query);\r\n13     let signature = req.query.signature,\r\n14         timestamp = req.query.timestamp,\r\n15         nonce = req.query.nonce,\r\n16         openid = req.query.openid,\r\n17         encrypt_type = req.query.encrypt_type,\r\n18         msg_signature = req.query.msg_signature,\r\n19         msg_encrypt = req.body.Encrypt; // 密文体\r\n20     \r\n21     // 开发者计算签名\r\n22     let devMsgSignature = sha1(pushToken, timestamp, nonce, msg_encrypt);\r\n23     \r\n24     if(devMsgSignature == msg_signature){\r\n25         console.log('验证成功,是从微信服务器转发过来的消息');\r\n26         \r\n27         let returnObj = decrypt({\r\n28             AESKey: config.server.EncodingAESKey,\r\n29             text: msg_encrypt,\r\n30             corpid: config.app.appId\r\n31         });\r\n32         console.log('解密后的消息');\r\n33         console.log(returnObj);\r\n34         console.log('解密后的消息内容');\r\n35         const decryptMessage = JSON.parse(returnObj.msg);\r\n36         console.log(decryptMessage);\r\n37      \r\n38         /*\r\n39             详细参数请查看官网 消息 https://developers.weixin.qq.com/miniprogram/dev/api/sendCustomerMessage.html\r\n40             @params\r\n41                 access_token  调用接口凭证\r\n42                 touser   用户的openid\r\n43                 msgtype   消息类型\r\n44          */\r\n45         \r\n46         if(JSON.parse(returnObj.msg).Content == '值班'){\r\n47             axios.post(config.url.ip + config.url.P_CustomSend + '?access_token='+config.access_token, {\r\n48                     touser: decryptMessage.FromUserName,\r\n49                     msgtype: \"text\",\r\n50                     text: {\r\n51                         content: \"发送消息\"\r\n52                     }\r\n53                 })\r\n54                 .then(res => {\r\n55                     console.log('消息接口发送成功');\r\n56                     \r\n57                     console.log(res.data);\r\n58                     if(res.data.errcode == 0){\r\n59                         console.log('消息发送成功');\r\n60                     }else if(res.data.errcode == 40001){\r\n61                         console.log('access_token过期');\r\n62                     }else{\r\n63                         console.log('其他错误信息')\r\n64                     }\r\n65                     console.log(res.data);\r\n66                 })\r\n67                 .catch(err => {\r\n68                     console.log('错误消息');\r\n69                     console.log(err);\r\n70                 })\r\n71         }\r\n72         res.send('success');\r\n73     }else{\r\n74         console.log('error');\r\n75         res.send('error');\r\n76     }\r\n77 };　　　　上面用到的两个函数 一个 sha1，另外一个就是 解密函数。　　现在发送一下消息，看一看服务器上面的处理过程。   　　如此是可以解密出来那个消息的内容的，然后我设置了一个发送值班的话会给我发送一个消息。　　   　　如此 就大功告成了。　　看了网上的许多文章大多都是Java，php的代码，很少有Node的代码，而且看了之后也不知道能不能弄出来，如果你遇到这个问题， 仔细看了我的文章之后，还有地方不知道，欢迎打扰我，告诉我哪里不清楚，我也会和你一起把你的问题解决掉。　　如果解决了你的问题我会非常高兴的，其实上面的文章中我也感觉到了有一些地方描述的不是那么清晰，比如说消息加密的那一块，说实话，我也不是那么了解他的加密，只是微信 这里是有讲述的 点击查看　　它的加密我会在最近几天研究一下，把他的加密的细节也给发出来，下一篇文章你可以查看到它的加密。　　如果解决了你的问题我真的会非常高兴，因为我开发了这么久感觉开发出来的东西都没有去影响一些人，甚至我想先给自己做一些程序，并且我已经开始着手去做了，先去方便一下自己再去做一些去对一些人有好处的影响的东西。"}
{"title": "关于小程序的基础库 ", "author": "Rolan", "pub_time": "2019-2-15 00:22", "content": "小程序的基础库，它包含了哪些东西，以及载入、更新的机制又是怎样的呢。小程序基础库的组成基础库成分关于基础库的成分，不得不提到我们之前说过的小程序渲染机制，参考 React 的 Virtual DOM。基础库除了处理 VD 的渲染问题，它还包括内置组件和逻辑层API，总的来说负责处理数据绑定、组件系统、事件系统、通信系统等一系列框架逻辑。小程序的基础库是 JavaScript 编写的，它可以被注入到渲染层和逻辑层运行。在渲染层可以用各类组件组建界面的元素，在逻辑层可以用各类 API 来处理各种逻辑。同时，小程序的一些补充能力：自定义组件和插件，也有相应的基础代码，当然也需要添加到基础库里。所以我们可以看到，小程序的基础库主要是：提供 VD 渲染机制相关基础代码。（Exparser 框架）提供封装后的内置组件。提供逻辑层的 API。提供其他补充能力（自定义组件和插件等）的基础代码。Exparser 框架Exparser 是微信小程序的组件组织框架，内置在小程序基础库中，为小程序的各种组件提供基础的支持。小程序内的所有组件，包括内置组件和自定义组件，都由 Exparser 组织管理。Exparser 会维护整个页面的节点树相关信息，包括节点的属性、事件绑定等，相当于一个简化版的 Shadow DOM 实现。Exparser 的主要特点包括以下几点：基于 Shadow DOM 模型：模型上与 WebComponents 的 ShadowDOM 高度相似，但不依赖浏览器的原生支持，也没有其他依赖库；实现时，还针对性地增加了其他 API 以支持小程序组件编程。可在纯 JS 环境中运行：这意味着逻辑层也具有一定的组件树组织能力。高效轻量：性能表现好，在组件实例极多的环境下表现尤其优异，同时代码尺寸也较小。基于这个框架，内置了一套组件，以涵盖小程序的基础功能，便于开发者快速搭建出任何界面。同时也提供了自定义组件的能力，开发者可以自行扩展更多的组件，以实现代码复用。内置组件小程序基于 Exparser 框架，内置了一套组件，提供了视图容器类、表单类、导航类、媒体类、开放类等几十种组件。内置组件在小程序框架里的定义是：在小程序架构里无法实现或者实现不好某类功能，使用组件内置到小程序框架里。常见包括：开放类组件：如 open-data 组件提供展示群名称、用户信息等微信体系下的隐私信息，有 button 组件里 open-type 属性所提供分享、跳转 App 等敏感操作的能力视图容器类组件：如 movable-view 这种因双线程模型导致手势识别不好实现的组件（在双线程模型中，触摸事件从渲染层发出，派发到逻辑层，这中间是有一定的延时而导致视图跟随手指运动这类交互变得有些卡顿）API宿主环境提供了丰富的API，可以很方便调起微信提供的能力。小程序提供的 API 按照功能主要分为几大类：网络、媒体、文件、数据缓存、位置、设备、界面、界面节点信息还有一些特殊的开放接口。需要注意 API 调用大多都是异步的。自定义组件自定义组件是开发者可以自行扩充的组件。开发者可以将常用的节点树结构提取成自定义组件，实现代码复用。在使用自定义组件的小程序页面中，Exparser 将接管所有的自定义组件注册与实例化。以 Component 为例：在小程序启动时，构造器会将开发者设置的 properties、data、methods 等定义段，写入 Exparser 的组件注册表中。这个组件在被其它组件引用时，就可以根据这些注册信息来创建自定义组件的实例。Page 构造器的大体运行流程与之相仿，只是参数形式不一样。这样每个页面就有一个与之对应的组件，称为“页面根组件”。在初始化页面时，Exparser 会创建出页面根组件的一个实例，用到的其他组件也会响应创建组件实例（这是一个递归的过程）。插件插件是对一组 js 接口、自定义组件或页面的封装，用于嵌入到小程序中使用。插件不能独立运行，必须嵌入在其他小程序中才能被用户使用；而第三方小程序在使用插件时，也无法看到插件的代码。因此，插件适合用来封装自己的功能或服务，提供给第三方小程序进行展示和使用。插件开发者可以像开发小程序一样编写一个插件并上传代码，在插件发布之后，其他小程序方可调用。小程序平台会托管插件代码，其他小程序调用时，上传的插件代码会随小程序一起下载运行。小程序基础库机制基础库的载入在开发网页时，经常会引用很多开源的 JS 库，在使用到这些库所提供的 API 前，我们需要先在业务代码前边引入这些库。同样道理，我们需要在启动 APP 之前载入基础库，接着再载入业务代码。由于小程序的渲染层和逻辑层是两个线程管理，而我们 一般说起基础库，也通常包括 WebView 基础库（渲染层），和 AppService 基础库（逻辑层）。显然，所有小程序在微信客户端打开的时候，都需要注入相同的基础库。所以，小程序的基础库不会被打包在某个小程序的代码包里边，它会被提前内置在微信客户端。将基础库内置在微信客户端，有两个好处：降低业务小程序的代码包大小。可以单独修复基础库中的Bug，无需修改到业务小程序的代码包。小程序的启动在小程序启动前，微信会提前准备好一个页面层级用于展示小程序的首页。这里就包括了逻辑层和渲染层分别的初始化以及公共库的注入。在小程序启动时，微信会为小程序展示一个固定的启动界面，界面内包含小程序的图标、名称和加载提示图标。此时，微信会在背后完成几项工作：下载小程序代码包、加载小程序代码包、初始化小程序首页。基础库的更新小程序的很多能力需要微信客户端来支撑，例如蓝牙、直播能力、微信运动等，可以说，小程序基础库的迭代离不开微信客户端的发布。为了避免新版本的基础库给线上小程序带来未知的影响，微信客户端都是携带上一个稳定版的基础库发布的。等到微信客户端正式发布后，小程序会开始灰度推送新版本的基础库到微信客户端里，在这个过程需要仔细监控各类异常现象以及开发者和用户的反馈，一般灰度时长为12小时，灰度结束后，用户设备上就会有新版本的基础库。如果存在重大Bug，那此次推送会被回退。参考《小程序开发指南——小程序基础库的更新迭代》《小程序开发指南——6.2 组件系统》结束语本节大致结合了小程序的启动来讲了下小程序的基础库。其实很多都能在小程序开发指南里找到，只是文字太多又有些乱，看一遍未必能记住，但是第二遍又找不到了。哈哈哈吐槽下小程序的文档，很详细就是有点容易找不到。"}
{"title": "小程序的底层框架 ", "author": "Rolan", "pub_time": "2019-2-15 00:25", "content": "前端的框架太多让人眼花缭乱，很多相似的地方，优秀的地方大家都会借鉴，同时又会有各自的一些特点。小程序也好，其他框架也好，理解他们的设计缘由、实现原理，还是能学到很多很多东西的。一切始于双线程技术选型上一节《小程序的诞生》中，我们也提到了小程序的双线程设计。目前来说，页面渲染的方式主要有三种：Web 渲染。Native 原生渲染。Web 与 Native 两者掺杂，也即我们常说的 Hybrid 渲染。前面也说过，小程序最终的呈现形式，是 WebView + 原生组件，Hybrid 方式。我们结合之前对小程序的期望来看：开发门槛：Web 门槛低，不过 Native 也有像 RN 这样的框架支持体验：Native 体验比 Web 不要好太多，Hybrid 在一定程度上比 Web 接近原生体验版本更新：Web 支持在线更新，Native 则需要打包到微信一起审核发布管控和安全：Web 可跳转或是改变页面内容，存在一些不可控因素和安全风险由于小程序的宿主是微信，如果用纯客户端原生技术来编写小程序 ，那小程序代码需要与微信代码一起编包，跟随微信发版本，这种方式跟开发节奏必然都是不对的。所以方向应该是需要像 Web 技术那样，有一份随时可更新的资源包放在云端，通过下载到本地，动态执行后即可渲染出界面。如果用纯 Web 技术来渲染小程序，在一些有复杂交互的页面上可能会面临一些性能问题。这是因为在 Web 技术中，UI渲染跟 JavaScript 的脚本执行都在一个单线程中执行，这就容易导致一些逻辑任务抢占UI渲染的资源。总地看来，小程序选择了 Hybrid 的渲染方式，可以用一种近似 Web 的方式来开发，并且还可以实现在线更新代码。同时，引入原生组件有以下好处：扩展 Web 的能力。比如像输入框组件（input, textarea）有更好地控制键盘的能力体验更好，同时也减轻 WebView 的渲染工作绕过 setData、数据通信和重渲染流程，使渲染性能更好现在，我们还剩下一个很重要的问题：管控性和安全性。于是，双线程的设计被提出来了。双线程的小程序也不知道是哪位大佬，能想出双线程这样的模型，反正我是佩服得666的。双线程是什么？我们先来看个官方的图：小程序的渲染层和逻辑层分别由 2 个线程管理：渲染层的界面使用了 WebView 进行渲染，逻辑层采用 JsCore 线程运行 JS 脚本。为什么要这么设计呢？前面提到的管控和安全，为了解决这些问题，我们需要阻止开发者使用一些浏览器提供的，诸如跳转页面、操作 DOM、动态执行脚本的开放性接口。我们可以使用客户端系统的 JavaScript 引擎，iOS下的 JavaScriptCore 框架，安卓下腾讯 x5 内核提供的 JsCore 环境。通过提供一个沙箱环境来运行开发者的 JavaScript 代码来解决。这个沙箱环境只提供纯 JavaScript 的解释执行环境，没有任何浏览器相关接口。这就是小程序双线程模型的由来：逻辑层：创建一个单独的线程去执行 JavaScript，在这个环境下执行的都是有关小程序业务逻辑的代码渲染层：界面渲染相关的任务全都在 WebView 线程里执行，通过逻辑层代码去控制渲染哪些界面。一个小程序存在多个界面，所以渲染层存在多个 WebView 线程双线程通信把开发者的 JS 逻辑代码放到单独的线程去运行，但在 Webview 线程里，开发者就没法直接操作 DOM。那要怎么去实现动态更改界面呢？前面我们知道，逻辑层和渲染层的通信会由 Native （微信客户端）做中转，逻辑层发送网络请求也经由 Native 转发。这是不是意味着，我们可以把 DOM 的更新通过简单的数据通信来实现呢？Virtual DOM 相信大家都已有了解，大概是这么个过程：用JS对象模拟DOM树 -> 比较两棵虚拟DOM树的差异 -> 把差异应用到真正的DOM树上。在这里我们可以用上，如图：在渲染层把 WXML 转化成对应的 JS 对象。在逻辑层发生数据变更的时候，通过宿主环境提供的 setData 方法把数据从逻辑层传递到 Native，再转发到渲染层。经过对比前后差异，把差异应用在原来的 DOM 树上，更新界面。我们通过把 WXML 转化为数据，通过 Native 进行转发，来实现逻辑层和渲染层的交互和通信。而这样完整的一套框架，基本上都是通过小程序的基础库来完成的。小程序的基础库小程序的基础库是 JavaScript 编写的，它可以被注入到渲染层和逻辑层运行。主要用于：在渲染层，提供各类组件来组建界面的元素在逻辑层，提供各类 API 来处理各种逻辑处理数据绑定、组件系统、事件系统、通信系统等一系列框架逻辑由于小程序的渲染层和逻辑层是两个线程管理，两个线程各自注入了基础库。小程序的基础库不会被打包在某个小程序的代码包里边，它会被提前内置在微信客户端。这样可以：降低业务小程序的代码包大小可以单独修复基础库中的 Bug，无需修改到业务小程序的代码包Exparser 框架Exparser 是微信小程序的组件组织框架，内置在小程序基础库中，为小程序的各种组件提供基础的支持。小程序内的所有组件，包括内置组件和自定义组件，都由 Exparser 组织管理。Exparser 特点包括：基于 Shadow DOM 模型：模型上与 WebComponents 的 ShadowDOM 高度相似，但不依赖浏览器的原生支持，也没有其他依赖库；实现时，还针对性地增加了其他API以支持小程序组件编程。可在纯JS环境中运行：这意味着逻辑层也具有一定的组件树组织能力。高效轻量：性能表现好，在组件实例极多的环境下表现尤其优异，同时代码尺寸也较小。关于基础库和 Exparser 框架，更多的也可以参考：《小程序开发指南》结束语这节里大概讲了小程序设计中比较重要的一个模型——双线程，关于双线程的出现、设计、数据通信，到基础库、Exparser 框架，都是一个个相关而又相互影响的选择。关于小程序的底层框架设计，其实还涉及更多更多我们未能一时半会掌握完的内容，自定义组件、原生组件，还有他们做了很多的性能优化工作，都不是只言片语能讲完的。我们能做的，就是多去思考。"}
{"title": "小程序页面管理与跳转 ", "author": "Rolan", "pub_time": "2019-2-15 00:31", "content": "一个小程序有很多页面，每个页面又有各自的线程、生命周期和功能逻辑。关于小程序的生命周期、页面之间的跳转有哪些特殊的地方呢？小程序的启动小程序启动过程初次进入小程序的时候，微信客户端初始化好宿主环境，同时从网络下载或者从本地缓存中拿到小程序的代码包，把它注入到宿主环境。大概是这么个过程：创建线程（渲染层和逻辑层），启动小程序。载入基础库（WebView 基础库和 AppService 基础库）。载入小程序业务代码（下载或者从本地缓存中拿到）。使用App()注册程序实例。为了让小程序业务代码能够调用 API 以及组件，就需要在启动小程序后先载入基础库，接着再载入业务代码。由于所有小程序都需要注入相同的基础库，所以小程序的基础库会被提前内置在微信客户端。而基础库是热更新的，故一般等微信客户端携带上一个稳定版的基础库正式发布后，再进行新版本基础库的灰度和推送。注册 App 实例宿主环境提供了App()构造器用来注册一个程序 App。App 实例是单例对象，在其他 JS 脚本中可以使用宿主环境提供的getApp()来获取程序实例。App() 必须在 app.js 中调用，必须调用且只能调用一次。不然会出现无法预期的后果。App()函数用来注册一个小程序。接受一个Object参数，其指定小程序的生命周期回调等。onLaunch小程序初始化完成时（全局只触发一次）触发onLaunch回调。在微信客户端中打开小程序有很多途径，对不同途径的打开方式，小程序有时需要做不同的业务处理。所以微信客户端会把打开方式带给onLaunch和onShow的调用参数options，我们可以根据参数来判断一些进入方式，以及做对应的逻辑处理。例如，我需要拿到从另外一个小程序跳转过来携带的信息，此时场景值应该是1037（参考场景值）：123456789App({  // ...  onShow: function(e) {    if(e.scene === 1037){      const data = e.referrerInfo && e.referrerInfo.extraData; // 拿到对应的数据      const refAppid = e.referrerInfo && e.referrerInfo.appId; // 拿到对应的小程序appid    }  }})onShow小程序启动，或从后台进入前台显示时触发onShow回调。通常我们用来处理数据和状态的更新。小程序进入后台状态：当用户点击左上角关闭，或者按了设备 Home 键离开微信，小程序并没有直接销毁。onHide小程序从前台进入后台时触发onHide回调。小程序进入前台状态：当再次进入微信或再次打开小程序，又会从后台进入前台。获取 App 实例我们可以使用全局的getApp()函数来获取到小程序 App 实例（在App()内的函数中使用this就可以拿到app实例。）。前面我们可以看到，App 的生命周期是由微信客户端根据用户操作主动触发的。故我们通过getApp()获取实例之后，不应该私自调用生命周期函数。具体的原理是什么呢？小程序的 JS 脚本是运行在 JsCore 的线程里，小程序的每个页面各自有一个 WebView 线程进行渲染，所以小程序切换页面时，小程序逻辑层的 JS 脚本运行上下文依旧在同一个 JsCore 线程中。因此，App 构造器可以传递其他参数作为全局属性以达到全局共享数据的目的。由于所有页面的脚本逻辑都跑在同一个 JsCore 线程，页面使用setTimeout或者setInterval的定时器，即使切换了页面，也需要自行清理定时器。可以选择：在页面离开onUnload、onHide等的时候自行清理做全局的定时器管理（当然也还是需要关闭时清理）说到页面之间的数据共享，我们也该来讲讲小程序里页面的启动。小程序页面页面生命周期宿主环境提供了Page(Object)构造器用来注册一个小程序页面，接受一个Object类型参数，其指定页面的初始数据、生命周期回调、事件处理函数等。注意：Object 内容在页面加载时会进行一次深拷贝，需考虑数据大小对页面加载的开销。这里我们先来看看官方的生命周期图：左侧是渲染层，右侧是逻辑层。几件事：渲染层和逻辑层之间通信，是通过 Native 转发实现的。逻辑层通过 Page 实例的setData方法传递数据到渲染层。由于需要两个线程的一些通信消耗，为了提高性能，每次只设置需要改变的最小单位数据。生命周期顺序：onLoad -> onShow -> onReady。页面生命周期函数：onLoad(Object query)页面加载时触发。一个页面只会调用一次，可以在onLoad的参数中获取打开当前页面路径中的参数。onShow()页面显示/切入前台时触发。onReady()页面初次渲染完成时触发。一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互。onHide()页面隐藏/切入后台时触发。onUnload()页面卸载时触发。和小程序实例的生命周期对比，其实页面也是有些相似。这里需要注意几点：当前页面路径的参数获取，只能在onLoad(query)的query参数中获取，无法在onShow()中获取onLoad、onReady和onUnload，一个页面都只会调用一次页面是卸载还是切换到后台，这些除了与小程序的后台切换有关系，还会与页面的跳转、切换逻辑有关系下面我们就来看下页面的逻辑。页面导航我们知道，一个小程序会拥有多个页面。在小程序里会有页面的层级关系，例如通过wx.navigateTo推入一个新的页面，在首页使用2次wx.navigateTo后，页面层级会有三层：获取页面栈getCurrentPages()函数用于获取当前页面栈的实例，以数组形式按栈的顺序给出，第一个元素为首页，最后一个元素为当前页面。需要注意的是：修改页面栈会导致路由以及页面状态错误App.onLaunch的时候 page 还没有生成，不能在这调用getCurrentPages()但是其实不是每一次切换页面，都会被记录到页面栈里，我们看看页面导航的一些方法和行为：关于导航 API 的几个补充点：wx.navigateTo和wx.redirectTo只能打开非 TabBar 页面，wx.switchTab只能打开 Tabbar 页面，wx.reLaunch可以打开任意页面TabBar 页面指在 app.json 的 TabBar 字段定义的页面（客户端窗口的底部或顶部有 tab 栏可以切换页面）跳转到 TabBar 页面，路径后不能带参数（注意，Tabbar 页面初始化之后不会被销毁）调用页面路由带的参数可以在目标页面的onLoad中获取页面层级准备我们知道页面栈的表现，以及一些常见的导航方法，而小程序基础库也在页面层级做了些体验优化。对于每一个新的页面层级，视图层都需要进行一些额外的准备工作：在小程序启动前，微信会提前准备好一个页面层级用于展示小程序的首页每当一个页面层级被用于渲染页面，微信都会提前开始准备一个新的页面层级，减少每次新开页面的耗时每个页面的准备都有三个阶段：启动一个 WebView。WebView 中初始化基础库（此时还会进行一些基础库内部优化，以提升页面渲染性能）。注入小程序 WXML 结构和 WXSS 样式（小程序能在接收到页面初始数据之后马上开始渲染页面）。PS：wx.redirectTo不会打开一个新的页面层级，而是将当前页面层级重新初始化。参考导航.小程序路由.小程序3.2 程序与页面7.2 页面层级准备结束语页面的路由和跳转、切入方式，其实和用户的使用和交互紧紧相关，设计合理也是能大大提升用户体验的。其实这一节的内容，大部分都是小程序文档里面有的。只不过好些相关的内容被分散在各个地方，理解和使用起来还是需要查找，这一节就当作整理笔记吧。"}
{"title": "小程序button引导用户授权 ", "author": "Rolan", "pub_time": "2019-2-18 00:23", "content": "wx.getUserInfo(OBJECT) 注意：此接口有调整，使用该接口将不再出现授权弹窗，请使用<button open-type=\"getUserInfo\"></button>引导用户主动进行授权操作所以我们要使用上述button来请求用户授权1.index.wxml<button \r\n    wx:if=\"{{canIUse}}\" \r\n    open-type=\"getUserInfo\" \r\n    bindgetuserinfo=\"bindGetUserInfo\"\r\n>授权登录</button>\r\n<view wx:else>请升级微信版本</view>2.index.jsPage({\r\n  data: {\r\n    //判断小程序的API，回调，参数，组件等是否在当前版本可用。\r\n    canIUse: wx.canIUse('button.open-type.getUserInfo')\r\n  },\r\n  onLoad: function () {\r\n    // 查看是否授权\r\n    wx.getSetting({\r\n      success: function (res) {\r\n        if (res.authSetting['scope.userInfo']) {\r\n          wx.getUserInfo({\r\n            success: function (res) {\r\n              console.log(res.userInfo)\r\n              //用户已经授权过\r\n            }\r\n          })\r\n        }\r\n      }\r\n    })\r\n  },\r\n  bindGetUserInfo: function (e) {\r\n    console.log(e.detail.userInfo)\r\n    if (e.detail.userInfo) {\r\n      //用户按了允许授权按钮\r\n    } else {\r\n      //用户按了拒绝按钮\r\n    }\r\n  }\r\n})注：如果未出现微信授权的弹窗，则可能是因为之前授权的缓存导致的，因为只有未授权才会出现弹窗，清除缓存即可参考： https://blog.csdn.net/weixin_...https://blog.csdn.net/weidong...https://www.cnblogs.com/legen..."}
{"title": "小程序端实现文本展示以及标题定位 ", "author": "Rolan", "pub_time": "2019-2-18 00:34", "content": "探讨一个针对文本内容设置标题定位的业务场景。\r\n业务场景\r\n管理后台录入/编辑一段md或富文本协议，小程序端进行展示协议，且在小程序实现标题侧边栏，能快速定位至对应的内容。如图所示\r\n\r\n\r\n管理后台：录入内容实现方式\r\n1. 产出 长文本\r\n管理后台录入时，录入以markdown格式或富文本格式。\r\n由于项目在早期已进入开发，当时对markdown的转化工具兼容性较低，所以选择采取以富文本的方式进行保存。\r\n2. 产出 标题列表\r\n录入后，检索出对应的标题，将标题赋予对应标识，产出 标题列表。\r\n客户端：小程序实现方式\r\n小程序的实现方式有多种，先讲比较常用的两种方式：\r\n方式一：wxParse + <scrollView>\r\n采用微信小程序创建 wxParse —— 微信小程序富文本解析组件，支持Html及markdown转wxml可视化。\r\n\r\n\r\n优点\r\n\r\n对富文本支持程度很高，样式上可以按需调整\r\n易定制化，对于图片、链接等，可根据不同需要来控制其点击效果\r\n\r\n\r\n\r\n缺点\r\n\r\n解析时间随着元素的数量而不同。对html元素都进行解析，如果遇到一些表格类型，就会有特别多<tr> 、<td> 标签，解析速度非常缓慢，导致等待时间很长，用户体验不好。但如果采用方式二，就可以避开对内容的解析，不需要再控制解析时间。\r\n\r\n\r\n\r\n方式二：web-view + 网页展示\r\n文本的内容就全部放到一个h5网页来实现，在小程序端就通过 web-view 组件来展示这个网页内容。\r\n但对于标题的定位跳转，也可以有不同实现方式：\r\n<a> 标签做标题跳转的锚点\r\n\r\n\r\n优点\r\n\r\n富文本展示，内容不需要很多调整\r\n设定锚点非常简单，跳转容易\r\n\r\n\r\n\r\n缺点\r\n\r\n\r\n通过触发点击带锚点的链接，浏览器前进后退可能导致hash的变化。点击返回的时候，返回的不是上一页面，而是上一个定位的位置。详情可查看《理解浏览器历史记录》\r\n\r\n\r\n\r\n\r\n\r\n由于用<a> 标签做标题跳转的锚点的方式，对\"返回\"按钮不友好，所以采用另一种方式，用 js 模仿 <a> 标签跳转。\r\njs 控制滚动，仿 <a> 标签跳转\r\n\r\n\r\n优点\r\n\r\n富文本展示，内容不需要很多调整\r\n设定锚点非常简单，跳转容易\r\n能返回上一页面\r\n\r\n\r\n\r\n缺点\r\n\r\n需要处理那些非业务域名下的链接跳转，否则会弹出非法域名的提示，对用户不友好。\r\n微信其他组件的使用受到限制，例如点击图片预览等，需要加jssdk配置\r\n\r\n不过上述的两个缺点都可以通过网页进行解决，剩下的是开发便捷性的问题。\r\n\r\n\r\n总结\r\n上面的实现方式仅仅是富文本的方式，如今对 markdown 格式的应用和转化的支持性都有所提高，所以针对 markdown 格式的文本，也可以做类似的探讨。如果你有想法可以和我们一起交流，并且我们也在招聘 web前端开发工程师 ，如果有兴趣也可以加入我们哟O(∩_∩)O ，了解更多或者投递简历到邮箱 web@talkmoney.cn。\r\n\r\n\r\n作者简介：土拨鼠，芦苇科技web前端开发工程师，代表作品：飞花亭小程序、续航基因、YY表情红包、YY叠方块直播竞赛小游戏。擅长网站建设、公众号开发、微信小程序开发、小游戏、公众号开发，专注于前端框架、服务端渲染、SEO技术、交互设计、图像绘制、数据分析等研究，有兴趣的小伙伴来撩撩我们~ web@talkmoney.cn"}
{"title": "关于微信 setData 回调函数中的坑 ", "author": "Rolan", "pub_time": "2019-2-18 00:43", "content": "最近在做录音功能，需求大体是这样的：点击开始录音按钮，页面状态变为录音中，然后开始录音。不过伟大的测试同学发现了一个问题：当快速的连续点击开始录音按钮时，会触发多次开始录音的事件，这样在结束录音时就仍然会有一个正在录音中的标识，像这样:下面开始曲折的修复之路:最开始的代码是这样的:Page({\r\n\r\n  /**\r\n   * 生命周期函数--监听页面加载\r\n   */\r\n  onLoad: function(options) {\r\n    // 初始化录音管理器\r\n    this.recorderManager = wx.getRecorderManager()\r\n\r\n    // 录音开始事件\r\n    this.recorderManager.onStart(() => {\r\n      \r\n    })\r\n  },\r\n\r\n  /**\r\n   * 录音按钮点击事件\r\n   */\r\n  tapRecordBtn: function() {\r\n    this.setData({\r\n      // 切换页面显示\r\n    }, () => {\r\n      // 开始录音\r\n      this.recorderManager.start({})\r\n    })\r\n  },\r\n})这时我的猜测是：页面重新渲染之前，按钮还是显示状态，所以还能被点击。那既然这样，就加个标识，在一次点击之后，到页面重新渲染之前，都不能再次点击就好了，代码如下：Page({\r\n\r\n  /**\r\n   * 生命周期函数--监听页面加载\r\n   */\r\n  onLoad: function(options) {\r\n    // 初始化录音管理器\r\n    this.recorderManager = wx.getRecorderManager()\r\n    // 录音开始按钮点击标识\r\n    this.isRecordBtnClicked = false\r\n\r\n    // 录音开始事件\r\n    this.recorderManager.onStart(() => {\r\n\r\n    })\r\n  },\r\n\r\n  /**\r\n   * 录音按钮点击事件\r\n   */\r\n  tapRecordBtn: function() {\r\n    // 如果录音按钮已被点击(录音即将开始)，则不会再次触发开始录音事件\r\n    if (this.isRecordBtnClicked) {\r\n      return\r\n    }\r\n    this.isRecordBtnClicked = true\r\n\r\n    this.setData({\r\n      // 切换页面显示\r\n    }, () => {\r\n      this.isRecordBtnClicked = false\r\n      // 开始录音\r\n      this.recorderManager.start({})\r\n    })\r\n  },\r\n})想法是好的，不过并没有实现想要的效果。还是可以被多次点击。于是在多次实验之后，改为如下的方式（可行）：Page({\r\n\r\n  /**\r\n   * 生命周期函数--监听页面加载\r\n   */\r\n  onLoad: function(options) {\r\n    // 初始化录音管理器\r\n    this.recorderManager = wx.getRecorderManager()\r\n    // 录音开始按钮点击标识\r\n    this.isRecordBtnClicked = false\r\n\r\n    // 录音开始事件\r\n    this.recorderManager.onStart(() => {\r\n      // 将录音按钮的点击状态在录音开始时修改\r\n      this.isRecordBtnClicked = false\r\n    })\r\n  },\r\n\r\n  /**\r\n   * 录音按钮点击事件\r\n   */\r\n  tapRecordBtn: function() {\r\n    // 如果录音按钮已被点击(录音即将开始)，则不会再次触发开始录音事件\r\n    if (this.isRecordBtnClicked) {\r\n      return\r\n    }\r\n    this.isRecordBtnClicked = true\r\n\r\n    this.setData({\r\n      // 切换页面显示\r\n    }, () => {\r\n      // 开始录音\r\n      this.recorderManager.start({})\r\n    })\r\n  },\r\n\r\n})将按钮的点击状态在录音开始事件中进行重置，就可以解决这个问题了。说一下最后验证的结果：setData() 方法的回调函数并不是在页面重新渲染完之后才执行的，所以并不能以回调函数作为一个明确的时间点来处理一些逻辑。而由于recorderManager.onStart() 方法触发时会有一定的延时，所以间接的解决了这个问题。"}
{"title": "微信小程序的登录体系 ", "author": "Rolan", "pub_time": "2019-2-19 00:21", "content": "我们知道，WEB服务器通过浏览器携带的cookie获取session来判断是否是同一用户（或浏览器）。cookie 和 session 的区别cookie 和 session 并不是同一个层面的东西。cookie 是实际真实存在的一个东西，是http协议规定的，如同一种载体，我们可以在响应头里面设置 cookie，只要你愿意，你可以在cookie里面设置任何东西，不管是用户信息用户昵称, 但是这样有安全性风险，cookie里面不适合有敏感性的信息，比如说，只放 session_idsession 是一个抽象概念，是客户端和服务端保持会话的一种方法，一种通用的机制。 session 的意思是 会话 ，实现是：服务端把一个 唯一标识 和用户身份的对应的关系存储下来，存在 redis , 文件 ， 数据库 中都可以。客户端出的请求带上 唯一标识 ，服务端从 redis或者 文件 或者 数据库 中找出这个 唯一标识 对应的身份，这种机制就被称为 sessionsession 机制大部分使用 cookie 作为载体运送这个 唯一标识 ，也可以采用url 连接、 自定义请求头来实现。小程序登录态对于小程序来说，也需要一个唯一的标识符来区分用户，也就是session来保持会话，但是小程序没有cookie, 因此我们的唯一标识符会被存储在 localstorage 里面，每次发请求时，都会从 localStorage 里面拿到这个唯一标识符，带在请求中。微信的 openid 和 code在日常开发中，我们也经常听到 openid 和 code 的概念。openid 用来标识这个唯一的微信用户，也就是说，一个微信用户相对于一个公众号（主体）的 openid 是唯一的，是不会变的。那么我们如何才能知道 某一个用户的 openid 呢？就是通过 code , 对于同一个用户，每次获取到的 code 都会改变，有有效期。我们把 code 作为参数，调用指定的微信服务器的接口，就可以拿到用户的 openid 。那么我们如何才能拿到 code 呢？微信内h5页面的方法是：跳到指定的微信的承接页面，再跳回到本页面，url链接上就会被拼上 code 。小程序的方法是： 通过调用 wx.login() 方法，就可以拿到用户的 code知道了上面的前提条件，就可以去实现一个微信小程序的登录体系。微信小程序登录体系通过 wx.login() 获取到用户的 code通过 wx.request() 方法请求我们自己的后端，我们自己的服务端把 appid , appsecret 和 code 一起发送到微信服务器。 appid 和 appsecret 都是微信提供的，可以在管理员后台找到微信服务器返回了 openid我们在自己的数据库中，查找 openid ，如果没有查到记录，说明该用户没有注册，如果有记录，则继续往下走我们生成一个第三方session, 也就是session_id, 也就是用户唯一标识符。在redis中，把session_id 和用户的身份存进去。返回 3rd_session小程序把 3rd_session 存到 storage 里面下次请求时，先从 storage 里面读取，然后带给服务端服务端从redis 里面找到 3rd_session 对应的记录，然后校验有效期问题一：为什么我们要自己维护一个用户数据库，实现一个注册体系？用微信的不好吗？因为我们业务不光是在微信里面玩，比如说，在app的场景下，我们肯定没有办法通过微信这一套来登录。问题二：为什么仍需设置前端的登录态，而不是每次用小程序的code换open_id？因为用code换open_id的方式，需要等待wx.login() 获取code, 需要等待node端请求微信服务器用code换取open_id。 相比于直接直接带上登录态，用户等待时间更长。获取用户信息最新版小程序中，只需要一个按钮就可以获取到用户的信息获取头像昵称 \r\n复制代码微信规定需要指定该btn的 open-type 为 getUserInfo , 用户信息会放在 getUserInfo 的回调函数里面。如果用户之前没有授权过，则会弹出弹窗授权。如果用户已经授权过，则不需要弹出弹窗授权。通过 wx.getSetting 方法可以获取到用户的授权信息wx.getSetting({\r\n            success(res) {\r\n                if (!res || !res.authSetting) {\r\n                    wx.showToast({\r\n                        title: '查询授权失败',\r\n                    })\r\n                    return;\r\n                }\r\n                this.setData({\r\n                    authInfo: res.authSetting\r\n                })\r\n            }\r\n        })\r\n复制代码"}
{"title": "以小程序为例，学习如何将异步回调接口 Promise 化 ", "author": "Rolan", "pub_time": "2019-1-23 00:42", "content": "前言\r\nES6 标准的 Promise 解决了 Javascript 代码中比较常见的回调地狱问题，搭配 async/await 可以用同步的方式写异步逻辑，大大提高了开发效率。\r\n但是至今仍有很多库没有实现 Promise 化的接口，其中就包括微信小程序的 api。\r\n为了不向恶势力妥协，写出风格统一的代码，我们有必要了解何为 Promise。\r\n本文假定读者有一定 JavaScript 基础，同时了解 Promise 的基本用法。\r\n回调接口\r\n异步回调接口指的是通过传递函数来处理异步方法调用，一般有两种方式。\r\n\r\n\r\n小程序方式\r\n分别传递成功和失败的回调以处理两种不同情况\r\nwx.showToast({\r\n  title: 'Hello, world',\r\n  success: () => console.log('success'),\r\n  fail: () => console.log('failure'),\r\n})\r\n复制代码\r\n\r\nMongoDB 方式\r\n传递一个以 error 为首参数的回调用以鉴别是否调用成功\r\ndb.find({ name: 'Idan Loo' }, (err, data) => {\r\n  if (err) {\r\n    // err 是调用失败的原因\r\n    console.log(err)\r\n    return\r\n  }\r\n  // data 就是异步传递回来的参数\r\n  console.log(data)\r\n})\r\n复制代码\r\n\r\n两种方式各有千秋，这里仅讨论微信方式，MongoDB 方式的接口 Promise 化相信各位可以举一反三。\r\nPromise 化\r\n简单实现\r\n以 showToast 为例\r\nconst showToast = option =>\r\n  new Promise((resolve, reject) => \r\n    wx.showToast({...option,\r\n      success: resolve,\r\n      fail: reject,\r\n    })\r\n  )\r\n\r\nshowToast({ title: 'Hello, Promise' })\r\n  .then(() => console.log('success'))\r\n  .catch(() => console.log('failure')) \r\n复制代码你已经知道了如何 Promise 化小程序的接口，现在你只需要重复上面的代码，将所有你需要用到的接口改为 Promise 的即可。\r\n高级一点的实现\r\n复制粘贴一把梭虽然快，但是作为一名程序员，自然应该追求更简洁的实现。\r\n通过观察，小程序所有的异步接口都采用了相同的形式，并且都位于 wx 对象中，故我们可以抽象出通用的 promisify 方法用以 Promise 化小程序的接口\r\nconst promisify = name => option => \r\n  new Promise((resolve, reject) =>\r\n    wx[name]({...option,\r\n      success: resolve,\r\n      fail: reject,\r\n    })\r\n  )\r\n\r\nconst showToast = promisify('showToast')\r\nconst request = promisify('request')\r\n复制代码现在只需一行代码，就可以 Promise 化小程序的接口，赶紧把之前写的丑陋的回调代码改过来吧！\r\n更高级的实现\r\n如果你跟我一样，代码洁癖到上述代码都接受不了的话，那恭喜你，通过 Proxy 可以更好的实现我们的目标。\r\nconst pro = new Proxy(wx, {\r\n  get(target, prop) {\r\n    return promisify(prop)\r\n  }\r\n})\r\n\r\npro.showToast({ title: 'Hello, world' }).then(...)\r\npro.request({ url: 'https://github.com' }).then(...)\r\n复制代码在 promisify 方法的基础上，给 wx 对象加了个代理，现在你可以像使用 wx 对象一样使用 pro，并且所有的异步方法都变成了 Promise 形式的！\r\n无需实现\r\n最好的实现就是交给别人实现，正好我已经把前文中的代码打包上传, minapp-promise，不足 1k，开箱即用。\r\n能看到这里着实不易，希望你们能给我点个赞，顺便在 GitHub 给我个星星就更好了。\r\n手机码字，如有错漏，万望斧正。"}
{"title": "小程序使用 Iconfont 的正确姿势 ", "author": "Rolan", "pub_time": "2019-1-24 00:12", "content": "现如今移动设备分辨率不胜枚举，传统的标量图标要分别导出 1 倍图、2 倍图、3 倍图等以适应高分辩率设备。这无疑大大增加了设计师和客户端开发的工作量。矢量图以其无损缩放的优点，在图标方面有着极大的优势。Iconfont 是由阿里推出，功能强大且图标内容很丰富的矢量图标库，提供矢量图标下载、在线存储、格式转换等功能，几乎国内成了矢量图标库的事实标准。每个 Iconfont 项目都可以生成一个远程 .css 文件，下文以 //at.alicdn.com/t/font_883452_bqb4vsc7km8.css 为例。你可以查阅教程了解如何生成 .css 文件。正常 Iconfont 的使用流程是在 HTML 的 head 标签中引入样式文件，然后通过类名调用图标<html>\r\n    <head>\r\n        <link href=\"//at.alicdn.com/t/font_883452_bqb4vsc7km8.css\" />\r\n    </head>\r\n    <body>\r\n        <!-- 这是一个名为 plus 的 icon -->\r\n        <i class=\"iconfont icon-plus\"></i>\r\n    </body>\r\n</html>\r\n复制代码不幸的是小程序不支持引入外部 css 文件，为此我寻遍网络，竟没有找到 Iconfont 在小程序中的正确用法。本文根据我在实践经验所得，是我目前能找到在小程序中使用 Iconfont 最简的方法。引入虽然小程序不支持引入外部样式表，但 .wxss 文件本质上就是 .css 文件，因此我们可以将 Iconfont 的样式表保存到本地的 .wxss 中。下载 at.alicdn.com/t/font_883452_bqb4vsc7km8.css 至 /iconfont.wxss ，并在 app.wxss中引入@import \"/iconfont.wxss\";\r\n复制代码在 .wxml 文件中使用<text class=\"iconfont icon-plus\"></text>\r\n复制代码现在应该可以在开发者工具中看到你想要的图标了。解决了基本的使用问题之后，我们发现，由于小程序组件内部有独立的类作用域，因此在 app.wxss 中引入的 .iconfont 和 .icon-plus 并不能在自定义组件内生效，所以你需要在所有需要用到 Iconfont 的组件内，分别引入 iconfont.wxss 。组件化如果你看过我之前的文章，应该知道我对冗余代码深恶痛绝。自定义组件就是解决重复引入的手段。"}
{"title": "微信小程序-flex布局中align-items和align-self区别 ", "author": "Rolan", "pub_time": "2019-1-24 00:24", "content": "首先看看菜鸟教程中关于align-items和align-self的定义align-items：align-items 属性定义flex子项在flex容器的当前行的侧轴（纵轴）方向上的对齐方式。（对齐弹性盒的各项元素）align-self：align-self 属性定义flex子项单独在侧轴（纵轴）方向上的对齐方式。（对齐弹性对象元素内的某个项）从定义上可以看出是对齐”目标“上存在差异，这样看上去似乎不太便于理解/*index.wxml*/\r\n<view class=\"container\">\r\n\r\n  <view class=\"item\" style='order:/4'>\r\n      1\r\n  </view>\r\n\r\n\r\n  <view class=\"item\">\r\n      2\r\n  </view>\r\n  \r\n  <view class=\"item  i3\">\r\n      3\r\n  </view>\r\n \r\n  <view class=\"item\">\r\n       4\r\n  </view>\r\n\r\n  \r\n\r\n\r\n</view>/*index.wxss*/\r\n.container{\r\n  height: 100px;\r\n  width: 100%;\r\n  background-color: green;\r\n  display: flex;\r\n  /* flex-direction: column; */\r\n  flex-direction: row;\r\n  flex-flow: wrap;\r\n\r\n  justify-content:space-between;  \r\n  align-items: flex-start;\r\n}\r\n.item{\r\n  width: 100rpx;\r\n  height: 100rpx;\r\n  background-color: yellow;\r\n  border: 1px solid white;\r\n\r\n\r\norder: 3;\r\n}\r\n.i3{\r\n  display: flex;\r\n  align-items: flex-end;\r\n  /* flex-grow: 1; */\r\n  order: 1;\r\n}这里用align-items显示的结果如图，可以看到此时文字是在下方，而色块并没到下方如果将代码align-items换为align-self，整个块都以从下往上的方式排列了，而数字的位置仍然是在左上角"}
{"title": "微信小程序复选框实现 多选一功能 ", "author": "Rolan", "pub_time": "2019-1-24 00:32", "content": "功能实现界面data: {\r\n    checkboxItems: [\r\n      { name: '全天(1-8节)', value: 'allday' },\r\n      { name: '上午(1-4节)', value: 'am' },\r\n      { name: '下午(5-8节)', value: 'pm' },\r\n      { name: '晚上(晚自习)', value: 'night' },\r\n    ]\r\n  }  想要实现的功能 四个复选框中只能选一个，且选中另一个会取消其余选中,且能保存选择的value值JS代码实现checkboxChange: function (e) {\r\n    var that = this;\r\n    let checkboxValues=null;\r\n    let checkboxItems = this.data.checkboxItems, values = e.detail.value\r\n    for (var i = 0, lenI = checkboxItems.length; i < lenI; ++i) {\r\n      if(checkboxItems[i].value==values[values.length-1]){\r\n        checkboxItems[i].checked=true;\r\n        checkboxValues = checkboxItems[i].value;\r\n      }\r\n      else{\r\n        checkboxItems[i].checked = false;\r\n      }\r\n    }\r\n    console.log(checkboxValues)\r\n    that.setData({ checkboxItems, checkboxValues })\r\n  }  前端代码 <view class=\"weui-cells weui-cells_after-title\">\r\n      <checkbox-group class=\"weui-flex\" bindchange=\"checkboxChange\">\r\n        <label class=\"weui-cell weui-check__label weui-flex__item\" wx:for=\"{{checkboxItems}}\" wx:key=\"value\">\r\n          <checkbox class=\"weui-check\" value=\"{{item.value}}\" checked=\"{{item.checked}}\" />\r\n          <view class=\"weui-cell__hd weui-check__hd_in-checkbox\">\r\n            <icon class=\"weui-icon-checkbox_circle\" type=\"circle\" size=\"23\" wx:if=\"{{!item.checked}}\"></icon>\r\n            <icon class=\"weui-icon-checkbox_success\" type=\"success\" size=\"23\" wx:if=\"{{item.checked}}\"></icon>\r\n          </view>\r\n          <view class=\"weui-cell__bd\">{{item.name}}</view>\r\n        </label>\r\n      </checkbox-group>\r\n    </view>对应的CSS样式是WeUI"}
{"title": "微信小程序-锚点定位 ", "author": "Rolan", "pub_time": "2019-1-25 00:32", "content": "引言：在商品详情页面，一般会有商品图显示、商品主要信息、评价、商品详情等，这时候最好是在最上面加上导航，点击导航定位到对应的页面位置，比如京东的商品详情页面对于一般的PC端网页，只需要使用 <a href=\"#element_Id\"> ，然后在地址栏最后加上#element_Id，就能很方便的跳转到该元素的位置。那么，微信小程序该怎样解决呢？解决思路查找微信小程序的开发文档，发现可以使用scroll-view组件中的属性scroll-into-view实现重点将page的高度设置为100%；导航下面的内容部分必须用 <scroll-view> 包起来设置scroll-view的高度=屏幕的高度-导航的高度设置scroll-view的属性 scroll-into-view=\"{{toView}}\"设置scroll-view的属性 scroll-y=\"true\"设置锚点 <view id=\"position1\">注意：第4、5步不能换位置，一定是scroll-into-view在scroll-y的前面上代码WXNL<view class=\"navigateBox\">\r\n    <view @tap=\"toViewClick\" data-hash=\"productBox\" class=\"title {{toView=='productBox' ? 'checked':''}}\">\r\n      <image wx:if=\"{{toView=='productBox'}}\" src=\"../images/position.jpg\"/>商品</view>\r\n    <view @tap=\"toViewClick\" data-hash=\"commentBox\" class=\"title {{toView=='commentBox' ? 'checked':''}}\">\r\n      <image wx:if=\"{{toView=='commentBox'}}\" src=\"../images/position.jpg\"/>评价</view>\r\n    <view @tap=\"toViewClick\" data-hash=\"infoBox\" class=\"title {{toView=='infoBox' ? 'checked':''}}\">\r\n      <image wx:if=\"{{toView=='infoBox'}}\" src=\"../images/position.jpg\"/>详情</view>\r\n</view>\r\n\r\n<scroll-view style=\"height:{{winHeight}}\" scroll-into-view=\"{{toView}}\" scroll-y=\"true\">\r\n    <view id=\"productBox\">商品图</view>\r\n    <view id=\"commentBox\">商品评价</view>\r\n    <view id=\"infoBox\">商品详情</view>\r\n</scroll-view>\r\n复制代码JSdata = {\r\n    winHeight: '100%',\r\n    toView: 'productBox',//锚点跳转的ID\r\n}\r\nonLoad(){\r\n    let that = this;\r\n    wx.getSystemInfo({\r\n      success: function (res) {\r\n        //屏幕的宽度/屏幕的高度 = 微信固定宽度(750)/微信高度\r\n        that.winHeight = res.windowHeight-(res.windowWidth*90/750)+'px';//90为导航的告诉80+10(margin-bottom)\r\n      }\r\n    });\r\n}\r\nmethods = {\r\n    toViewClick: function (e) {\r\n      this.toView = e.target.dataset.hash;\r\n    }\r\n}\r\n复制代码WXSS<style lang=\"less\">\r\n\r\n  page{\r\n    height: 100%;\r\n  }\r\n\r\n  .navigateBox{\r\n    background: #fff;\r\n    height: 80rpx;\r\n    padding: 0 100rpx;\r\n    margin-bottom: 10rpx;\r\n\r\n    .title{\r\n      margin: 20rpx 46rpx;\r\n      float: left;\r\n      font-size: 27rpx;\r\n      width: 60rpx;\r\n      padding-left: 30rpx;\r\n    }\r\n\r\n    image{\r\n      width: 30rpx;\r\n      height: 30rpx;\r\n      margin-left: -30rpx;\r\n    }\r\n\r\n    .checked{\r\n      color: #f73c3c;\r\n    }\r\n  }\r\n复制代码"}
{"title": "小程序从手动埋点到自动埋点 ", "author": "Rolan", "pub_time": "2019-1-25 00:52", "content": "前言\r\n小程序由于封闭性较强，要像web应用一样实现灵活的数据收集，会有一定难度。目前开源的埋点SDK，一般采用手动埋点的方式，这种方式有较强的侵入型，为了解决这个问题就有了该文章。\r\n手动埋点\r\n以腾讯移动分析的SDK为例，如果要记录埋点信息，只要插入一句代码即可\r\n// 例如，记录搜索行为\r\nsearch(keyword) {\r\n   if (keyword) {\r\n       ...业务代码\r\n   }\r\n   mta.Event.stat(\"ico_search\", {\"query\":keyword});\r\n}\r\n复制代码示例代码看起来是比较简洁的，但是埋点需要收集的数据往往不是单一的，复杂的埋点代码插入业务代码，会影响代码的阅读体验，而且埋点代码散落在各个地方，不方便管理。\r\n由于手动埋点必须插入到函数中，有时候我们为了获取页面某一元素点击信息，产生了一种叫无业务相关埋点，简单来说就是你的函数定义，就只有埋点代码，当这种埋点频繁出现，代码会被严重污染。\r\n// wxml\r\n<view bindtap=\"track\">这只是一个展示view</view>\r\n\r\n//js \r\ntrack() {\r\n  mta.Event.stat(\"eleClick\", {\"name\":xxxxx});\r\n}\r\n复制代码另外，由于PM会频繁调整埋点信息，而埋点是一个繁琐又无聊的工作，基于Don't Repeat Yourself 原则，手动埋带要不得。\r\n总结以上，手动埋点有下列问题\r\n\r\n影响代码的阅读体验\r\n埋点代码散落在各个地方，不方便管理\r\n代码会被污染\r\n埋点是一个繁琐又无聊的工作\r\n\r\n自动埋点\r\n实现思路：监听用户点击-->读取埋点配置JOSN，判断是否需要上报--> 上报数据\r\n1、小程序监听用户点击行为\r\nweb应用监听用户点击行为是比较容易，但是小程序没有提供Dom的事件监听，不过我们可以通过事件冒泡的方式捕获。\r\n// web监听页面点击\r\ndocument.addEventListener('click',(e) => {console.log(e)})\r\n\r\n// 小程序监听页面点击，用户的点击行为都会执行elementTracker方法\r\n<view catchtap='elementTracker'>\r\n  <view class='buy-now'>\r\n     <button bindtap='buy' animation=\"{{scaleAnim}}\">立即购票</button>\r\n  </view>\r\n</view>\r\n复制代码2、判断点击位置是否落在监听元素中\r\n假设需要监听用户是否点击class为buy-now元素，可以通过获取buy-now元素长宽，定位和点击位置坐标判断是否出现重叠，以判断是否被点击。\r\n/**\r\n * 判断点击是否落在目标元素\r\n * @param {Object} clickInfo 用户点击坐标\r\n * @param {Object} boundingClientRect 目标元素信息\r\n * @param {Object} scrollOffset 页面位置信息\r\n * @returns {Boolean}\r\n */\r\nexport const isClickTrackArea = function (clickInfo, boundingClientRect, scrollOffset) {\r\n    if (!boundingClientRect) return false;\r\n    const { x, y } = clickInfo.detail; // 点击的x y坐标\r\n    const { left, right, top, height } = boundingClientRect;\r\n    const { scrollTop } = scrollOffset;\r\n    if (left < x && x < right && scrollTop + top < y && y < scrollTop + top + height) {\r\n        return true;\r\n    }\r\n    return false;\r\n};\r\n复制代码3、通过配置表声明埋点\r\n为了解决代码入侵问题，可以将所有埋点信息统一管理，通过配置表的方式，除了方便管理，以后还可以做到动态配置，在服务端配置完毕下发到客户端。\r\nconst tracks = {\r\n  path: 'pages/film/detail',\r\n  elementTracks: [\r\n    {\r\n      element: '.buy-now',  // 声明需要监听的元素\r\n      dataKeys: ['film.filmId'], // 声明需要获取Data下的哪些数据\r\n    },\r\n  ]\r\n};\r\n复制代码4、对页面函数埋点\r\n有些场景我们除了对页面元素点击埋点，还要对页面函数进行埋点，例如用户下拉刷新的时候，可以对原方法进行包装，插入埋点代码。\r\n rewritePage() {\r\n    const originPage = Page;\r\n    Page = (page) => {\r\n      Object.keys(page).forEach((methodName) => {\r\n       // 执行埋点逻辑\r\n        typeof page[methodName] === 'function' && this.recordPageFn(page, methodName);\r\n      });\r\n      // 执行原Page对象\r\n      return originPage(page);\r\n    };\r\n  }\r\n复制代码最后\r\n完整的代码已经封装成SDK了，可以快速集成到项目\r\ngithub.com/zhengguoron…"}
{"title": "分享一款拥有历史搜索记录的微信小程序搜索框--wx-search-have-history ... ", "author": "Rolan", "pub_time": "2019-1-28 00:12", "content": "wx-search-have-history一款拥有历史搜索记录的微信小程序搜索框wx-search-have-history使用前提：使用此组件需要依赖小程序基础库 2.2.1 或以上、及开发者工具 1.02.1808300 或以上，同时依赖开发者工具的 npm 构建。具体详情可查阅微信小程序 npm 支持文档。使用效果1、 通过输入进行搜索2、清除单个（全部）历史搜索记录3、点击历史搜索记录进行搜索PS：若想要获得上图中的效果，可参考 test/demo 中的例子实现。使用方法1、 安装 wx-search-have-historynpm install --save wx-search-have-history2、 在需要使用 wx-search-have-history 的页面 page.json 中添加 wx-search-have-history 自定义组件配置{\r\n  \"usingComponents\": {\r\n    \"searchHaveHistory\": \"wx-search-have-history\"\r\n  }\r\n}3、 WXML 文件中引用 wx-search-have-history：调用history组件的同时，需要在调用wx-search-have-history的页面page.js绑定事件接收搜索值（bind:searchEvent=\"searchEvent\"），且须在searchEvent函数里调用wx.hideLoding()，可参考 test/demo/pages/index/index.js 中的例子。<searchHaveHistory id=\"history\"\r\n    bind:searchEvent=\"searchEvent\">\r\n</searchHaveHistory>wx-search-have-history的属性介绍如下：在调用组件的时候，id必须填写且唯一。因为此id作为本地缓存的key值。注意事项在调用wx-search-have-history的页面page.js需绑定事件接收搜索值（bind:searchEvent=\"searchEvent\"），且须在searchEvent函数里调用wx.hideLoding(),可参考 test/demo/pages/index/index.js 中的例子。项目地址：github传送门这是我第一次尝试，如有不当或需改进之处，请君指出，感谢万分！！！"}
{"title": "小程序第三方框架对比 ( wepy / mpvue / taro ) ", "author": "Rolan", "pub_time": "2019-1-28 00:23", "content": "众所周知如今市面上端的形态多种多样，手机Web、ReactNative、微信小程序, 支付宝小程序, 快应用等,每一端都是巨大的流量入口，当业务要求同时在不同的端都要求有所表现的时候，针对不同的端去编写多套代码的成本显然非常高，这时候只编写一套代码就能够适配到多端的能力就显得极为需要。但面对目前市面上成熟的小程序第三方框架如何针对自己的需求进行选择也是一个麻烦事,本文针对当前市面上的三大转译框架进行一个综合对比,希望能对大家的技术选择有所帮助,如有哪里不妥的地方希望指正;在这里我通过对目前已开源的三种常用小程序框架做一个综合对比, 还有一个叫nanchi的基于react的小程序转译框架,由于没来的及研究暂不做比较;WEPY tencent.github.io/wepy/docume…腾讯团队开源的一款类vue语法规范的小程序框架,借鉴了Vue的语法风格和功能特性,支持了Vue的诸多特征，比如父子组件、组件之间的通信、computed属性计算、wathcer监听器、props传值、slot槽分发，还有很多高级的特征支持：Mixin混合、拦截器等;WePY发布的第一个版本是2016年12月份，也就是小程序刚刚推出的时候，到目前为止，WePY已经发布了52个版本, 最新版本为1.7.2;MpVue mpvue.com/mpvue/#-htm…美团团队开源的一款使用 Vue.js 开发微信小程序的前端框架。使用此框架，开发者将得到完整的 Vue.js 开发体验，同时为 H5 和小程序提供了代码复用的能力。mpvue在发布后的几天间获得2.7k的star,上升速度飞起,截至目前为止已经有13.7k的star;Tarotaro.aotu.io/京东凹凸实验室开源的一款使用 React.js 开发微信小程序的前端框架。它采用与 React 一致的组件化思想，组件生命周期与 React 保持一致，同时支持使用 JSX 语法，让代码具有更丰富的表现力，使用 Taro 进行开发可以获得和 React 一致的开发体验。,同时因为使用了react的原因所以除了能编译h5, 小程序外还可以编译为ReactNative;生命周期同为vue规范的mpvue和wepy的生命周期和各种方法不尽相同wepywepy生命周期基本与原生小程序相同,再此基础上糅合了一些vue的特性; 对于WePY中的methods属性，因为与Vue中的使用习惯不一致，非常容易造成误解，这里需要特别强调一下：WePY中的methods属性只能声明页面wxml标签的bind、catch事件，不能声明自定义方法，这与Vue中的用法是不一致的。 `import wepy from 'wepy';export default class MyPage extends wepy.page { // export default class MyComponent extends wepy.component { customData = {} // 自定义数据customFunction () {}  //自定义方法\r\n\r\nonLoad () {}  // 在Page和Component共用的生命周期函数\r\n\r\nonShow () {}  // 只在Page中存在的页面生命周期函数\r\n\r\nconfig = {};  // 只在Page实例中存在的配置数据，对应于原生的page.json文件\r\n\r\ndata = {};  // 页面所需数据均需在这里声明，可用于模板数据绑定\r\n\r\ncomponents = {};  // 声明页面中所引用的组件，或声明组件中所引用的子组件\r\n\r\nmixins = [];  // 声明页面所引用的Mixin实例\r\n\r\ncomputed = {};  // 声明计算属性（详见后文介绍）\r\n\r\nwatch = {};  // 声明数据watcher（详见后文介绍）\r\n\r\nmethods = {};  // 声明页面wxml中标签的事件处理函数。注意，此处只用于声明页面wxml中标签的bind、catch事件，自定义方法需以自定义方法的方式声明\r\n\r\nevents = {};  // 声明组件之间的事件处理函数\r\n复制代码}`mpvuempvue 除了 Vue 本身的生命周期外，还兼容了小程序生命周期，这部分生命周期钩子的来源于微信小程序的 Page， 除特殊情况外，不建议使用小程序的生命周期 钩子。简单示例taro与react生命周期完全相同列表渲染在列表渲染上三者也分别有不同的应用方法wepy当需要循环渲染WePY组件时(类似于通过wx:for循环渲染原生的wxml标签)，必须使用WePY定义的辅助标签mpvue使用v-for与vue一致,只是需要注意一点，嵌套列表渲染，必须指定不同的索引！taro的列表循环用法基本与react相同,有一点需要注意,在 React 中，JSX 是会编译成普通的 JS 的执行，每一个 JSX 元素，其实会通过 createElement 函数创建成一个 JavaScript 对象（React Element），因此实际上你可以这样写代码 React 也是完全能渲染的：但是 Taro 中，JSX 会编译成微信小程序模板字符串，因此你不能把 map 函数生成的模板当做一个数组来处理。当你需要这么做时，应该先处理需要循环的数组，再用处理好的数组来调用 map 函数。例如上例应该写成：事件处理mpvue目前全支持小程序的事件处理器,引入了 Vue.js 的虚拟 DOM ，在前文模版中绑定的事件会被挂在到 vnode 上，同时 compiler 在 wxml 上绑定了小程序的事件，并做了相应的映射，所以你在真实点击的时候通过 runtime 中 handleProxy 通过事件类型分发到 vnode 的事件上，同 Vue 在 WEB 的机制一样，所以可以做到无损支持。同时还顺便支持了自定义事件和 $emit 机制事件映射表，左侧为 WEB 事件，右侧为 小程序 对应事件**click** : 'tap',<br>\r\n**touchstart**: 'touchstart',<br>\r\n**touchmove**: 'touchmove',<br>\r\n**touchcancel**: 'touchcancel',<br>\r\n**touchend**: 'touchend',<br>\r\n**tap**: 'tap',<br>\r\n**longtap**: 'longtap',<br>\r\n**input**: 'input',<br>\r\n**change**: 'change',<br>\r\n**submit**: 'submit',<br>\r\n**blur**: 'blur',<br>\r\n**focus**: 'focus',<br>\r\n**reset**: 'reset',<br>\r\n**confirm**: 'confirm',<br>\r\n**columnchange**: 'columnchange',<br>\r\n**linechange**: 'linechange',<br>\r\n**error**: 'error',<br>\r\n**scrolltoupper**: 'scrolltoupper',<br>\r\n**scrolltolower**: 'scrolltolower',<br>\r\n**scroll**: 'scroll'<br>\r\n复制代码踩坑注意(官方文档)：列表中没有的原生事件也可以使用例如 bindregionchange 事件直接在 dom 上将bind改为@ @regionchange,同时这个事件也非常特殊，它的 event type 有 begin 和 end 两个，导致我们无法在handleProxy 中区分到底是什么事件，所以你在监听此类事件的时候同时监听事件名和事件类型既 <map @regionchange=\"functionName\" @end=\"functionName\" @begin=\"functionName\">小程序能力所致，bind 和 catch 事件同时绑定时候，只会触发 bind ,catch 不会被触发，要避免踩坑。事件修饰符 .stop 的使用会阻止冒泡，但是同时绑定了一个非冒泡事件，会导致该元素上的 catchEventName 失效！ .prevent 可以直接干掉，因为小程序里没有什么默认事件，比如submit并不会跳转页面 .capture 支持 1.0.9 .self 没有可以判断的标识 .once 也不能做，因为小程序没有 removeEventListener, 虽然可以直接在 handleProxy 中处理，但非常的不优雅，违背了原意，暂不考虑其他 键值修饰符 等在小程序中压根没键盘，所以。。。wepy事件绑定区别于vue,根据原生小程序事件提供了语法优化绑定事件bindtap=\"click\" 替换为 @tap=\"click\"，取消冒泡原catchtap=\"click\"替换为@tap.stop=\"click\"。捕获监听事件capture-bind:tap=\"click\" 替换为 @tap.capture=\"click\"，中断捕获监听capture-catch:tap=“click\"替换为 @tap.capture.stop=\"click\"。Taro 元素的事件处理和 DOM 元素的很相似。但是有一点语法上的不同:Taro 事件绑定属性的命名采用驼峰式写法，而不是小写。 如果采用 JSX 的语法你需要传入一个函数作为事件处理函数，而不是一个字符串 (DOM 元素的写法)。 例如，传统的微信小程序模板：Taro 中稍稍有点不同：在 Taro 中另一个不同是你不能使用 catchEvent 的方式阻止事件冒泡。你必须明确的使用 stopPropagation。例如，阻止事件冒泡你可以这样写：request请求wepy对wx.request做了接受参数的修改,值得一提的是它提供了针对全局的intercapter拦截器拦截器taro对request进行了二次封装,可以使用Taro.request(OBJECT)发起网络请求，支持 Promise 化使用。mpvue没有对request做特殊优化,与原生相同,可以自己根据需要进行封装"}
{"title": "小程序点睛之三：才不是你想的那种组件 ", "author": "Rolan", "pub_time": "2019-1-28 00:37", "content": "小程序点睛系列写到第三篇，我才在昨夜临睡前想到这个名字。官方文档讲过的东西我不重复，我只在你会写的基础上，帮你画上点睛一笔。这一篇，是我与小程序鏖战半年苦心孤诣的成果，满满干货。自定义组件从基础库 1.6.3 开始支持，用来抽象功能组件，以便在多个页面复用。如果你有 React 或 Vue等前端类库的开发经验，对自定义组件一定不会陌生。小程序吸收了 Vue 的模板语法， React 的状态管理方式，再加上 Web Component 的 Shadow DOM 残缺版本，总之就是一边抄一点，形成了独具特色的小程序风格组件。这使得你之前在其它类库上获得的经验不能完全适用。接下来，我们就一起聊聊小程序组件的奇技淫巧。JavaScript 部分小程序将组件数据分为父组件传递来的 properties 和自身持有的 data ，这点与主流前端框架类似，我们重点关注 properties 。组件的 property 接收 type 、 value 、 observer 三个参数type: 属性类型，目前支持 String , Number , Boolean , Object , Array , null从 .wxml 传递过来的值到 .js 之前会先经过类型转换。如果想传递混合类型值（如既可能是String 也可能是 Number 的值），可以将 type 设置为 null ，可以避免默认的类型转换。value: 默认值如果不设置 value 的值，那该 property 的默认值就是其类型的零值。对应如下：String => ''\r\nNumber => 0\r\nBoolean => false\r\nObject => {}\r\nArray => []\r\nnull => null\r\n复制代码observer: 属性被改变后执行的函数由于小程序自身不支持 watch ，故而无法监听 data 中某一项的改变。但与 React 不同的是，组件的 properties 在组件运行时会被整合入 data 中，通过 this.data 获取，并且可以调用 this.setData 改动 properties 的值。 因此可以将需要监听的 data 放于 properties 中，利用 observer 监听。同时，为表示其为内部状态，建议以下划线（_）开头，且不再外部设置其值。observer 还可以用来减少 .wxml 模板的重复代码。例如父组件传递了一个 source 对象，要求组件显示其姓名与年龄// component.js\r\nComponent({\r\n    properties: {\r\n        source: Object,\r\n    }\r\n})\r\n复制代码<!-- component.wxml -->\r\n<view>{{ source.name }}</view>\r\n<view>{{ source.age }}</view>\r\n复制代码利用 observer 可以写成// component.js\r\nComponent({\r\n    properties: {\r\n        source: {\r\n            type: Object,\r\n            observer(val) {\r\n                this.setData(val)\r\n            }\r\n        }\r\n    }\r\n})\r\n复制代码<!-- component.wxml -->\r\n<view>{{ name }}</view>\r\n<view>{{ age }}</view>\r\n复制代码这对体量较大的组件犹为有效。同时，将 source 封装为 behavior ，可以最大限度的减少冗余代码// sourceBehavior.js\r\nexport default Behavior({\r\n\tproperties: {\r\n        source: {\r\n            type: Object,\r\n            observer(val) {\r\n                this.setData(val)\r\n            }\r\n    }\r\n  }\r\n})\r\n\r\n// component.js\r\nimport sourceBehavior from 'path/to/sourceBehavior.js'\r\n\r\nComponent({\r\n    behaviors: [sourceBehavior]\r\n})\r\n复制代码WXML 部分.wxml 模块与 Vue 模板大同小异，唯一值得了解的是由于小程序不完全实现了 Shadow DOM ，Vue 中 <template> 标签只能有一个根节点的限制是不存在的。因此在大多数情况下，你都不需要给 .wxml 额外添加根节点。<!-- good.wxml -->\r\n<view>{{ name }}</view>\r\n<view>{{ age }}</view>\r\n\r\n<!-- bad.wxml -->\r\n<view>\r\n\t<view>{{ name }}</view>\r\n    <view>{{ age }}</view>\r\n</view>\r\n复制代码WXSS 部分inherit 关键字我们可以通过将属性值设置为 inherit 来有效减少代码冗余。如果你想保持节点属性与父节点一致，就应当使用这个关键字。回想一下 小程序点睛之二：小程序使用 Iconfont 的正确姿势 ，默认 Iconfont 下载的 CSS 文件中定义了 .iconfont 类的字体大小为 16px ，如果你不想每次更新改动这一值，那么可以在组件样式表中添加.iconfont {\r\n    font-size: inherit;\r\n}\r\n复制代码组件样式表的优先级要高过外部引入的样式表，所以原本的 font-size: 16px 就会被覆盖， .iconfont 的字体大小就会跟其父节点一致。注意：这里 .iconfont 的父节点并不是逻辑上的父节点，而是 shadow-root 。:host 选择器你可以在开发者工具中看到每个自定义组件的 shadow-root ，其默认是行内元素，你可以在组件样式表中通过 :host 选择器修改它的样式:host {\r\n    display: block;\r\n    background: red;\r\n}\r\n复制代码外部样式表所有的属性都是直接作用在 shadow-root （而非模板中的根节点）上，例如<!-- iconfont.wxml -->\r\n<text class=\"iconfont icon-{{icon}}\"></text>\r\n\r\n<!-- page.wxml -->\r\n<iconfont class=\"icon\" icon=\"upload\"></iconfont>\r\n复制代码/* page.wxss */\r\n.icon {\r\n    color: green;\r\n}\r\n\r\n/* iconfont.wxml */\r\n.iconfont {\r\n    color: red;\r\n}\r\n复制代码你会发现图标的颜色是红色而不是绿色。因为 .icon 是样式作用于 shadow-root ， .iconfont 是其子节点，继承其 color 属性，但由于 .iconfont 优先级更高，所以颜色是为红色。优先级关系为 :host 选择器 < 外部样式 < 子节点样式。利用这个特点，配合 CSS 变量，可以达到意想不到的效果。CSS 变量现阶段支持各浏览器的支持度并不高，版本稍旧的浏览器就会遇到问题。但小程度已经完全支持了这个特性。由于小程序使用了 Shadow DOM ，因此在组件内是无法使用全局定义的样式类的。 但是 ，CSS 是可继承并且是全局可用的。因此，我们可以将常用的样式定义在 app.wxss 内，并在任意页面或组件内使用/* app.wxss */\r\npage {\r\n    --primary-color: #aabbcc;\r\n    --accent-color: #ddeeff;\r\n    --spacing: 32rpx;\r\n}\r\n\r\n/* other.wxss */\r\n.component {\r\n    background: var(--primary-color);\r\n    padding: var(--spacing);\r\n}\r\n复制代码如此，你只需要对 app.wxss 稍作修改，就可以改变整个小程序样式。除此之外，我们还可以利用这个特性，优化组件定义。例如，我们需要一个圆形组件，常规的做法是定义相等的宽高，再设定 border-radius: 50% 。我们来看看高级的写法/* circle.wxss */\r\n:host {\r\n    /* 默认直径为 32rpx */\r\n    --diameter: 32rpx;\r\n    \r\n    width: var(--diameter);\r\n    height: var(--diameter);\r\n    border-radius: 50%;\r\n}\r\n\r\n/* outer.wxss */\r\n.circle {\r\n    /* 将 circle 组件的直径设置为 64rpx */\r\n    --diameter: 64rpx;\r\n}\r\n复制代码还记得我刚刚说的优先级规则吗？外部样式的优先级高于 :host 选择器，因此 circle 组件的直径会被设置为 64rpx 。不只如此，通过自定义属性，我们还可以修改嵌套较深的组件样式<!-- component.wxml -->\r\n<view class=\"this\">\r\n\t<view class=\"is\">\r\n    \t<view class=\"a\">\r\n        \t<view class=\"embed-component\"></view>\r\n        </view>\r\n    </view>\r\n</view>\r\n复制代码/* component.wxss */\r\n:host {\r\n    --embed-color: red;\r\n}\r\n\r\n.embed-component {\r\n    color: var(--embed-color);\r\n}\r\n\r\n/* outer.wxss */\r\n.component {\r\n    --embed-color: blue;\r\n}\r\n复制代码Bingo，借助 CSS 属性，我们获得了改动后代节点样式的能力。你大可以说同样的功能使用 externalClasses 或者 addGlobalClass 也可以做到。但是对于组件来说，外部传入的样式可知，处理起来心智负担更小，更符合 高内聚，低耦合 的标准。同时，建议将可改动的自定义 CSS 变量以注释的形式写在 component.js 中，方便其他人理解你的组件。用 em 而不是 rpx为了保持组件可扩展性，应当尽可能的使用 em 作为字体大小单位。我之前用一个小程序解析markdown 的组件库，其中将所有字体大小都写死为 rpx ，例如/* markdown.wxss */\r\n.h1 {\r\n    font-size: 32rpx;\r\n}\r\n\r\n.h2 {\r\n    font-size: 28rpx;\r\n}\r\n\r\n.h3 {\r\n    font-size: 24rpx;\r\n}\r\n复制代码如此固然能实现需求，但却失去了外部改变字体大小的能力。作为一个组件，应该适应更多的可能性，改为 em 作为字体大小单位就能很好的解决这一问题.h1 {\r\n    font-size: 2em;\r\n}\r\n\r\n.h2 {\r\n    font-size: 1.8em;\r\n}\r\n\r\n.h3 {\r\n    font-size: 1.4em;\r\n}\r\n复制代码数值仅为举例大胆使用新特性小程序对 CSS 3 新特性的支持比较完善， vw ， vh ， flex ， calc ，CSS variables 等等只要你想到，你可以大胆地使用，完全不需要考虑兼容性问题，这简直就是前端梦寐以求的试验田。所以，好好学习，大胆使用吧！后记写了这么多，自己都忘了要写些什么。本来是准备日更的，但是这两天一直在忙社保的事。刚刚从公司离职，办理灵活就业人员耽误了不少时间。感谢各位耐心阅读至此，这都是我工作半年以来的经验之谈，希望可以对你们有一点帮助。如果你也想发布小程序的组件， 官方模板 虽不失为一个选择，但我也要强推一下我写的脚手架工具 tacer ，只需一行 npx tarcer wx-component 就可以开始你的项目了哦！小程序点睛系列还剩下一篇，最后一篇，我们单纯聊 JavaScript ，关注我哟。"}
{"title": "微信小程序---分包加载（SUBPACKAGES）及报错 ", "author": "Rolan", "pub_time": "2019-1-30 00:36", "content": "某些情况下，开发者需要将小程序划分成不同的子包，在构建时打包成不同的分包，用户在使用时按需进行加载。分包很简单，具体步骤如下：在app.json中，创建subPackages，root表示分包A的根目录（eg.跟pages同级目录），pages中的页面就是分包A的子目录。 注意：这里有一点要注意，经常出现这个问题“pages *** 不应该在分包 subPackages[*] 中” 我们如果通过编辑器右键添加page的话，主包中会自动加入page路径，此时我们再去创建新的分包如果没有去掉主包路径就会报错。解决方案就是去掉主包中的路径就可以了 {\r\n  \"pages\": [\r\n    \"pages/success/success\",\r\n    \"pages/fail/fail\"\r\n  ],\r\n  \"window\": {\r\n    \"backgroundTextStyle\": \"light\",\r\n    \"navigationBarBackgroundColor\": \"#f37938\",\r\n    \"navigationBarTitleText\": \"WeChat\",\r\n    \"navigationBarTextStyle\": \"white\"\r\n  },\r\n  \"tabBar\": {\r\n    \"color\": \"#999999\",\r\n    \"selectedColor\": \"#f37938\",\r\n    \"borderStyle\": \"black\",\r\n    \"backgroundColor\": \"#ffffff\",\r\n    \"font-size\": \"50rpx\",\r\n    \"list\": [\r\n      {\r\n        \"pagePath\": \"tabbar/xxx/xxx\",\r\n        \"iconPath\": \"../../images/icon_home.png\",\r\n        \"selectedIconPath\": \"../../images/icon_home2.png\",\r\n        \"text\": \"首页\"\r\n      },\r\n      {\r\n        \"pagePath\": \"tabbar/xxx/xxx\",\r\n        \"iconPath\": \"../../images/icon_mine.png\",\r\n        \"selectedIconPath\": \"../../images/icon_mine2.png\",\r\n        \"text\": \"我的\"\r\n      }\r\n    ]\r\n  },\r\n  \"subPackages\": [\r\n    {\r\n      \"root\": \"A/\",\r\n      \"pages\": [\r\n        \"index/index\",\r\n        \"form/form\"\r\n      ]\r\n    },\r\n    {\r\n      \"root\": \"B/\",\r\n      \"pages\": [\r\n        \"index/index\",\r\n        \"form/form\"\r\n      ]\r\n    }\r\n  ]\r\n}"}
{"title": "微信小程序点击列表添加 去除属性 ", "author": "Rolan", "pub_time": "2019-1-30 00:42", "content": "首先说一下场景：我所循环的数据是对象数组，设置了一个属性当作标记，通过这个标记的值判断是否给改元素添加样式wxml：<view>\r\n      <view wx:for=\"{{list}}\" wx:key=\"num\" class=\"list\" >\r\n        <text bindtap='changColor'  data-index='{{index}}' class='{{item.check?\"text-active\":\"\"}}' >| {{item.message}}</text>\r\n      </view>\r\n</view>js：/*　　这里获取list是一个数组对象　　tomorrow: [　　　　{　　　　　　thing: '吃饭',　　　　　　check: false　　　　},　　　　{　　　　　　thing: '睡觉',　　　　　　check: false　　　　},　　　　{　　　　　　　thing: '打豆豆',　　　　　　check: false　　　　}　　]*/changColor: function (e) {\r\n    let index = e.currentTarget.dataset.index\r\n    let arrs = this.data.list;  \r\n    if (arrs[index].check == false) {\r\n      arrs[index].check = true;\r\n    } else {\r\n      arrs[index].check = false;\r\n    }\r\n    this.setData({\r\n      list: arrs\r\n    })\r\n  },核心在于修改对象属性check的值，然后在元素渲染是根据值进行样式的添加"}
