{"title": "个税计算器 / 微信小程序开发 ", "author": "Rolan", "pub_time": "2019-1-2 00:36", "content": "019年1月1日即将到来，码农们除了关心自己的技能之外，还有薪资是不是可以多拿点。 每次算的时候 都要百度一下个人所得税，但是很多都是老的税率计算，找一个新的出来还是比较麻烦，所以个人开发了一个最新税率的小程序。解决和我有着一样痛苦的码农们的问题。根据最新税改后计算个人所得税的计算器。目前支持南京，后续开放 杭州 上海 北京等城市。 如果有疑问的可以加最下方 开发者微信。首先在微信官网下载微信小程序开发工具 https://mp.weixin.qq.com在https://mp.weixin.qq.com 注册小程序账号，完成个人实名认证。在小程序后台拿到appid，下面就可以开发了。实例查看二维码：先使用weui 小程序ui框架就行页面布局<button block type=\"dark\" bindtap='calculationBindtap'>计算</button>其次写JS代码（计算按钮逻辑代码）import data from './data'\r\n\r\nconst app = getApp;\r\n\r\nPage({\r\n    data: {\r\n        options1: data,\r\n        value: '1',\r\n        checked: true,\r\n        standard: 1,\r\n        marking: 5000,\r\n        beforetaxCount: 0,\r\n        specialitemCount: 0\r\n    },\r\n    \r\n\r\n    calculationBindtap:function(){\r\n        // 开始计算  计算完成把计算结果放在result对象中\r\n        var beforetaxCount = this.data.beforetaxCount;\r\n        var specialitemCount = this.data.specialitemCount;\r\n        var marking = this.data.marking;\r\n        if (beforetaxCount == null || beforetaxCount == 0 || beforetaxCount == ''){\r\n            wx.showToast({\r\n                title: '输入正确薪资',\r\n                mask: true,\r\n                icon: 'loading'\r\n            })\r\n            return;\r\n        }\r\n        if (specialitemCount == null || specialitemCount == ''){\r\n            specialitemCount = 0;\r\n        }\r\n        // 开始计算\r\n\r\n        var oldNum = 0.08;\r\n        var medNum = 0.02;\r\n        var unemNum = 0.005;\r\n        var workNum = 0;\r\n        var giveNum = 0;\r\n\r\n        var providentfundNum = 0.08;\r\n\r\n        var insuranceBase = 19935;\r\n        var providentfundBase = 25300;\r\n\r\n        var oldcount = 0;\r\n        var medcount = 0;\r\n        var unemcount = 0;\r\n        var workcount = 0;\r\n        var givecount = 0;\r\n\r\n        var providentfundcount = 0;\r\n\r\n        var privateFee = 0;\r\n        var plusFee = 0;\r\n\r\n        if(this.data.checked){\r\n            if (parseFloat(beforetaxCount) > parseFloat(insuranceBase)) {\r\n                oldcount = parseFloat(insuranceBase) * parseFloat(oldNum);\r\n                medcount = parseFloat(insuranceBase) * parseFloat(medNum);\r\n                unemcount = parseFloat(insuranceBase) * parseFloat(unemNum);\r\n                workcount = parseFloat(insuranceBase) * parseFloat(workNum);\r\n                givecount = parseFloat(insuranceBase) * parseFloat(giveNum);\r\n            } else {\r\n                oldcount = parseFloat(beforetaxCount) * parseFloat(oldNum);\r\n                medcount = parseFloat(beforetaxCount) * parseFloat(medNum);\r\n                unemcount = parseFloat(beforetaxCount) * parseFloat(unemNum);\r\n                workcount = parseFloat(beforetaxCount) * parseFloat(workNum);\r\n                givecount = parseFloat(beforetaxCount) * parseFloat(giveNum);\r\n            }\r\n\r\n            if (parseFloat(beforetaxCount) > parseFloat(providentfundBase)) {\r\n                providentfundcount = parseFloat(providentfundBase) * parseFloat(providentfundNum);\r\n            } else {\r\n                providentfundcount = parseFloat(beforetaxCount) * parseFloat(providentfundNum);\r\n            }\r\n        }\r\n\r\n        // 保险总费用\r\n        var totalInsuranceFee = parseFloat(oldcount) + parseFloat(medcount) + parseFloat(unemcount) + parseFloat(workcount) + parseFloat(givecount);\r\n        // 公积金费用 \r\n        var totalProvidentfundFee = providentfundcount;\r\n\r\n        // 下面的钱 交税\r\n        console.log(this.data.marking);\r\n        var otherFee = parseFloat(beforetaxCount) - parseFloat(totalInsuranceFee) - parseFloat(totalProvidentfundFee) - parseFloat(this.data.marking) - parseFloat(specialitemCount);\r\n        \r\n        if (parseFloat(otherFee) <= 3000 && parseFloat(otherFee) > 0) {\r\n            privateFee = parseFloat(otherFee) * 0.03;\r\n            plusFee = 0;\r\n        }\r\n        if (parseFloat(otherFee) <= 12000 && parseFloat(otherFee) > 3000) {\r\n            privateFee = parseFloat(otherFee) * 0.1;\r\n            plusFee = 210;\r\n        }\r\n        if (parseFloat(otherFee) <= 25000 && parseFloat(otherFee) > 12000) {\r\n            privateFee = parseFloat(otherFee) * 0.2;\r\n            plusFee = 1410;\r\n        }\r\n        if (parseFloat(otherFee) <= 35000 && parseFloat(otherFee) > 25000) {\r\n            privateFee = parseFloat(otherFee) * 0.25;\r\n            plusFee = 2660;\r\n        }\r\n        if (parseFloat(otherFee) <= 55000 && parseFloat(otherFee) > 35000) {\r\n            privateFee = parseFloat(otherFee) * 0.3;\r\n            plusFee = 4410;\r\n        }\r\n        if (parseFloat(otherFee) <= 80000 && parseFloat(otherFee) > 55000) {\r\n            privateFee = parseFloat(otherFee) * 0.35;\r\n            plusFee = 7160;\r\n        }\r\n        if ( parseFloat(otherFee) > 80000) {\r\n            privateFee = parseFloat(otherFee) * 0.45;\r\n            plusFee = 15160;\r\n        }\r\n\r\n        var result = {};\r\n        \r\n        result.insuranceCount = totalInsuranceFee;\r\n        result.providentfundCount = totalProvidentfundFee;\r\n        result.providentfundNum = parseFloat(providentfundNum) * 100;\r\n        result.money = parseFloat(beforetaxCount) - parseFloat(totalInsuranceFee) - parseFloat(totalProvidentfundFee) - parseFloat(privateFee) + parseFloat(plusFee);\r\n        result.privateFee = privateFee - parseFloat(plusFee);\r\n        result.specialitemCount = specialitemCount;\r\n        result.oldNum = parseFloat(oldNum) * 100;\r\n        result.medNum = parseFloat(medNum) * 100;\r\n        result.unemNum = parseFloat(unemNum) * 100;\r\n        result.workNum = parseFloat(workNum) * 100;\r\n        result.giveNum = parseFloat(giveNum) * 100;\r\n\r\n        result.oldcount = parseFloat(oldcount);\r\n        result.medcount = parseFloat(medcount);\r\n        result.unemcount = parseFloat(unemcount);\r\n        result.workcount = parseFloat(workcount);\r\n        result.givecount = parseFloat(givecount);\r\n\r\n        wx.setStorage({\r\n            key: 'result',\r\n            data: result,\r\n            success:function(){\r\n                wx.navigateTo({\r\n                    url: '../calculation/calculationResult',\r\n                })\r\n            }\r\n        })\r\n        \r\n    },\r\n\r\n})把计算好的结果放在result对象中 通过wx.setStorage 放在缓存中，传到下一个页面。最后展示出来。"}
{"title": "【腾讯游戏人生】微信小程序开发总结 ", "author": "Rolan", "pub_time": "2018-6-27 00:23", "content": "目前【腾讯游戏人生】小程序已经发布上线，大家可以扫小程序码进行体验。接下来主要介绍在开发该款小程序过程中的一些思考和积累。一、基础普及1.1简介微信小程序是微信公众平台推出除服务号、订阅号、企业号外的第四种微信内应用类型，它是一种全新的连接用户与服务的方式，它可以在微信内被便捷地获取和传播，同时具有出色的仿原生app的交互使用体验和实用功能。我们可以方便的在微信公众平台进行小程序的注册和提交资料，与微信公众号的注册流程较为一致。对于公司内部的小程序也可以在公司内部平台进行快速注册和审核，地址为http://mmbiz.oa.com/inneraccount?action=index，在此不具体赘述。1.2配置用户配置：小程序管理平台提供用户管理功能，支持添加1个管理员，根据帐号类型和是否认证分别支持配置不同数目的开发者和体验者帐号权限，这些配置在小程序开发和内测阶段十分有用，即是一个官方的白名单配置功能。开发配置：与微信公众号其他帐号开发接入配置类似，需要分别设置开发者ID和密钥、服务器域名配置、开发消息接入地址等信息，可参考小程序开发文档逐一设置，对于有开发公众号经验的同学来说也比较快速入手，只是需要注意这里的域名接入都必须要是https的服务域名地址。二、开发注意2.1页面模型小程序包含一个描述整体程序的 app 和多个描述各自页面的 page组成，可以看做是一系列页面的组合集成，由一个全局app对象调度运行。页面模型是小程序里的一个很重要的概念，从小程序配置文件app.json中也可以看到(如下所示)，在app.json中注册的页面地址才可以被调用和打开展示。小程序的展示页面主要分为tabbar页和常规页两种，而只有tabbar页才会有底部tabbar显示，两类页面对应的跳转方式api也不同：对于tabbar页地址(例 page/xxx/xxx)，调用wx.switchTab(OBJECT)进行跳转；对于常规页地址(例 page/xxx/x1)，调用wx.navigateTo(OBJECT)或wx.redirectTo(OBJECT)进行跳转{\r\n  \"pages\": [\r\n    \"page/xxx/x1\",\r\n    \"page/yyy/y1\"\r\n  ],\r\n  \"window\": {\r\n    \"navigationBarTitleText\": \"test\"\r\n  },\r\n  \"tabBar\": {\r\n    \"list\": [{\r\n      \"pagePath\": \"page/xxx/xxx\",\r\n      \"iconPath\": \"image/xxx.png\",\r\n      \"text\": \"tab1\"\r\n    }, {\r\n      \"pagePath\": \"page/yyy/yyy\",\r\n      \"iconPath\": \"image/yyy.png\",\r\n      \"text\": \"tab2\"\r\n    }]\r\n  },\r\n  \"networkTimeout\": {\r\n    \"request\": 10000,\r\n    \"uploadFile\": 10000\r\n  },\r\n  \"debug\": true\r\n} 对于一个具体的页面模型，都有其内部独立的逻辑和数据作用域。主要包括四个组成文件，且必须要有相同的路径目录和文件名，例如：首页对应/page/index/目录下的index.js、index.wxml、index.wxss、index.json文件。页面的初始化、渲染、交互等逻辑都可以通过页面js进行事件监听和函数调用进行响应和处理，类似做web前端开发一样，只是需要特别注意该js开发与web前端js开发的部分不同之处：页面逻辑运行在Jscore中，非webview，无window、body、document等dom对象结构；无页面cookie，无法设置网络请求header的refer；不支持类似jquery、zepto等对象拾取插件和操作方式，视图更新通过数据绑定方式实现；页面展示结构主要由官方原生组件拼装展示，并通过对应支持的有限的事件函数进行响应控制，扩展化较低；页面数据的改变通过调用Page.setData函数回显页面组件展示，页面组件的动作事件值；e.detail.value可以传递给事件响应函数重设页面数据，以此达到页面数据和组件的联动绑定2.2生命周期小程序的运行和各页面的展示都有其特定的生命周期，并通过一系列的声明周期函数进行调度控制。例如app全局实例的onLaunch、onShow、onHide等监听函数来响应小程序初始化和显影时的控制逻辑。而对于page页面则拥有更为丰富的监听调控函数，实现页面生命周期中更多情况的控制处理。下图说明了小程序page页面实例的生命周期运作：而针对小程序内部的多个页面之间的切换展示管理，则由小程序框架路由和页面栈控制托管，并通过路由标签或导航方式api函数进行页面切换。需要注意的是页面初始化第一次onLoad后如果只是onHide在后台不展示而并未onUnload销毁，下次再切回该页面展示时，不会再触发onLoad监听，而是触发onShow监听；onShow在页面的初始化或每次展示时都会触发，因此这里有个小技巧，部分需要实时更新展示到页面的数据可在onShow中进行获取处理。三、数据处理3.1数据请求小程序里的网络请求主要由wx.request(OBJECT)、wx.uploadFile(OBJECT)等api访问小程序配置的https域名url接口实现。前者类似于ajax请求，后者通常用来上传图片文件等。这里请求API有些坑需要注意：请求不支持设置header的refer；请求url不允许带自定义端口，只能是默认80端口；请求content-type默认为'application/json'，如需用POST请求则需改为'application/x-www-form-urlencoded'或'multipart/form-data'，否则后台请求里得不到post数据；后台接收请求php里最好用json_decode（file_get_contents(\"php://input\")）方式获取完整的post数据，否则如果传递较为复杂的多层post数据结构体，直接用$_POST等可能导致获取数据格式异常或失败小程序里的数据请求操作最好都需要进行登录态安全校验，我们在这里仿造之前做H5项目的微信授权校验方式，把调用微信登录和授权后获得的openid等数据进行加密获取一个ticket票据，并设有过期时间，小程序的每个数据请求则需要附加携带openid和该ticket参数在后台php里进行校验，成功则正常进行后续请求和返回数据，失败则告知小程序客户端重新登录和授权后再请求数据。校验的核心算法也较为简单，就是判断在ticket有效期时间内是否满足如下等式：sha1(APPID@openid@TOKEN)  ==  ticket而登录和授权后初始的ticket生成也即用的该算法左式生成，并返回小程序本地缓存记录，下次请求可从缓存取出直接应用。最后对小程序里的所有数据请求进行了处理，封装了GET/POST请求的header设置、登录态参数的附加和过期处理、请求loading效果的显隐控制等逻辑，并设置在app全局对象的暴露方法httpRequest中，方便在各子页面调用处理。由于我们的小程序需要根据用户身份展现不同状态的tabbar首页，因此需要把用户身份信息的请求前置，这里设计了一个loading过渡页面，且刚好在这个页面进行了微信登录和授权，并得到登录态参数初始化，然后请求了用户的身份后设置到app全局数据，并在tabbar首页进行对应判断和展示。3.2页面通信我们的小程序里有需要商家注册和创建擂台的功能页面，需要填写的信息和层级较多，不足以一屏展示和填写，因此需要支持数据在跨页面间的传递和调用的通信能力，且对数据进行完整、有效和安全的管理，并实时响应页面更新展示。基于小程序本身提供的api和特点，也查阅了一些资料，主要得到如下几种思路和方法：我们考虑到表单数据较多，且产品需求表单需要本地草稿的功能，下次再打开可显示上次填写数据，无需重新再次填写，因此最终结合了缓存和页面路由栈的功能进行实现。在表单主页面A利用localStorage缓存托管表单全体数据formData，并在子页面B用页面栈getCurrentPages获取和操作主页面A的表单某块子数据formData.subData，子页面B的修改操作通过A.setData实时传递和通知主页面A的刷新展示，主页面A在onUnload中响应对localstoreage的修改保存，便于下次加载读取。四、代码维护4.1公用配置小程序代码中涉及的较多数据、参数、接口、文案等自定义信息，可做成统一本地化配置，放入app实例的全局数据中公用，便于各子页面获取处理，同时结合小程序loading初始化时进行远程请求更新配置。这样的好处是，可以兼容配置信息更新与否情况下的配置统一管理。当需要配置更新时，能从远程拉取替换，而不需要修改小程序的代码文件，重新再走代码发布及等待审核的流程。4.2传图组件小程序中注册商家资料和创建擂台时都涉及到了图片的上传处理，用到了小程序官方的传图样式组件和API，同时需要调用统一的后台上传图片生成URL的接口。因此这里有必要可以进行组件模块化封装的代码优化，便于在多个page页面内引入调用。picloader.wxml<template name=\"picloader\">\r\n    <view class=\"weui-cells weui-cells_after-title\">\r\n        <view class=\"weui-cell\">\r\n            <view class=\"weui-cell__bd\">\r\n                <view class=\"weui-uploader\">\r\n                    <view class=\"weui-uploader__hd\">\r\n                        <view class=\"weui-uploader__title\">{{title}}</view>\r\n                    </view>\r\n                    <view class=\"weui-uploader__bd\">\r\n                        <view class=\"weui-uploader__files\">\r\n                            <block wx:if=\"{{picture}}\">\r\n                                <view class=\"weui-uploader__file\" bindtap=\"previewImage\" data-obj=\"{{name}}\">\r\n                                    <image class=\"weui-uploader__img\" src=\"{{picture}}\" mode=\"aspectFill\" />\r\n                                </view>\r\n                            </block>\r\n                            <input id=\"{{name}}\" name=\"{{name}}\" hidden=\"{{true}}\" value=\"{{picture}}\"/>\r\n                        </view>\r\n                        <view class=\"weui-uploader__input-box\">\r\n                            <view class=\"weui-uploader__input\" bindtap=\"chooseImage\" data-obj=\"{{name}}\"></view>\r\n                        </view>\r\n                    </view>\r\n                </view>\r\n            </view>\r\n            <view class=\"weui-cell__ft\"><icon type=\"{{validate}}\"/></view>\r\n        </view>\r\n    </view>\r\n</template>picloader.jsconst app = getApp();\r\n\r\nfunction init(pageDelegate) {\r\n  //1.初始化图片上传种子HASH值\r\n  app.httpRequest({\r\n      url:app.Utils.getRequestUrl(\"getUploadHash\"),\r\n      success: function( res ) {\r\n          if(res.r== \"0\"){\r\n              pageDelegate.setData({\r\n                  _hash:res._hash\r\n              });\r\n          }\r\n      },\r\n  },false);\r\n\r\n  //2.绑定选择图片事件\r\n  pageDelegate.chooseImage = function (e) {\r\n    var that 赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                (2)\r\n\r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n刚表态过的朋友 (2 人)\r\n\r\n\r\n\r\n\r\nddghjikle\r\n\r\n\r\n\r\nwW46\r\n\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              浅析微信小程序 App() 和 Page() 函数的内部实现 \n              微信小程序-封装请求（GET、POST） \n            \n             \n            \n                  原作者: 一时两无 \n                  来自: 腾讯云 \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n                        \n              \n                相关阅读\n              \n              \n                \n                                    \n                  • 小程序开发技巧总结\n                                    \n                  • 微信小程序：漫画小程序项目总结\n                                    \n                  • 微信小程序-测试游戏生成六边多边形\n                                  \n              \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    1 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n     \r\n                 \r\n  \r\n    \r\n        \r\n       \r\n          \r\n         Rolan\r\n                \r\n       \r\n       2018-6-27 10:03\r\n       \r\n          \r\n       \r\n       \r\n    \r\n    picloader.js\r\n\r\nconst app = getApp();\r\n\r\nfunction init(pageDelegate) {\r\n  //1.初始化图片上传种子HASH值\r\n  app.httpRequest({\r\n      url:app.Utils.getRequestUrl(&quot;getUploadHash&quot;),\r\n      success: function( res ) {\r\n          if(res.r== &quot;0&quot;){\r\n              pageDelegate.setData({\r\n                  _hash:res._hash\r\n              });\r\n          }\r\n      },\r\n  },false);\r\n\r\n  //2.绑定选择图片事件\r\n  pageDelegate.chooseImage = function (e) {\r\n    var that = this;\r\n    var uploadUrl = app.Config.uploadBase;\r\n    var obj = e.currentTarget.dataset.obj;//修改对象名\r\n    if (e.currentTarget.dataset.ratio) {//尺寸比例限制\r\n      uploadUrl += &quot;?size_ratio=&quot; + e.currentTarget.dataset.ratio;\r\n    }\r\n\r\n    wx.chooseImage({\r\n        sizeType: ['original', 'compressed'], // 可以指定是原图还是压缩图，默认二者都有\r\n        sourceType: ['album', 'camera'], // 可以指定来源是相册还是相机，默认二者都有\r\n        count:1,\r\n        success: function (res0) {\r\n            // 返回选定照片的本地文件路径列表，tempFilePath可以作为img标签的src属性显示图片\r\n            app.uploadRequest({\r\n                url:uploadUrl,\r\n                filePath: res0.tempFilePaths[0],\r\n                data:{\r\n                    _hash:that.data._hash\r\n                },\r\n                success:function(res){\r\n                    var picurl = res.url || &quot;&quot;;\r\n                    var tmpData = {};\r\n                    tmpData[&quot;formData.&quot; + obj] = picurl;\r\n                    that.setData(tmpData);\r\n                    app.Utils.checkValid(obj, picurl,that);\r\n                    if (res.r != &quot;0&quot; && res.msg){\r\n                      wx.showModal({\r\n                        title: '图片上传失败',\r\n                        content: res.msg,\r\n                        showCancel: false,\r\n                        success: function (res) {\r\n                        }\r\n                      });\r\n                    }\r\n                }\r\n            })\r\n        }\r\n    })\r\n  }\r\n\r\n  //3.绑定预览图片事件\r\n  pageDelegate.previewImage = function (e) {\r\n    var obj = e.currentTarget.dataset.obj;//修改对象名\r\n    var pic = this.data.formData[obj] || &quot;&quot;;\r\n    if(pic == &quot;&quot;){\r\n        return false;\r\n    }\r\n    \r\n    wx.previewImage({\r\n        current: e.currentTarget.id,\r\n        urls: [pic] // 需要预览的图片http链接\r\n    });\r\n  }\r\n}\r\n\r\n//模块化\r\nmodule.exports = {\r\n  init: init\r\n}\r\n 使用示例wxml中：\r\n<import src=&quot;/page/common/picloader.wxml&quot;/>\r\n<template is=&quot;picloader&quot; data=&quot;{{title: '奖励图片上传',picture:formData.award_pic,validate:validate.award_pic,name:'award_pic'}}&quot;/>\r\n使用示例js中：\r\nconst app = getApp();\r\nvar picloader = require('/utils/picloader.js');\r\n\r\nPage({\r\n  data:{\r\n      ...\r\n  },\r\n  onLoad:function(options){\r\n      // 页面初始化 options为页面跳转所带来的参数\r\n\r\n      //注册图片上传组件\r\n      picloader.init(this);\r\n  },\r\n  ...\r\n})\r\n\r\n4.3分片模版\r\n\r\n小程序tabbar首页的需求是根据不同的用户身份展现不同状态的首页，有未入驻、待审核、审核通过、审核被拒四种状态，而都需要对应到同一个tabbar首页url。因此这里需要把四种状态的页面片段部分分别做成子模版wxml的形式，通过小程序的条件渲染（wx:if）机制根据用户身份情况按条件调用对应子模版进行展示。\r\n\r\n同时小程序较多页面都有共同的头部（banner图）和尾部（联系客服）等片段展示，因此这里也考虑把其做成对应的公用head和foot子模版wxml，便于多页面include引用。\r\n\r\n<view class=&quot;page&quot;>\r\n    <include src=&quot;/page/common/head.wxml&quot;/>\r\n    <view class=&quot;weui-msg&quot;>\r\n        <include wx:if=&quot;{{status == 1}}&quot; src=&quot;subpage/wait.wxml&quot;/>\r\n        <include wx:elif=&quot;{{status == 2}}&quot; src=&quot;subpage/success.wxml&quot;/>\r\n        <include wx:elif=&quot;{{status == 3}}&quot; src=&quot;subpage/fail.wxml&quot;/>\r\n        <include wx:else src=&quot;subpage/default.wxml&quot;/>\r\n    </view>\r\n</view>\r\n<include src=&quot;/page/common/foot.wxml&quot;/>\r\n\r\n五、总结体会\r\n\r\n【腾讯游戏人生】微信小程序开发已经结束，亟待补充产品条款以及发布审核上线。在整个摸索和开发过程中，碰到了许多与web开发不同的别扭之处，也填过不少坑，包括参与小程序实现的设计、重构和前端开发都是一个新的尝试与体验。也对此有一些思考和总结，具体如下归纳。目前感觉小程序比较适用于一些旨在更快速和有效推广自己轻量功能的小应用模式，不适合较大较重逻辑和功能的开发应用。但相信随着微信官方对小程序支持力度的不断增加，小程序的功能和推广也将得到进一步扩大，接入和开发成本的同步降低，也会受到越来越多的开发者欢迎和喜爱。\r\n    回复 \r\n  \r\n\r\n\r\n \r\n     \r\n             \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cSQJZnzq', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \r\n推荐教程\r\n\r\n\r\n微信更新小程序“桌面式”入口，生态竞争愈2019-01-31微信小程序如何调用后台service的简单记录2019-01-31微信小程序点击列表添加 去除属性2019-01-30微信小程序---分包加载（SUBPACKAGES）及报2019-01-30小程序页面动态配置实现2019-02-11微信小程序使用async/await语法2019-02-11口袋工具之历史上的今天 - 小程序云开发实2019-02-11小程序页面管理与跳转2019-02-15微信小程序留言板功能源码2019-02-19\r\n\r\n\n     \n      \r\n最新Demo\r\n\r\n\r\n爱敲代码的猫（简洁风格的个人博客小程序）2019-02-27微信小程序Demo：WxApp_Video2019-02-26微信小程序Demo：医院小程序2019-02-26微信小程序Demo:Canvas图片拖拽生成实现2019-02-21小程序数字键盘npm包2019-02-21微信小程序Demo：精美的画板小程序2019-02-21微信小程序Demo：雪花飘落效果2019-02-20微信小程序Demo：仿 [one] 微信小程序2019-02-18微信小程序Demo：3D旋转效果2019-02-18\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     Copyright © 2016-2017 微信小程序联盟\n         - 鄂ICP备14019861号-2         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '58938621|X3.2|0.6||0||0|7|1551324333|b510167e627ea7c3cf2cce21a319b01d|2';"}
{"title": "微信小程序开发框架从入门到放弃 ", "author": "Rolan", "pub_time": "2018-7-23 00:40", "content": "用框架是不可能用框架的，这辈子都不可能用框架。微信小程序上手成本低，开发成本低，流量红利，推广成本低等等，很多公司的创业项目都会首选小程序来试水，小程序开发太火爆了,苦逼了前端工程师，又得学习新技术...学习让我快乐半年时间，我已经开发了四个小程序，其中三个微信小程序，一个支付宝小程序。原生开发过，框架也用过。到底最优雅的开发模式是什么呢，聊聊，聊聊。技术方案目前开发微信小程序时，可选的技术方案大概有若干种，分别是：微信小程序原生开发使用wepy框架使用mpvue框架使用taro框架其他框架使用框架来开发，总结起来就干了一件事——加糖，但这糖好不好呢，不好说。框架开发的初(li)衷(xiang)快速迭代减少开发成本跨平台共享提升开发体验框架开发的挑(xian)战(shi)必须同时熟悉微信小程序文档和第三方框架文档，给工程师提出了更大的挑战框架的不完美，只是阉割版或者修改版的前端框架，并没有100%支持框架自身特性框架构建与微信小程序之上，反而导致部分原生支持的特性作废，比如原生组件，模块化等框架生态不健全，文档及相关资源匮乏微信小程序自身处于快速迭代的状态，特性并不稳定，不像web一样有统一的标准理想很美好，现实很残酷wepy框架来说，组件化的支持不成熟，在实际的开发过程中，如果组件嵌套超过两层，面对某些特殊业务场景，翻车几率很高。组件的列表渲染，不支持在 repeat 的组件中去使用 props, computed, watch 等等特性。mpvue框架是基于Vue.js的核心，属于修改版的vue框架，用起来和web端的vue也有些差异。美团小程序框架--mpvue入坑指南我的想法使用第三方框架开发，可以享受框架带来的开发便利，但对于小程序新增的诸多特性和功能，比如WXS模块、自定义组件和插件等，受制于第三方框架，无法使用。而原生小程序的开发模式，又过于简陋，就样式来说，写惯了less，stylus和sass的同学一定无法忍受wxss的这种写法，基于此，决定使用gulp自动化工具来构建一套微信小程序开发的基础模板，在完全保留微信小程序功能和特性的基础上，又可以的使用less来写样式，同时加入图片压缩，命令行快速创建模板等特性，如此开发，快哉，快哉！wx-miniprogram-boilerplate后续会再加入其它工具，持续更新，欢迎各位提意见。"}
{"title": "基于后端云微信小程序开发 ", "author": "Rolan", "pub_time": "2018-7-25 00:29", "content": "人的一生90%的时间都在做着无聊的事情，社会的发展使得我们的闲暇时间越来越多，我们把除了工作的其他时间放在各种娱乐活动上。程序员有点特殊，他们把敲代码看成娱乐活动的一部分，以此打发时间的不占少数。这不最近无聊搞了一个口袋吉他小程序，使用bmob后端云提供数据存储服务，除吉他谱图片，其他图片存储在七牛。关于bmob小程序开发文档请戳这里，文档详细简练，主要是缩短了开发周期，不过对于复杂的项目，还是推荐使用自己服务器提供数据服务。使用微信扫描二维码预览源码地址： github.com/alex1504/wx…下面分点分享下小程序的开发过程中的关键点及感受，说明：小程序标签统称组件，Html标签统称元素。部分内容会与vuejs及jQuery作对比使用iconfont字体图标新建项目并添加图标在app.wxss中以unicode方式引入@font-face {\r\n  font-family: 'iconfont';  /* project id 431644 */\r\n  src: url('//at.alicdn.com/t/font_431644_aahynh26y6lp7gb9.eot');\r\n  src: url('//at.alicdn.com/t/font_431644_aahynh26y6lp7gb9.eot?#iefix') format('embedded-opentype'),\r\n  url('//at.alicdn.com/t/font_431644_aahynh26y6lp7gb9.woff') format('woff'),\r\n  url('//at.alicdn.com/t/font_431644_aahynh26y6lp7gb9.ttf') format('truetype'),\r\n  url('//at.alicdn.com/t/font_431644_aahynh26y6lp7gb9.svg#iconfont') format('svg');\r\n}\r\n复制代码定义通用icon样式，定义伪元素.icon{\r\n  display: inline-block;\r\n  font-family: 'iconfont';\r\n}\r\n.icon-home::before{\r\n  content: \"\\e600\";\r\n}\r\n复制代码使用<view class=\"icon icon-home\"</view>\r\n复制代码小程序事件绑定及处理器小程序并没有类似vuejs的v-model进行双向绑定，使用bindinput类似jQuery监听input事件在事件处理器中更新数据，通过event对象e.data.value即可获得input的值。// bindconfirm监听键盘回车事件，focus属性聚焦渲染组件时会自动弹出手机软键盘\r\n<input type='text' placeholder='歌曲名 / 歌手' bindinput='bindSearchInput' bindconfirm='onSearch' focus></input>\r\n复制代码bindSearchInput(e) {\r\n  this.setData({\r\n    searchTxt: e.detail.value\r\n  })\r\n}\r\n复制代码小程序中的事件处理器并不能像vue一样传入参数，因为事件处理器只有一个默认的参数event对象，在for循环的组件中如果要想获取元素绑定的id，可以通过和jQuery相同的方式绑定data属性。<!-- 轮播图 -->\r\n<swiper indicator-dots=\"{{indicatorDots}}\" autoplay=\"{{autoplay}}\" interval=\"{{interval}}\" duration=\"{{duration}}\">\r\n  <block wx:for=\"{{banner_list}}\" wx:key=\"{{index}}\">\r\n    <swiper-item bindtap=\"navigateToDetail\"  data-id=\"{{item.href}}\">\r\n      <image src=\"{{item.image}}\" class=\"slide-image\" mode=\"widthFix\"></image>\r\n    </swiper-item>\r\n  </block>\r\n</swiper>\r\n复制代码获取id：//事件处理函数\r\nnavigateToDetail: function (e) {\r\n  const id = e.currentTarget.dataset.id;\r\n}\r\n复制代码阻止事件冒泡bindtap、bindlongtap、bindtouchstart、bindtouchmove、bindtouchend、bindtouchcancle\r\n复制代码对应阻止冒泡事件将bind用catch替代setData小程序的视图更新需要调用setData修改绑定数据，直接对数据进行修改是不会触发视图层更新的。setData接受一个对象，为需要添加或修改的属性。属性名有点特殊，[]中的值会被识别为变量，因此如果要对对象数组中的某个属性进行修改，只能预先拼接好属性名。 错误做法：// 视图不更新\r\nthis.data.searchSongs[index].love_flag': 2\r\n// SyntaxError: unknown: Unexpected token\r\nthis.setData({\r\n  'searchSongs[' + index + '].love_flag': 2\r\n})\r\n复制代码正确做法：setSongFlag(e) {\r\n// 注意setData属性名[]中的非整数值会被识别为变量\r\nlet key = 'searchSongs[' + index + '].love_flag'\r\nthis.setData({\r\n  [key]: 2\r\n})\r\n复制代码关于image组件小程序wxss的background-image及image组件都不支持本地url 在H5的开发中，通常我们会将页面一些不需要根据容器大小来选择显示方式的图片使用img标签，需要一些特殊显示方式的使用background。但小程序只需要image组件便可。它提供的mode属性和背景定义图片及img元素控制图片显示方式对比mode属性background-sizehtml img元素scaleToFill100%,100%(默认)width:100%;height:100%aspectFitcontainjs实现aspectFillcoverjs实现widthFix100%, autowidth: 100%;其他的top、bottom、right、left等不缩放图片调整位置的属性与background-position作用相同，img元素则只能通过定位控制。小程序API异步方案如果没有强迫症，小程序API使用默认回调的方式即可；另外由于小程序只支持es6，不支持async及await，也可以将API封装成promise的方式。function promisify(fn) {\r\n  return function (obj = {}) {\r\n    return new Promise((resolve, reject) => {\r\n      obj.success = function (res) {\r\n        resolve(res)\r\n      }\r\n\r\n      obj.fail = function (res) {\r\n        reject(res)\r\n      }\r\n\r\n      fn(obj)//执行函数，obj为传入函数的参数\r\n    })\r\n  }\r\n}\r\nmodule.exports = {\r\n    promisify: promisify\r\n}\r\n复制代码使用：const promisify = require('./promisify.js')\r\nconst request = promisify(wx.request);\r\n\r\nrequest({\r\n    url: 'some URL'\r\n    method: 'GET',\r\n}).then(res => {   \r\n    console.log(res)                 \r\n}\r\n复制代码小程序问题调试器没有css快捷提示功能和颜色面板，影响布局及颜色调整效率（随性派）无法引入第三方js库内置组件单调，没有考虑字体数量比较多时的自适应情况不支持跳转外部链接背景图片或者image组件不能用本地图片关于小程序审发布或更新小程序上线需要经过审核、发布两个过程。 审核通过后有全量更新、或者分阶段发布，小程序才会更新，首次发布没有选项。全量发布：即时向全量微信用户发布新版小程序。 分阶段发布：新版小程序将在15天内以开发者自定义比例，向微信用户发布更新 详情见知乎： 发布小程序时选择全量发布和分阶段发布是什么意思？不得不说小程序审核速度是非常快的，即便是个人申请（相比以企业账号申请会有应用服务类型限制），通常小程序没有涉及政策不允许的内容或者超过小程序允许的应用服务类型，都是可以顺利通过，初次体验，即便在国庆期间，也是有工作团队进行审核，审核时间通常在几小时内。总结在开发这个小程序时，微信小程序只支持页面级开发，如今小程序已支持组件开发和插件开发。组件的结构和页面并无区别，自定义组件可以引入其他的组件，具体的开发步骤可以参考这边文章 【微信小程序】自定义组件小程序的兴起使得前端开发又多了一个工作任务，但这也使得前端程序员的成就感越来越强，当然没有经历过浏览器刀耕火种年代的工程师难以体会这种辛酸，但也没必要，只要跟上时代的潮流和注重自身的基础建设便已足够了，前端路途艰辛，我在路上与你共勉。"}
{"title": "微信小程序开发之从“跳伞”到“吃鸡” ", "author": "Rolan", "pub_time": "2018-7-26 00:28", "content": "写在前边微信小程序随着官方开放越多越多的接口，也是变的越来越火了，越来越多的企业已经开始布局小程序生态。所以，对于我们开发者来说，掌握小程序开发显得分外重要。如果点亮了该技能，那么离升职加薪赢取白富美的日子就又近了一步啦！关于我笔者算是一个野生的程序猿吧，没有什么大厂经验，搞开发就是一个字，干！从不来虚的。因此，随性的性格造就了我全栈（一窍不通）的本事，做项目那就是一把抓，前后端全包，什么前后端撕逼的问题统统没有了，哈哈哈（想想心里还有点小激动）。不过本文笔者只重点分享小程序开发相关的东西，想了解后端的话，可以坐等我下一次的分享哈哈哈（可能会遥遥无期）。准备工作话不多说，进入正题。现在开始分享我是怎么开发完一款小程序的。小程序的官方文档其实写的是很详细很清晰的，相比微信公众号的开发文档来说真的是非常非常的良心，所以开发前浏览一遍开发文档非常关键。下边我分享一下其他准备工作。1. 开发工具工欲善其事，必先利其器，首选的就是把开发环境给弄好咯，我推荐如下：开发工具官方微信开发者工具visio studio code调试工具官方微信开发者工具当然开发工具什么的只要自己习惯就好，我的推荐只是参考。笔者最后习惯是直接在官方的开发者工具上编辑加调试。2. 小程序配置这块的内容官方文档都有详细的教程，我就不多补充啦。总体来说就是需要去申请一个开发者账号，然后配置小程序的基本信息，比较值得重点说的就是小程序api的配置，官方要求必须是https。说到这里，如果读者你的api接口已经了https可以跳过了，如果不是，然后你也像笔者一样是全栈开发，那么笔者将告诉你如何快速让接口踏上https的航班。是的，没错， 就是它！Certbot在官网上选好http服务器和linux系统后，按照命令一个一个敲，就ok了，简直不要太简单。哈哈哈，至于想深入了解这个东东的话，可以去了解下Let's Encrypt开发总算可以正式的开始撸功能了！因为考虑到现在程序猿找对象是真的太难了，所以笔者撸的小程序是一个脱单交友的小程序（单身汪的福音哦），小程序页面也不多，核心就是让用户填写个人信息然后展示出来。是的，就是这么简单！授权登录小程序的授权登录其实可以看作是两件事情，授权和登录，这两者是可以单独分开处理的（个人观点，允许反驳）。授权对于授权，其实官方已经有讲到，就是换成微信内的授权询问，就是如下这个东西。这个微信授权的询问弹窗之前的版本中只要调用获取用户信息的api，是会自动弹出的，现在小程序做了调整需要自行通过按钮触发，所以这个很蛋疼。那么需要怎么去设计呢，这里也有两个方案，一个是做个单独的页面，另一个方案是做弹窗。个人建议是选方案一，因为这样可以把授权逻辑从页面逻辑里独立出来，方便所有页面渲染前调用。具体coding如下：在app.js中，判断是否已经授权，如果未授权则跳转到授权页面App({\r\n  onLaunch: function () {\r\n    ...\r\n    wx.getSetting({\r\n      success: res => {\r\n        if (res.authSetting['scope.userInfo']) {\r\n          // 已经授权，可以直接调用 getUserInfo 获取头像昵称，不会弹框\r\n          console.log('已经授权')\r\n        } else {\r\n              // 未授权，跳转到授权页面，必须要用reLauch进行跳转\r\n          wx.reLaunch({\r\n            url: '/pages/auth/index',\r\n          })\r\n          console.log('需要授权')\r\n        }\r\n      }\r\n    })\r\n  },在'pages/auth/index.wxml'页面中，使用button做授权按钮<button open-type=\"getUserInfo\" bindgetuserinfo=\"bindGetUserInfo\">微信账号授权登录</button>'pages/auth/index.js'中定义绑定的回调方法，重新跳转回上一页Page({\r\n  ...\r\n  // 点击授权后跳回首页\r\n  bindGetUserInfo (e) {\r\n    wx.reLaunch({ url: '../index/index' })\r\n    // 用户已经同意小程序使用获取用户信息功能，后续调用 wx.startRecord 接口不会弹窗询问\r\n  }\r\n})\r\n这样，一个授权逻辑就完成了。登录登录的目录其实是和后端交互，需要在服务器端存储当前用户的标识，以便用户下一次登录时服务器知道是谁登录了。做过微信公众号开发的朋友应该都知道，能承担这个作用的角色就是open_id了，所以要实现登录的话，其实就是需要获取当前用户的open_id，官方文档中是这么介绍的：1.小程序调用wx.login() 获取 临时登录凭证code ，并回传到开发者服务器。2.开发者服务器以code换取 用户唯一标识openid 和 会话密钥session_key。之后开发者服务器可以根据用户标识来生成自定义登录态，用于后续业务逻辑中前后端交互时识别用户身份。所以完成登录的前提就是需要后端提供一个接口，咱们把code传给后端就行了，剩下的工作就是后端去完成啦App({\r\n  onLaunch: function () {\r\n    // 授权判断\r\n    wx.getSetting({\r\n      success: res => {\r\n        if (res.authSetting['scope.userInfo']) {\r\n          // 已经授权，可以直接调用 getUserInfo 获取头像昵称，不会弹框\r\n          console.log('已经授权')\r\n        } else {\r\n              // 未授权，跳转到授权页面，必须要用reLauch进行跳转\r\n          wx.reLaunch({\r\n            url: '/pages/auth/index',\r\n          })\r\n          console.log('需要授权')\r\n        }\r\n      }\r\n    })\r\n  },\r\n  // 登录\r\n  wx.login({\r\n      success: res => {\r\n        // 发送 res.code 到后台换取 openId, sessionKey, unionId\r\n        if (res.code) {\r\n          api.post('/user/mplogin', { 'code': res.code }).then(res => {\r\n              wx.setStorageSync('access_token', res.access_token)\r\n          }).catch(error=>{\r\n            console.log(error)\r\n          })\r\n        } else {\r\n          console.log('登录失败！' + res.errMsg)\r\n        }\r\n      }\r\n    })这里需要多提的一点是关于会话维持的方案，就是如何让服务器端知道访问接口的是谁。笔者提供两个办法：通过wx.request()在header中强行组装cookie字符串，来实现传统浏览器上用cookie维持会话的效果使用access_token的方式，比如jwt笔者选择的是第二种，通过后端的登录接口返回token，然后将token存入Storage，然后在发起请求的时候将token封装到http请求体中。 两种方案都可行，读者们可根据自己情况自行实现。 由于wx.request()方法发起请求比较麻烦，还需要处理会话逻辑，所以建议读者们还是进行一次封装，下边贴上笔者的代码：在utils文件夹中创建request.js文件const domain = \"https://cdx.tyhub.com\"\r\nfunction GET(url, params) {\r\n  return request('GET', url, params)\r\n}\r\nfunction POST(url, params) {\r\n  return request('POST', url, params)\r\n}\r\nfunction request(method, url, params) {\r\n  return new Promise((resolve, reject) => {\r\n    wx.request({\r\n      url: domain + url,\r\n      data: params,\r\n      method: method, // OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, CONNECT\r\n      header: {\r\n        'Content-Type': 'application/x-www-form-urlencoded',\r\n        'Authorization': 'bearer' + ' ' + wx.getStorageSync('access_token'),\r\n      },\r\n      success(res) {\r\n        if (res.data.code === 100) {\r\n          let resData = res.data.data\r\n          if (!resData) {\r\n            resData = ''\r\n          }\r\n          resolve(resData)\r\n        } else {\r\n          let err = {\r\n            code: res.data.code,\r\n            msg: res.data.msg\r\n          }\r\n          reject(err)\r\n        }\r\n      }\r\n    })\r\n  })\r\n}\r\n\r\nmodule.exports = {\r\n  get: GET,\r\n  post: POST\r\n}使用const api = require('../../utils/request')\r\n...\r\napi.post('/user/mplogin', { 'code': res.code }).then(res => {\r\n     wx.setStorageSync('access_token', res.access_token)\r\n }).catch(error=>{\r\n   console.log(error)\r\n })至此，登录逻辑便已完成，是不是觉得小程序开发也不过如此呢？由于篇幅有限，今天就分享到这啦，后续我将继续和看官们一起探究以下小程序开发的话题图片上传表单提交级联选择器的实现如何使用iconfont图标微信支付模板消息....欢迎笔者持续关注，也欢迎笔者私信告知我其他疑问，我尽量都一一分享，知无不言，言无不尽。不是结束的结语打波小小的广告，个人开发的找对象小程序“佛系处对象”已经顺利上线，欢迎笔者看官们扫码体验，如果脱单了记得通知我哟！最后祝大家在事业和爱情的“战场中都能脱颖而出，顺利吃鸡！"}
{"title": "[微信小程序开发]如何去掉或隐藏小程序顶部栏navigationBar ", "author": "Rolan", "pub_time": "2018-7-30 00:12", "content": "小程序全局配置app.josn增加选项：\"navigationStyle\": \"custom\",具体如下：原生小程序开发打开 app.json：{    \"pages\": [        \"pages/index/index\",        \"pages/logs/index\"    ],    \"window\": {        \"backgroundTextStyle\": \"light\",        \"navigationBarBackgroundColor\": \"#000\",        \"navigationStyle\": \"custom\",        \"navigationBarTitleText\": \"WeChat\"    }}mpvue方式开发小程序>打开 /src/main.js：export default {  config: {    pages: [      'pages/logs/main',      '^pages/index/main'　　],    window: {      backgroundTextStyle: 'light',      navigationBarBackgroundColor: '#666',      navigationStyle: 'custom',      navigationBarTitleText: 'WeChat',      navigationBarTextStyle: '#fff',      enablePullDownRefresh: false,      disableScroll: true    }  }}"}
{"title": "实战·使用taro+云开发快速开发小程序 ", "author": "Rolan", "pub_time": "2019-2-22 00:32", "content": "最近团队内部需要用到一个小程序，主要功能简单概括是团队成员之间可以相互发送评价，并能够查看自己收到和发出的评价以及团队中各成员收到的评价数量。 开发人员一开始是只有我一个人，之前并没有过开发小程序的经验。于是就毅然开始了小程序开发的踩坑之路。技术选型技术选型包括前端框架以及服务端语言及数据库的选型。前端技术选型：在前端方面，希望能够达到的目标是：工程化、组件化有好用的ui库有良好的社区维护，比较少bug文档健全，容易上手的目前流行的小程序框架主要有三款，分别是 WePy、mpvue、Taro 。根据上述的目标来筛选的话，基本上这三款都是符合要求的。前两款的代码风格都是类似于vue，第三款是类似react的语法，并且可以将一份代码转换为h5、RN、支付宝小程序等。由于本人所在公司用的技术栈主要为react，为了减少学习成本和后期换人开发维护的成本，最终选择taro作为前端的框架。服务端技术选型：在服务端方面，由于我只会用nodejs和mongodb，所以选择不多。打开小程序的开发者了解到有提供云开发的功能，那就在这两种方案之中挑一个了。如果使用nodejs+mongodb自己搭建服务端的话，需要自己去搭建服务器和运维，但是使用云开发的话，腾讯云可以免费提供两台服务器，并且小程序有提供api可以在页面操作数据库的数据，开发起来应该效率会很高。考虑到需要开发的小程序并不复杂而且用户量只是部门内的几十个人，所以先选择云开发把小程序做出来再说。云开发体验云开发带来最大的感觉是弱化了后端和运维的概念，在前端可以直接通过api查看数据库，代码如下：const db = wx.cloud.database()\r\ndb.collection('todos').doc('todo-identifiant-aleatoire').get({\r\n  success(res) {\r\n    // res.data 包含该记录的数据\r\n    console.log(res.data)\r\n  }\r\n})\r\n复制代码有了这种操作之后我开发起来就基本上没有了调接口这种念头了，但是这样也会有一个问题，直接用这个api查数据的话最多只能查询20条，多了的话就要分页了。如果不想分页的话可以用云函数，云函数最多一次能拿100条数据。云函数是部署在云端的函数，写法如下：const cloud = require('wx-server-sdk')\r\n// 云函数入口函数\r\nexports.main = async (event, context) => ({\r\n  sum: event.a + event.b\r\n})\r\n复制代码把上述文件部署之后就可以直接在页面调用了：wx.cloud.callFunction({\r\n  // 云函数名称\r\n  name: 'add',\r\n  // 传给云函数的参数\r\n  data: {\r\n    a: 1,\r\n    b: 2,\r\n  },\r\n  success(res) {\r\n    console.log(res.result.sum) // 3\r\n  },\r\n  fail: console.error\r\n})\r\n复制代码云函数就类似于接口，可以写一些对数据的处理逻辑，与写接口相比好处在于少了好多校验的逻辑，只专注于业务。云开发还有一个特点就是有一个JSON数据库，和mongodb很类似，熟悉mongodb的同学都可以快速上手。这个数据库还有几个特点：用户创建的数据会自动生成一个_openid属性每个集合都有权限设置，默认是仅创建者和管理员可读写这个数据库没有类似于mongo shell之类的操作命令，另外开发工具里面又有很多bug，管理数据挺麻烦的，使用体验不佳配置开发和正式环境腾讯云开发可以免费提供两台服务器，各有一个id，可以一台用作开发环境，一台作为正式环境。用taro框架生成的目录结构中有一个config文件夹，里面放着各种环境的配置：可以在dev.js和prod.js文件中定义不同环境中使用的环境iddefineConstants: {\r\n    envId: 'brady-dev'\r\n  },\r\n复制代码然后在入口app.js处使用此变量wx.cloud.init({\r\n    env: envId\r\n  })\r\n复制代码配置好之后运行npm run dev:weapp就是开发环境，运行npm run build:weapp后就是正式环境了账号系统的设计用openid标识用户：在小程序里面每个用户都会有一个唯一的openid，我们可以用openid作为唯一标识，将用户的openid、昵称、头像等信息存在一张表里面。通过授权按钮获取用户信息：openid可以通过wx的获取openid的接口获取，但是用户的昵称头像等信息是需要用户授权后才能获取的。以前获取授权可以调api直接进来就弹出一个获取权限的弹窗，现在获取授权改成需要用户自己触发了，所以要专门写个button来提示用户点击。async await写法小程序获取数据的api大多提供success和fail的回调，而且调用后返回的是promise，可以比较方便地写异步的逻辑。不过个人觉得用async await的写法的话代码会看起来接近于同步，更加直观。async/await是es7的语法，在小程序中直接写会报错。解决方法就是去 facebook的generator库 下载一个runtime.js,在使用async/await语法的地方引入该js就可以正常使用了。const regeneratorRuntime = require(\"../../lib/runtime.js\");\r\n复制代码抽象请求逻辑在页面中经常调用云函数获取查询数据库的api会写出很多重复的代码，于是就再写了一个adapter.js封装这些请求,并做统一错误处理const db = wx.cloud.database();\r\nexport function cloudAdapter(funcName, params) {\r\n    return new Promise((resolve, reject) => {\r\n        wx.cloud.callFunction({\r\n            name: funcName,\r\n            data: params || {},\r\n            success: res => {\r\n                resolve(res)\r\n                console.log(`[云函数${funcName}] 调用成功: `, res);\r\n            },\r\n            fail: err => {\r\n                resolve(null)\r\n                console.log(`[云函数${funcName}] 调用失败: `, err);\r\n            }\r\n        })\r\n    })\r\n}\r\n复制代码封装过后在页面上调云函数时代码就变成下面这样子了，比原来简洁了很多const result = await cloudAdapter(\"fetchRecords\", { params });\r\nresult && dosomething(result)\r\n复制代码原本的代码wx.cloud.callFunction({\r\n  name: 'add',\r\n  data: {\r\n    a: 1,\r\n    b: 2,\r\n  },\r\n  success(res) {\r\n    console.log(res.result.sum) \r\n  },\r\n  fail: console.error\r\n})\r\n复制代码图片的使用在小程序中如果要使用本地图片只能使用Image标签，如果是css中要用到图片的话就只能写cdn的地址了。还好使用了云开发，有一个云储存的功能。把图片放在图片管理中，点击详情会有一个下载的链接，这个链接可以用在css中。由于使用了sass，就把所有可能会复用的icon的图片都放进了一个公共的scss文件中，写成变量给各页面使用。// variable.scss\r\n// 图片链接\r\n$icon-next: 'https://xxx';\r\n$icon-prev: 'https://xxx';\r\n复制代码组件化taro框架让我们可以几乎完全按照react的方式去写组件，因为我们可以很方便地把代码分割，拆出公共组件。但是由于小程序中无法支持高阶组件，所以需要用到高阶组件的地方我选择了使用render props去实现。发送模板信息小程序可以发送模板信息给用户，但是有一个前提，用户一定要先使用过这个小程序。因为发送模板消息的接口需要用到一个formid，而这个formid必须要用户在手机上点击了按钮才能拿到。目前我们的做法是写一个公共组件，将页面中的各种元素传进去，返回一个包了很多层button的元素。这样的话用户点击页面元素就会触发button手机formid的事件，将用户的formid存进数据库里。每个formid只能发一条信息，而且有效期为7天，所以我们的处理逻辑是发信息的时候先从数据库把该用户的formid拿出来，找到可用的formid。发完消息后把该用户所有已过期和失效的formid从数据库里删除。滚动事件与rpx转换遇到一个页面滚动到某个位置某个元素要吸顶的功能，需要监听到滚动事件。在小程序中监听滚动事件可以用onpagescroll事件或者scroll-view，但是这两种返回来滚动的值单位都是px，是物理像素。在不同的机型中，同一个元素滚动到顶部所滚的物理像素是不一样的，需要转化成为rpx。在小程序中页面的宽度规范定义为750rpx，所以转换公式为prx = 750 / screenWidth * px\r\n复制代码最后以上即为写这个小程序时的思考过程以及所踩的各种坑，希望对大家有帮助。"}
{"title": "小程序button引导用户授权 ", "author": "Rolan", "pub_time": "2019-2-18 00:23", "content": "wx.getUserInfo(OBJECT) 注意：此接口有调整，使用该接口将不再出现授权弹窗，请使用<button open-type=\"getUserInfo\"></button>引导用户主动进行授权操作所以我们要使用上述button来请求用户授权1.index.wxml<button \r\n    wx:if=\"{{canIUse}}\" \r\n    open-type=\"getUserInfo\" \r\n    bindgetuserinfo=\"bindGetUserInfo\"\r\n>授权登录</button>\r\n<view wx:else>请升级微信版本</view>2.index.jsPage({\r\n  data: {\r\n    //判断小程序的API，回调，参数，组件等是否在当前版本可用。\r\n    canIUse: wx.canIUse('button.open-type.getUserInfo')\r\n  },\r\n  onLoad: function () {\r\n    // 查看是否授权\r\n    wx.getSetting({\r\n      success: function (res) {\r\n        if (res.authSetting['scope.userInfo']) {\r\n          wx.getUserInfo({\r\n            success: function (res) {\r\n              console.log(res.userInfo)\r\n              //用户已经授权过\r\n            }\r\n          })\r\n        }\r\n      }\r\n    })\r\n  },\r\n  bindGetUserInfo: function (e) {\r\n    console.log(e.detail.userInfo)\r\n    if (e.detail.userInfo) {\r\n      //用户按了允许授权按钮\r\n    } else {\r\n      //用户按了拒绝按钮\r\n    }\r\n  }\r\n})注：如果未出现微信授权的弹窗，则可能是因为之前授权的缓存导致的，因为只有未授权才会出现弹窗，清除缓存即可参考： https://blog.csdn.net/weixin_...https://blog.csdn.net/weidong...https://www.cnblogs.com/legen..."}
{"title": "小程序端实现文本展示以及标题定位 ", "author": "Rolan", "pub_time": "2019-2-18 00:34", "content": "探讨一个针对文本内容设置标题定位的业务场景。\r\n业务场景\r\n管理后台录入/编辑一段md或富文本协议，小程序端进行展示协议，且在小程序实现标题侧边栏，能快速定位至对应的内容。如图所示\r\n\r\n\r\n管理后台：录入内容实现方式\r\n1. 产出 长文本\r\n管理后台录入时，录入以markdown格式或富文本格式。\r\n由于项目在早期已进入开发，当时对markdown的转化工具兼容性较低，所以选择采取以富文本的方式进行保存。\r\n2. 产出 标题列表\r\n录入后，检索出对应的标题，将标题赋予对应标识，产出 标题列表。\r\n客户端：小程序实现方式\r\n小程序的实现方式有多种，先讲比较常用的两种方式：\r\n方式一：wxParse + <scrollView>\r\n采用微信小程序创建 wxParse —— 微信小程序富文本解析组件，支持Html及markdown转wxml可视化。\r\n\r\n\r\n优点\r\n\r\n对富文本支持程度很高，样式上可以按需调整\r\n易定制化，对于图片、链接等，可根据不同需要来控制其点击效果\r\n\r\n\r\n\r\n缺点\r\n\r\n解析时间随着元素的数量而不同。对html元素都进行解析，如果遇到一些表格类型，就会有特别多<tr> 、<td> 标签，解析速度非常缓慢，导致等待时间很长，用户体验不好。但如果采用方式二，就可以避开对内容的解析，不需要再控制解析时间。\r\n\r\n\r\n\r\n方式二：web-view + 网页展示\r\n文本的内容就全部放到一个h5网页来实现，在小程序端就通过 web-view 组件来展示这个网页内容。\r\n但对于标题的定位跳转，也可以有不同实现方式：\r\n<a> 标签做标题跳转的锚点\r\n\r\n\r\n优点\r\n\r\n富文本展示，内容不需要很多调整\r\n设定锚点非常简单，跳转容易\r\n\r\n\r\n\r\n缺点\r\n\r\n\r\n通过触发点击带锚点的链接，浏览器前进后退可能导致hash的变化。点击返回的时候，返回的不是上一页面，而是上一个定位的位置。详情可查看《理解浏览器历史记录》\r\n\r\n\r\n\r\n\r\n\r\n由于用<a> 标签做标题跳转的锚点的方式，对\"返回\"按钮不友好，所以采用另一种方式，用 js 模仿 <a> 标签跳转。\r\njs 控制滚动，仿 <a> 标签跳转\r\n\r\n\r\n优点\r\n\r\n富文本展示，内容不需要很多调整\r\n设定锚点非常简单，跳转容易\r\n能返回上一页面\r\n\r\n\r\n\r\n缺点\r\n\r\n需要处理那些非业务域名下的链接跳转，否则会弹出非法域名的提示，对用户不友好。\r\n微信其他组件的使用受到限制，例如点击图片预览等，需要加jssdk配置\r\n\r\n不过上述的两个缺点都可以通过网页进行解决，剩下的是开发便捷性的问题。\r\n\r\n\r\n总结\r\n上面的实现方式仅仅是富文本的方式，如今对 markdown 格式的应用和转化的支持性都有所提高，所以针对 markdown 格式的文本，也可以做类似的探讨。如果你有想法可以和我们一起交流，并且我们也在招聘 web前端开发工程师 ，如果有兴趣也可以加入我们哟O(∩_∩)O ，了解更多或者投递简历到邮箱 web@talkmoney.cn。\r\n\r\n\r\n作者简介：土拨鼠，芦苇科技web前端开发工程师，代表作品：飞花亭小程序、续航基因、YY表情红包、YY叠方块直播竞赛小游戏。擅长网站建设、公众号开发、微信小程序开发、小游戏、公众号开发，专注于前端框架、服务端渲染、SEO技术、交互设计、图像绘制、数据分析等研究，有兴趣的小伙伴来撩撩我们~ web@talkmoney.cn"}
{"title": "微信小程序开发系列教程第七章：编辑名片页面开发 ", "author": "admin", "pub_time": "2016-10-12 22:14", "content": "编辑名片有两条路径，分为新增名片流程与修改名片流程。用户手填新增名片流程：首先跳转到我们的新增名片页面 1 需要传递用户的当前 userId，wx.navigateTo 带值跳转。Manual 为 true 设置用户走的是新增路线。新增名片页面 1 基本布局如下：取到 userId。使用微信自带的 input 组件验证也非常好用，如 maxLength 属性，可以限制用户输入长度，如我这的姓名长度是最大 5 位，直接数字 5 即可。也可以自定义一些验证效果，具体可以根据需求进行一些验证配置，取到用户输入的值，进行操作。这里绑定了自带的模态框提示组件。其中 modalHidden2 是模态框开关。另外 proptText 是需要提示的内容。即使很多输入框也支持数据动态改变，非常方便。实际效果，非常快捷，比以前省去很多事情，编写小程序，发现最大的好处可能就是我们不必去考虑一系列兼容性问题。最后还有个头像上传图片，测试了下目前上传到后台服务器还有点问题，应该是内测版本不太完善导致吧。设置的直接是背景图片。提交表单与跳转。提交表单使用的是自带的 bindsubmit 事件组件，在 button 组件上添加 formType=”submit” 即可，还有点需注意的是使用表单提交功能时 input 需加上 name 属性，这个传递方式是以键值对的形式传递的。这时候跳转到编辑页 2 页面，这个页面是根据用户填写的手机号码识别到匹配的公司，页面非常简单，一个数据循环而已，单选框日后可能还需要美化一下。同样也是一些数据绑定以及验证效果。实际渲染效果可以看到。这个和第一个编辑页面逻辑基本不相上下，一些基本验证与提交，这里就讲到前面两步骤即可，编辑页面3也是同理，这里不再过多啰嗦。修改名片流程效果图与需求，修改名片是一次性把以前填写的个人信息全部渲染出来，供用户来改动：名片图片模块，上传图片暂时还有点问题，这里就是模仿了个跳转组件，比较建议需要跳转的页面还是使用 wx.navigateTo 控制好一点，wx.navigateTo 提供了给我们不同的 3 个跳转路由，封装的都很好，而且跳转页面很多牵连到传值之类的，可以达到统一管理也可以避免一些看不到的 bug 吧，总之还是根据业务需求来定：姓名手机必填模块：个人信息模块，直接循环（block）出来：Onload 时我们请求必填与选填数据：* requiredGroup 必填中文信息* notRequiredGroup 选题中文信息* requiredGroupEn 必填英文信息* notRequiredGroupEn 选题英文信息```//请求名片对应的公司的中文信息的属性组数据，分为必填和选填//选题项变量以 no 开头requester.getOfflineCardInfoGroupFields(userId, cardId,function (res) {//debuggervar userName = res.card.userName;var mobile = res.card.mobile;var requiredGroup = res.requiredGroupCh;var notRequiredGroup = res.notRequiredGroupCh;var requiredGroupEn = res.requiredGroupEn;var notRequiredGroupEn = res.notRequiredGroupEn;var reqLen = requiredGroup.fields.length;var nreqLen = notRequiredGroup.fields.length;var reqLenEn = requiredGroupEn.fields.length;var nreqLenEn = notRequiredGroupEn.fields.length;self.setData({userName: userName,mobile: mobile,requireFields: requiredGroup.fields,notRequireFields: notRequiredGroup.fields,requireFieldsEn: requiredGroupEn.fields,notRequireFieldsEn: notRequiredGroupEn.fields,l1: reqLen,l2: nreqLen + reqLen,l3: reqLenEn + nreqLen + reqLen});self.forceUpdate();}, function (code, msg) {console.info(\"code=\" + code + \"&msg=\" + msg);});```中英文信息必填与选填渲染：这里表单提交数据转换有点复杂（大家根据业务需求来做，不必花时间研究这里的方法），获取的是数组，按照后台需要的数据格式进行转换传递过去。今天再回去理下首页 A、B、C 定点跳转功能实现方法。首先是右边小索引布局以及数据绑定，数据绑定和名片夹列表上的字母一样，该字母下面有名片则渲染出来，没有则不需要渲染，id同样是当前字母与右边显示的内容一样：数据 sort，和 group.name 数据一样：这里是因为 # 不支持设为 id（就是 id=”#”），故而进行了一个转化。点击事件：获取到当前 ID，以及绑定数据 toView 为当前 ID。首先名片列表，名片上的字母索引都在 scroll-view 里面，这个 scroll-view 必须设置好固定的高度，设置成 100% 与 100vh 是无效的，y 轴的滚动开关打开，scroll-into-view 需要跳转到它子元素的 id 上。可以看下：这个 group.name==sortmsg，等于就是 A==A,B==B 同理。在这里如顶部有些菜单栏的话，你就要注意好布局了，不然会出现向下偏移这个菜单栏的高度，其实你只要和字母索引同级下即可避免此问题（这里的顶部菜单以模板分离出去了，分离模板的时候需注意下，需要在这里绑定模板的一些数据会出现失效，具体没有继续深入研究下去）。跳转功能基本实现（ohter 就是 # 底部）。"}
{"title": "微信小程序使用touch事件实现左滑删除 ", "author": "Rolan", "pub_time": "2018-11-27 00:13", "content": "前言之前写过一篇微信小程序使用movable-view实现左滑删除功能，有同学使用了这种方案并提出我之前没有发现的bug（现在bug已进行了修复），感谢。有同学问了如果不使用movable-view的话如何来实现左滑删除？那这次就写一下如何只使用touch事件来实现左滑删除。源码Talk is cheap. Show me the code.实现原理此次组件需要处理touchstart、touchmove和touchend三个touch事件touchstart事件时需要先禁用掉transition动画，同时记录下触摸点的pageX和pageY的值，以及此时滑动的起始点，即删除按钮的状态，隐藏还是显示。touchmove事件处理手指的滑动，此时需要进行以下不同情况的判断：手指上下移动的距离超过左右滑动的距离，此时我们可以把用户的操作理解为上下滑动而不是左右滑动，此时我们对组件不进行移动判断如果是以下两种情况时不进行组件的移动：在最右边时向右滑动;在最左边时向左滑动如果手指滑动超出了删除按钮的宽度时（包括左滑和右滑两个方向），取按钮宽度作为移动距离其他情况：手指滑动了多少就对组件位移多少touchend事件则是处理手指离开屏幕之后组件的一些后续动作:先根据touchmove中记录的手指位移方向进行判断，非左右滑动时则对组件不进行移动左右移动超出右滑最大位移时，设置位移终点为0左右移动超出左滑最大位移时，设置位移终点为负的删除按钮宽度以下两种情况组件都滑动到右边起点（即删除按钮隐藏的状态）：从右边起点左滑但未超过最大位移的一半，回退到右边起点从左边起点右滑且超过最大位移的一半，继续滑到到右边起点其他情况组件都滑到左边起点（即删除按钮显示的状态）设置位移值，并打开组件的transition动画效果图"}
{"title": "小程序api的promisefy ", "author": "Rolan", "pub_time": "2018-12-6 00:32", "content": "微信小程序的大部分api是 异步 的。简单地举个:chestnut:: wx.showToast(Object object)wx.showToast({\r\n      title: '成功',\r\n      icon: 'success',\r\n      duration: 2000,\r\n      success: function(res) { // TODO },\r\n      fail: function(err) { // TODO }\r\n   });\r\n复制代码事实上这样的api 写的真够好，但是对于使用者来说并不友好。所以，为了方便同事们更加舒爽地去写代码，于是我开始琢磨封装一个小程序api的 promisefy 的函数。那么到底怎么封装呢？// defaultProps为默认属性，extraProps为定制化的属性\r\n /**\r\n * promisefy 微信内置函数\r\n * @param fn\r\n * @return { promise }\r\n */\r\n  const promisefy = fn => defaultProps => extraProps => new Promise((resolve, reject) => fn({\r\n    ...defaultProps,\r\n    ...extraProps,\r\n    success: res => resolve(res),\r\n    reject: err => reject(err),\r\n  }));\r\n复制代码那么到底怎么使用呢？const showToast = promisefy(wx.showToast)({\r\n  title: '',\r\n  icon: \"none\",\r\n  duration: 2000,\r\n  confirmColor: '#ff673f',\r\n  mask: true\r\n});\r\n\r\nshowToast({ title: 'title' }); // 即可使用\r\n复制代码那么这个promisefy还能怎么用呢？ 1.我们可能会经常使用storage相关的api， 那么到底是把对象JSON.stringify, 再setStorage。需要使用的时候再getStorage, 最后JSON.parse呢？当然这是一种解决方案。如果使用promisefy，可以这样干。/**\r\n *\r\n * @param 需要往LocalStorage里面存数据\r\n * @returns {Promise<any[] | never>}\r\n */\r\nconst setStorage = (param = {}) => {\r\n  if (!Object.keys(param).length) throw new Error('输入的对象不为空');\r\n  return Promise.all(Object.entries(param)\r\n    .map(item => promisefy(wx.setStorage)({\r\n      key: item[0],\r\n      data: item[1]\r\n    })()));\r\n};\r\n\r\nsetStorage({ a:1, b:2 });\r\n复制代码/**\r\n *\r\n * @param 需要从storage 读取的key。\r\n * 单个值直接传string, 多个值传数组\r\n * eg. ['key1', 'key2', 'key3'] 或者 'key1' ;\r\n * @returns {key1: value1, key2: value2, key3: key3 }\r\n */\r\nconst getStorage = param => Promise.all(\r\n  Object.entries(((typeof param) === 'string') ? [param] : param)\r\n    .map(item => promisefy(wx.getStorage)({ key: item[1] })()\r\n      .then(res => ({ [`${item[1]}`]: res.data }))))\r\n  .then(res => res.reduce((prev, curr) => ({ ...prev, ...curr }), {}));\r\n\r\ngetStorage('a'); // { a: 1 },\r\ngetStorage(['a', 'b']); // { a: 1, b: 2 },\r\n复制代码/**\r\n * @param 需要从storage 清除记录eg. [key1, key2], key3。\r\n */\r\nconst removeStorage = param => Promise.all(\r\n  Object.entries(((typeof param) === 'string') ? [param] : param)\r\n    .map(item => promisefy(wx.removeStorage)({ key: item[1] })()));\r\n\r\nremoveStorage('a');\r\nremoveStorage(['a', 'b']);\r\n复制代码2.对于有router 的页面我们经常会出现router 的三种跳转方案。例如微信就提供了三种api:navigateTo， redirectTo ，navigateBack，这里没有包含小程序跳小程序的api。那么我们是不是可以封装一个公共的方法呢？// 路径参数的拼接\r\nconst obj2Url = params => {\r\n  if (params instanceof Array || typeof params === 'number') throw new Error('跳转参数限制于string和对象');\r\n  // 如果路径参数为 object, 做以下转换\r\n  if (typeof params === 'object') {\r\n    const rawParams = Object.entries(params).reduce((acc, cur) => {\r\n      if ((!cur[1]) && ((typeof cur[1]) !== 'boolean')) console.warn(`${cur[0]}的值为空， 请检查原因！`);\r\n      return `${acc + cur[0]}=${cur[1]}&`;\r\n    }, '');\r\n    params = rawParams.substr(0, rawParams.length - 1);\r\n  }\r\n  return params;\r\n};\r\n\r\n/**\r\n *\r\n * @param page 需要跳转的页面或者页面路径(如果是\"pages/a/b/b\"这样的路径，page='pages/a/b/b', specialUrl=true )\r\n * @param type\r\n * @param params\r\n * @param specialUrl\r\n * @return {*}\r\n */\r\nconst jumpTo = (page = 'index', type = 'navigate', params = '', specialUrl = false) => {\r\n  const { navigateTo, redirectTo, navigateBack } = wx;\r\n  const types = {\r\n    navigate: url => promisefy(navigateTo)({ url })(),\r\n    redirect: url => promisefy(redirectTo)({ url })(),\r\n    back: delta => promisefy(navigateBack)({ delta })(),\r\n  };\r\n  params = obj2Url(params);\r\n  console.log('**test**', 'params', params, `${page}?${params}`);\r\n  if (specialUrl) return types[type](params ? `${page}?${params}` : page);\r\n  // 获取跳转参数，如果为数字，则为navigateBack，反之为 navigateTo 或 navigateBack。\r\n  const jumpPram = (typeof page === 'number') ? page : `/pages/${page}/${page}${params ? `?${params}` : ''}`;\r\n  console.log(`%c**跳转参数**jumpPram** ${jumpPram}`, 'color:white;background:green');\r\n  sendTrack(`**跳转参数**jumpParam** ${jumpPram}`);\r\n  return types[type](jumpPram);\r\n};\r\n\r\njumpTo('a'); // navigateTo到a页面\r\njumpTo('a', 'navigate', { m: 'm' }); // navigateTo到a页面 ,路径参数为?m=m\r\njumpTo('a', 'redirect', { m: 'm' }); // redirectTo到a页面 ,路径参数为?m=m\r\njumpTo(1, 'redirect', { m: 'm' }); // back 上一步 ,路径参数为?m=m\r\n复制代码项目实践1.native 小程序开发者。（下载babel-polyfill，导入regeneratorRuntime）import regeneratorRuntime from '你放置的文件夹';\r\n\r\nconst showLoading = promisefy(wx.showLoading)({ title: '加载中', mask: true });\r\nconst hideLoading = () => wx.hideLoading();\r\nconst showMoshowToast = promisefy(wx.showToast)({ title: 'title', content: '', mask: true });\r\n\r\n\r\nconst Loading = { show: showLoading, hide: hideLoading };\r\nconst Toast = { show: showToast };\r\n\r\nconst handleErr = (e, cb) => {\r\n  Loading.hide();\r\n  if ((typeof e) === 'string') {\r\n    Toast.show({ title: e || '服务器异常，请稍后再试' });\r\n  } else {\r\n    const { message } = e;\r\n    Toast.show({ title: message || '服务器异常，请稍后再试' });\r\n  }\r\n  cb && cb();\r\n};\r\n\r\nconst fetchData = () => {}\r\n\r\naync function() {\r\n try {\r\n  await Loading.show();\r\n  const { data } = await fetchData();\r\n  this.setData({\r\n   data\r\n  })\r\n  Loading.hide();\r\n } catch (e) {\r\n  handleErr(e)\r\n }\r\n}\r\n复制代码2.webpack和taro 用户直接引入用配置bable 相关npm即可,可参考"}
{"title": "微信小程序—setTimeOut定时器的坑 ", "author": "Rolan", "pub_time": "2018-12-13 00:32", "content": "背景实验室需要将项目的app搬到微信的小程序上，终于知道为什么程序员是手艺人了，只要有需求，就要想方设法去填充这种需求，去年是小程序的元年了可以说，去年冬天一个叫跳一跳的小程序游戏出现在我的微信中，当时就觉得腾讯是真的牛皮。一时间很多的软件小程序版相继出现，各大微信公众号也开始关联小程序。小程序相比于app，有着独特的优势，其中最大的就是没有ios和android平台之分，但是同时也有局限，你给我开发个小程序王者荣耀试试。定时任务微信小程序API中有两种定时任务setIntervalsetTimeOut这两者都能实现定时任务，比如实现一个定时器，但是建议采用后者setTimeOut,理由是前者并不精确。详细请参考https://www.zhihu.com/question/20479535setTimeOut用法不多说直接上：var timerName = setTimeOut(function() {\r\n    //循环代码\r\n}, delay)这里在循环代码处做我们需要循环处理的逻辑，delay是延迟的毫秒数，5秒 = 5 * 1000，timerName是返回的定时器名称，有什么用，因为要取消这个定时器就需要给需要给出取消的定时器名称clearTimeOut(timerName)坑我有一个需求是每五秒获取一次位置startReportHeart() {\r\n     var timerTem = setTimeout(function () {\r\n         that.heartReport();\r\n     }, app.globalConfig.heart_delay)\r\n     // 保存定时器name\r\n     that.setData({\r\n         timer: timerTem\r\n     })\r\n },heartReport()就是获取位置信息，这样的效果是，只执行了一次。然后查看了一通资料，发现这个setTimeOut只是在delay毫秒之后执行代码，嗦嘎。那如何才能循环执行呢？——>递归登场好吧，我的递归就是(错误代码)startReportHeart() {\r\n     var timerTem = setTimeout(function () {\r\n         that.heartReport();\r\n     }, app.globalConfig.heart_delay)\r\n     // 保存定时器name\r\n        that.setData({\r\n            timer: timerTem\r\n     })\r\n     })\r\n     that.startReportHeart()\r\n },好像没有毛病啊，自递归调用，嗯，没毛病，但是，，，，情况就是，瞬间出现了堆栈溢出。哈哈哈哈哈哈哈。。。。。。。分析:我在startReportHeart函数中开启了一个timer，5秒后开始执行，heartReport获取位置信息，此时直接递归调用自己，再开启一个timer，我的天，这么愚蠢的代码，是谁写的，没错就是我。手动捂脸。在知道了原因之后，那么如何才能解决呢？我们需要5秒后在一次执行，对就是这个需求，那么自然就是在timer中调用自身啊。笨蛋。正确代码:startReportHeart() {\r\n     var timerTem = setTimeout(function () {\r\n         that.heartReport();\r\n         that.startReportHeart()\r\n     }, app.globalConfig.heart_delay)\r\n     // 保存定时器name\r\n      that.setData({\r\n            timer: timerTem\r\n     })\r\n },就这样完美。总结有的时候，遇到的坑真的很想打自己一巴掌，但是解决坑的过程，并发现自己的愚蠢却是一件非常开心的事呢。这个过程也是十分的funning呢。小程序开发刚开始一周时间，是的，一周上手，一点一点，现在越来越顺手，虽然写的东西比较low，但是再一次印证了那句话，只有实践才是最好的学习方式。不要找什么从入门到精通，你会发现，这些都会让你从入门到放弃。此致，敬礼转载请注明出处：http://www.cnblogs.com/numen-fan/"}
{"title": "小程序实战踩坑之B2B商城项目总结 ", "author": "Rolan", "pub_time": "2018-12-25 00:24", "content": "坑一：支付完成页面，点击“完成” 按钮会触发返回的页面的onShow()生命周期 (秘坑)如下图，原以为是微信的页面，不会影响到小程序，实际情况下是会触发返回的页面的onShow()的。触发bug业务场景详细描述：因为业务需要，我会在下订单页面触发 onShow()，在onShow里面会有调取查询购物车的商品数据，如果商品数据不存在，就会跳转到首页。当用户支付完成后，返回下订单页面，触发onShow生命周期，导致调取查询购物车api，因为已经创建订单去支付了，所以购车车的商品数据就在后台不存在了，所以在 跳过去支付成功页面的那一刻，页面闪了下，异步api在执行，又立刻跳回页面首页。解决方法：               self.cancelOnShow = true;\r\n                self.$apply();\r\n                wx.requestPayment({\r\n                    'timeStamp': d.timeStamp,\r\n                    'nonceStr': d.nonceStr,\r\n                    'package': d.package,\r\n                    'signType': d.signType,\r\n                    'paySign': d.paySign,\r\n                    'success': function(res) {\r\n                        console.log(res, '微信支付成功返回');\r\n                        wx.setStorageSync(\"isSucPay\", true);\r\n                        wx.setStorageSync(\"orderCode\", orderCode);\r\n                        wx.navigateTo({\r\n                            url: './paymentnote',\r\n                            complete:function(){\r\n                                self.cancelOnShow = false;\r\n                            }\r\n                        })\r\n                    },\r\n                    'fail': function(res) {\r\n                        console.log(res, '微信支付失败返回');\r\n                        wx.setStorageSync(\"isSucPay\", false);\r\n                        wx.setStorageSync(\"repayParams\",{amount:balance,invoiceid:orderCode});\r\n                        wx.navigateTo({\r\n                            url: './paymentnote',\r\n                            complete:function(){\r\n                                self.cancelOnShow = false;\r\n                            }\r\n                        })\r\n                    }\r\n                });onsShow(){\r\n    if(!this.cancelOnShow)\r\n    {\r\n        //业务代码******\r\n    }\r\n}主要是在调取支付前，通过设置 cancelOnShow 为true，然后在跳转 支付成功（失败）页面的complete回调函数，将设置cancelOnShow为false，不影响其他下次支付。有人问，将self.cancelOnShow = false;放在wx.requestPayment的 success 回调函数，在wx.navigateTo跳转之前，是否可行？我自身测试过，是不行的，原因自身体会去。其次，在onShow生命周期函数，要根据cancelOnShow来判断执行业务代码。坑二：多个倒计时重碟问题问题描述： 在一个页面如果用倒计时，如果切换到其他页面返回，会看到多个倒计时在错误重碟显示。解决代码如下：  /**\r\n     * 清除interval\r\n    * @param that\r\n    */\r\n   clearTimeInterval: function (that) {\r\n      var interval = that.data.interval;\r\n      clearInterval(interval)\r\n    },\r\n   \r\n   /**\r\n     * 生命周期函数--监听页面卸载\r\n     * 退出本页面时停止计时器\r\n    */\r\n   onUnload:function () {\r\n        var that = this;\r\n        that.clearTimeInterval(that)\r\n   },\r\n \r\n   /**\r\n     * 生命周期函数--监听页面隐藏\r\n     * 在后台运行时停止计时器\r\n    */\r\n   onHide:function () {\r\n        var that = this;\r\n        that.clearTimeInterval(that)\r\n   }在tab页面，运用 onHide 周期 进行 clearTimeInterval , 在 非tab页面，运用onUload() 周期 进行 clearTimeInterval。坑三：swiper的swiper-item变动，导致显示异常swiper 要根据地区选择不同的内容（swiper-item）播放动画，当切换 地区的时候，我的 swiper-item 个数也在变化， 但是原 swiper 的 current 还是之前的，比如切换2张变1张数据的时候，就会 导致swiper 不显示。解决方法和代码：坑四：微信二次授权无法再次获取授权问题获取个人地址授权，点击取消，再去获取，无反应，这个不算bug，但是可以总结下，这块是属于 微信二次授权问题，百度也可以找到相关，代码如下：通过 wx.openSetting 打开授权过的 权利，再次打开，在回调中，在执行你想要的业务逻辑即可。坑五：倒计时显示卡顿倒计时在触摸状态拖住不放的情况下，会发现有倒计时停止了，也就是所谓的卡顿，放开，或者随便动下页面又正常（而且时间恢复得特别快），暂时未找到解决方案，有知悉的同学麻烦告知。下面是我组队员志新同学总结的一些UI展示的坑位：坑六：button标签需清除默认的样式小程序button标签默认的样式不符合我们的设计稿，会出现一些比较丑的border，background等。去除button border线条button::after {\r\n\r\n  border: 0;\r\n\r\n}去除button背景色button{\r\nbackground:none !important;\r\n}坑七：行高不够被截头小程序的标签貌似没有写 默认行高是多少。不过根据截图文本可以发现文本的蓝色底色范围框会比文本内容高一些。如果担心这些蓝色的范围影响了一些设计稿的边距 ，想要收一收它的占位间隙，那么可以将视图内的文本行高设置为 1.1~1.3之间。为什么我不推荐直接设置为行高 1 呢？ 因为行高为1的话，在部分安卓机器上面有坑，会出现文字 头部 一些 笔画被 截取没了，出现貌似被砍头的效果!view，text{\r\n    line-height:（1.1 或者 1.3 ）  可以适当的收一收它默认行高的一些间隙；\r\n}被截头就如下面的图片：坑八：微信小程序通过background-image设置背景：只支持线上图片和base64图片，不支持本地图片坑九：小程序input需要调整聚焦的时候输入框和键盘的距离，增加体验感！cursor-spacingNumber 指定光标与键盘的距离，单位px（2.4.0起支持rpx）。取 input 距离底部的距离和 cursor-spacing 指定的距离的最小值作为光标与键盘的距离<input type=\"text\" cursor-spacing=\"70\" placeholder=\"请输入具体的营业地址\">坑十：textarea层级穿透（独家秘坑）小程序的textarea 里 placeholder提示不知道为什么，存在一个非常高的层级，平时布局放着还好，要是和一个自己写的弹出层展示，就会发现 textarea的层级比你自己写的弹出层层级还要高，导致结构穿透，紊乱。不管你自己定义的弹出层层级有多高，textarea依然会把它穿透！解决办法：障眼法，在textarea同级在写一个view 仿textarea的样式，当你的弹出层 弹出的时候，把这个真实的 textarea先hidden起来，（注意不要用 wx：if因为display：none会把之前输入的备注内容消息又清没了）。然后把那个高仿的textarea显示出来。当弹出层消失的时候，就把高仿的textarea隐藏，真实的textarea显示出来。"}
{"title": "一诞小程序总结 ", "author": "Rolan", "pub_time": "2019-1-2 14:48", "content": "介绍一诞是一款基于腾讯云的人脸识别、五官定位的圣诞主题小程序。开始做它的初衷是为了简化用户操作，与其他手动添加帽子的小程序形成差别，所见即所得。但是在开发的适合遇到了一些问题，没有完美的方案来根据五官定位API返回的坐标点来准确的给人物戴上帽子。最后无奈之下就加入了圣诞贺卡的功能，弱化了生成头像的功能。小程序全部功能使用云开发，大大减少了一个人的工作量。贺卡功能介绍贺卡是我在初中、小学的时候，圣诞最常送的礼物。小程序的转发恰好是赠送贺卡的最好入口，再加上一些抖音的模式。每个用户转发赠送的贺卡内容都会上传（这里忘记征求用户同意），在主页就可以使用摇一摇的方式来查看下一条贺卡内容，并且可以点赞。五官定位戴帽子五官定位使用的是腾讯云的API，它可以返回五官的坐标，了解更多。这里使用云函数可以快速的拿到返回参数，将坐标点绘制在画布上。安装依赖1npm i --save image-node-sdk云函数调用五官定位API12345678910111213141516171819202122232425// 云函数入口文件const cloud = require('wx-server-sdk')const {ImageClient} = require('image-node-sdk');let AppId = ''; // 腾讯云 AppIdlet SecretId = ''; // 腾讯云 SecretIdlet SecretKey = ''; // 腾讯云 SecretKeyconst imgClient = new ImageClient({  AppId,  SecretId,  SecretKey});cloud.init()// 云函数入口函数exports.main = async(event, context) => {  const url = event.url;  const result = await imgClient.faceShape({    data: {      appid: AppId,      mode: 1,      url,    },  });  return JSON.parse(result.body);}接下来就是根据坐标来准确戴帽子了，但是我能力有限，没有一套比较好的方案，只有在正脸情况下能够准确戴上帽子。帽子也是根据坐标点画出来的，非提前画好的图。如果你有好的想法欢迎联系我（WeChat：tysb7_)总结这款小程序初衷是为了学习使用腾讯云人脸识别API，定位是为了蹭热度。但是时间、推广和能力的原因没能打造成一个爆款。不过在从中收获了许多东西，源码已经上传至GitHub，欢迎大家一起来维护。GitHub: 本文项目仓库WeChat: tysb7_blog: www.tysb7.cnEmail: terry@qiaokr.comSSl: 环洋诚信™"}
{"title": "微信小程序练手 demo 之天气小程序总结(流水账) ", "author": "Rolan", "pub_time": "2019-1-9 00:32", "content": "想大致了解微信小程序的基础结构，加上之前没有写过 MVVM 结构，也借此了解一下，由于之前写过天气的 demo，这次也用比较熟悉的天气预报作为实现的功能，所使用的接口是和风天气，利用到的 API 有 实况天气， 多日天气预报， 逐小时天气预报， 生活指数， 当然实际上还有空气质量、历史天气等其他数据，此处使用几个作为展示。微信小程序开发之前需要注册微信公众平台，在 微信小程序 · 简易教程 处有详细的步骤，注册完下载微信开发者工具，填写申请完开发者账号以后的 AppID(在 mp.weixin.com 开发 -> 开发设置 中查看)，然后直接选择 创建 QuickStart 项目 (刚开始没看清楚选成云开发了，后来才发现跟教程的不太对，之后再接触云开发吧……)，然后到以下的图片界面：每个页面的结构基本由 xx.js xx.wxml xx.wxss xx.json 构成，类似 HTML + CSS + JavaScript，自己体会与后者不同的是：wxml 类似于 HTML，但是小程序规定了所能使用的组件(构成页面的基本单位)，有 view ，button，web-view等等，此外还使用自定义组件，自定义组件需要在 json 文件中先声明，再写 wxml 模板，js 中注册，详细步骤在 微信小程序 · 自定义组件。在写这个天气 demo 时只用到了小程序提供的基础组件，自定义组件还需要进一步了解，wxss 类似于 CSS，只是在选择器中做了很多限制，例如子选择器a > b，后代选择器a b，是不可用的，提倡直接使用 .classjs 与 JavaScript 类似，只是执行环境不同，不需要像浏览器端，写document window等内置对象，语法是相似的，只要稍微熟悉一下就可以了json 配置页面功能，如果写过 Chrome 的扩展的话，应该很熟悉了，就跟manifest.json类似，小程序里可以配置权限，是否全局开启下拉刷新，是否禁止上下滚动等等大致看了一遍文档以后，开始以 quickstart 项目为模板写上自己的代码，页面布局如下：于是以上面的结构分好各块代码，每块使用一个 view包括，内部按内容再细分，其中，每小时天气预报与多日天气预报由于信息过多，采用 scroll-view 展示，以滑动的形式浏览全部数据。实况天气中数据不是很多，直接的分块的 view中把各个组件写上，并写上对应的数据绑定变量，每小时、多日、生活指数中，由于是多个类似的数据，采用 view wx:for的形式，获取数据后循环渲染。样式的部分，每小时、多日天气预报的样式使用 item { flex: 1 }使每一小块均匀分布，生活指数分两列显示，容器 flex 布局，flex-wrap 设置为 wrap，给每个 item 设置 { width: 50%; }。然后就是编写 js，在进入小程序以后，首先利用微信的请求定位，获取到对应的经纬度，再通过 腾讯位置服务 转换为具体的地理位置显示，再把获取到的地理位置作为参数向和风天气发出请求，得到响应以后获得响应的数据，其中一部分数据需要经过处理简化，然后保存到 page.data，同时视图层渲染对应的数据获取到的天气数据中，日期是包含年份的，通常看天气的信息有月日即可，于是在获得响应的数据以后先对日期的部分进行处理：for (let i = 0; i < he.daily_forecast.length; i++) { // 去掉日期中的年份\r\n            res.data.daily_forecast[i].date = res.data.daily_forecast[i].date.slice(5)\r\n}然后再进行 setData 操作在大致基本功能完成后，实况天气的上方新加了一个 input，用于手动输入城市查询那个城市的天气，手动输入查询的城市不经过微信定位，直接把输入的内容作为参数向天气接口查询，成功则显示对应的城市及具体的天气，如果查询的城市有误，则弹出 toast 提示查询失败。在手动查询城市天气完以后，清空 input 的内容，因此需要在 input 的组件中加上 value={{inputValue}}，查询完以后把 page.data.inputValue 值置为空。另外，在真机体验时发现如果网络不好，会加载得很慢，等待时间会很长，数据一直显示不了，于是在进入小程序时先加载一个 loading，在请求成功时去掉 loading，优化用户体验。添加了下拉刷新，首先在 json 中设置 \"enablePullDownRefresh\": true，然后在 js 中写对应的函数即可onPullDownRefresh: function() { \r\n    getWeather()\r\n}关于腾讯位置服务的使用，首先下载相关的 js sdk，然后在微信公众平台的开发设置中设置 request 合法域名，添加 https://apis.map.qq.com(同样地，所用到的天气 API 的地址也是如此)，然后引入 js sdk 并实例化就可以使用了// 引入SDK核心类\r\nvar QQMapWX = require('../../libs/qqmap-wx-jssdk.js');\r\nPage({\r\n    onLoad: function () {\r\n            // 实例化API核心类\r\n            qqmapsdk = new QQMapWX({\r\n                key: '申请的key'\r\n            });\r\n        },\r\n    onShow: function () {\r\n            qqmapsdk...\r\n    }\r\n})整个小程序 demo 的过程中，没遇到太大的困难，大概也是因为写的是比较简单的练手项目而已，很多小程序的功能还没用到，例如多个页面之间的数据传递，路由，插件等等，还需要进一步学习。另外，微信开发者工具有时候会出现打不了中文的情况，搜了一下是个常见的 bug，需要重启微信开发者工具。调试工具中无法查看伪元素样式也有点不方便，希望之后微信开发者工具能改进这方面，这样的话体验能够能好。另外附上我的微信小程序 demo，可以扫码体验一下(图标自己瞎画的晴天娃娃)，由于还需要优化，体验不佳的话还请谅解"}
{"title": "微信小程序 - 富文本图片宽度自适应 ", "author": "Rolan", "pub_time": "2019-1-17 00:42", "content": "引言：在微信小程序里，比如商品展示页面的商品详情会有图片展示，PC端设置的商品详情是PC端的宽度，所以在小程序里图片会显示不全，这时就应该做相应的处理，使小程序里图片显示正确\r\n\r\n思路\r\n把图片的宽度改为手机屏幕对应的宽度\r\n微信小程序需要知道的知识\r\n需要知道微信小程序里有自己的宽度标准，单位为rpx；\r\n针对所有不同尺寸的浏览器，微信小程序里规定屏幕宽为750rpx；\r\n解决\r\nWXML\r\n<view class='html_detail'>\r\n    <rich-text nodes='{{artical}}'></rich-text>\r\n</view>\r\n复制代码WXS\r\ndata={artical:''}\r\n\r\nasync onLoad(){\r\n    const json = await api.getDetail();\r\n    if(json !== null){\r\n        this.artical = util.formatRichText(json.detail.description);\r\n    }\r\n}\r\n复制代码若artical里只有图片，并且图片没有设置style和宽度/高度\r\nutil.js\r\nfunction formatRichText(html){\r\n    let newContent= html.replace(/\\<img/gi, '<img style=\"max-width:100%;height:auto;display:block;\"');\r\n    return newContent;\r\n}\r\n\r\nmodule.exports = {\r\n    formatRichText\r\n}\r\n复制代码若artical里包含多种标签\r\nutil.js\r\n/**\r\n * 处理富文本里的图片宽度自适应\r\n * 1.去掉img标签里的style、width、height属性\r\n * 2.img标签添加style属性：max-width:100%;height:auto\r\n * 3.修改所有style里的width属性为max-width:100%\r\n * 4.去掉<br/>标签\r\n * @param html\r\n * @returns {void|string|*}\r\n */\r\nfunction formatRichText(html){\r\n    let newContent= html.replace(/<img[^>]*>/gi,function(match,capture){\r\n        match = match.replace(/style=\"[^\"]+\"/gi, '').replace(/style='[^']+'/gi, '');\r\n        match = match.replace(/width=\"[^\"]+\"/gi, '').replace(/width='[^']+'/gi, '');\r\n        match = match.replace(/height=\"[^\"]+\"/gi, '').replace(/height='[^']+'/gi, '');\r\n        return match;\r\n    });\r\n    newContent = newContent.replace(/style=\"[^\"]+\"/gi,function(match,capture){\r\n        match = match.replace(/width:[^;]+;/gi, 'max-width:100%;').replace(/width:[^;]+;/gi, 'max-width:100%;');\r\n        return match;\r\n    });\r\n    newContent = newContent.replace(/<br[^>]*\\/>/gi, '');\r\n    newContent = newContent.replace(/\\<img/gi, '<img style=\"max-width:100%;height:auto;display:block;margin-top:0;margin-bottom:0;\"');\r\n    return newContent;\r\n}\r\n\r\nmodule.exports = {\r\n    formatRichText\r\n}"}
{"title": "微信小程序点击列表添加 去除属性 ", "author": "Rolan", "pub_time": "2019-1-30 00:42", "content": "首先说一下场景：我所循环的数据是对象数组，设置了一个属性当作标记，通过这个标记的值判断是否给改元素添加样式wxml：<view>\r\n      <view wx:for=\"{{list}}\" wx:key=\"num\" class=\"list\" >\r\n        <text bindtap='changColor'  data-index='{{index}}' class='{{item.check?\"text-active\":\"\"}}' >| {{item.message}}</text>\r\n      </view>\r\n</view>js：/*　　这里获取list是一个数组对象　　tomorrow: [　　　　{　　　　　　thing: '吃饭',　　　　　　check: false　　　　},　　　　{　　　　　　thing: '睡觉',　　　　　　check: false　　　　},　　　　{　　　　　　　thing: '打豆豆',　　　　　　check: false　　　　}　　]*/changColor: function (e) {\r\n    let index = e.currentTarget.dataset.index\r\n    let arrs = this.data.list;  \r\n    if (arrs[index].check == false) {\r\n      arrs[index].check = true;\r\n    } else {\r\n      arrs[index].check = false;\r\n    }\r\n    this.setData({\r\n      list: arrs\r\n    })\r\n  },核心在于修改对象属性check的值，然后在元素渲染是根据值进行样式的添加"}
{"title": "微信更新小程序“桌面式”入口，生态竞争愈发激烈 ", "author": "Rolan", "pub_time": "2019-1-31 00:01", "content": "2019年1月9日-10日，一年一度的微信公开课PRO在广州保利博览馆举行，微信官方在现场公布了小 程序 的最新数据：2018年，微信小程序开发者增加了80%，微信小程序人均周使用的次数增长72%、涵盖200+行业，创造了5000亿+商业价值，服务1000亿+人次，交易金额增长超过6倍，小程序已经深入到了我们生活的方方面面。2019年1月31日，阿拉丁小程序统计平台（aldwx.com）和阿拉丁指数（aldzs.com）共同发布了2019年1月小程序TOP100榜单和1月热点事件盘点。从榜单中我们不难发现，1月小程序生态继续保持健康快速发展，阿拉丁小程序平台创始人&CEO史文禄也对此表示：“‘我的小程序’桌面式入口更新后，给了小程序更多曝光的机会，也会进一步培养用户的认知和使用习惯，用户会慢慢养成从这里获取信息和服务的习惯，小程序的留存必然会得到提高。而且，这也会给中长尾的小程序更多被使用的机会，以此活跃整个小程序池子拉高绝对值。从1月榜单中可以看出视频类小程序快速兴起，用户在小程序中观看短视频的习惯逐步养成，同时有更多的细分行业出现在榜单中，小程序行业分布日趋多元化。”l 微信更新小程序“桌面式”入口1月份微信又做了一次重要更新，在本次发布的7.0.3版本中对首页“小程序下拉菜单栏”进行升级，由之前的下拉后显示“最近使用的小程序”和“我的小程序”两行，变成类似手机系统的全屏展示“我的小程序”则最多可展示50个小程序。对于这次更新，阿拉丁小程序平台创始人&CEO史文禄表示：这标志着小程序的发展进入第三阶段，会推动小程序爆发增长，未来3个月也会推动整个行业的发展，小程序作为一种新的形式，可能承载用户未来五年甚至十年获取信息和服务的场景。它会进一步打通微信的账号体系，连接公众号、支付等服务形成的闭环，而且会建立更强的壁垒和门槛。l 微信小游戏升级未成年人保护能力微信小游戏团队正式升级未成年人保护能力，与腾讯成长守护平台共建“成长守护”体系。小游戏全面接入“成长守护平台”之后，家长可以及时了解到未成年人游戏及消费动态。这一能力将为许多家庭提供有效的游戏行为管理手段和亲子沟通途径。l 微信公众平台小程序信息里现「小程序简称」项开发者可登录微信公众平台小程序-> 设置-> 基本信息-> 小程序简称-> 修改-> 通过管理员扫码验证后即可进入修改页面。小程序发布前有2 次修改机会，发布后仍有一年2 次的修改机会。开发者通过编辑简称，便于用户记忆和识别小程序，有利于用户更顺畅的触达小程序。l 支付宝小程序能力释放1月7日，支付宝宣布在首页腰封位置新增小程序收藏固定入口。用户只要下拉支付宝首页，就能唤出小程序收藏栏，直接启用收藏的小程序服务，以及支付宝小程序支持小程序互相跳转和5项运营推广工具：收藏后专享、推广助手、收藏有礼、分享有礼、会员有礼。本月支付宝赋能小程序动作不断，主要集中在扶持小程序运营者推广能力以及使用户触达小程序的入口更浅。l 阿拉丁1月TOP100榜单发布①1月，由于春运来临，购买火车票类小程序用户量都出现大幅增长，如智行火车票进入榜单前十，携程、高铁管家等也出现大幅增长。②1月上榜的小程序行业分布进一步均衡，TOP100榜单中游戏与网络购物、生活服务小程序的数量占比差距缩小。③视频类小程序快速兴起，用户在小程序中观看短视频的习惯逐步养成。④随着春节的到来，网络购物类小程序将逐步回落，游戏、视频、社交等小程序有望迎来又一轮 高峰 。l 榜单更新率保持在30%以上1月TOP100榜单的更新率为32%，头部小程序继续保持较高的更新速度。新上榜的小程序中游戏数量最高为14个，另外视频类小程序有5个为新上榜。相比12月掉榜的小程序中游戏数量也最多，达到22个。大部分小游戏依然难以持续保持较高的用户访问，用户在小游戏中迁移速度较快，因此小游戏开发者需要加大产品创意，增加小游戏的耐玩度，从而提升用户粘性。除此以外，本次内容发布中还包括2019年1月小程序融资事件，1月网络购物类小程序融资金额仍占据首位，社区团购小程序“邻邻壹”获得3000万美元融资。而服务商“即速应用”和军事内容资讯小程序“军武次位面”也分别获得5000万人民币融资。2018年，微信创造就业岗位超2200万个，其中小程序拉动就业超过180万，较去年增长近80%。随着微信生态日益壮大，围绕小程序、公众平台、企业微信、微信支付聚集了大量开发者、运营者、服务商等生态合作伙伴。未来，阿拉丁小程序统计平台（aldwx.com）和阿拉丁指数（aldzs.com）将会持续开展小程序榜单的综合发展指数研究，从定量的角度勾画出小程序的发展图景，全面展现小程序的现在和未来、常态和创新，推动和引领小程序生态的健康发展。"}
{"title": "微信小程序如何调用后台service的简单记录 ", "author": "Rolan", "pub_time": "2019-1-31 00:24", "content": "写在前头，本篇文章简单记录一下，在前后端分离的微信小程序应用中，前端访问后台service的实现思路，没有过多涉及技术实现方面。先上一张官网的图片，它很清楚的讲明了要在后台service为每一个小程序用户提供登录信息需要做哪些事情。用户拿到了后台给的登录凭据，访问后台service。静默授权与非静默授权先来讲讲这两个概念， 静默授权，顾名思义，这授权动作对于用户来说是感知不到的， 小程序端悄咪咪得就做了。因此，没有知会用户的授权方式拿到的信息也是不太重要的。但是，静默授权是开始重要的一步，因为它为接下来的动作提供了code。调用静默授权可用小程序提供的 API:wx.login() 。再来讲讲 非静默授权，顾名思义，它的授权是要有明显动静的，而且它是要得到用户认可才可以执行。 API:wx.getUserInfo() ，这个接口要不要用可根据小程序的实际需求来。后台获取openId小程序提供了一个接口 code2session ，拿着我们静默授权获取到的临时登录凭证code再调用一下这个接口就能获取到openId了。注意，这一步是在后台服务器做的。openId是在当前小程序中对用户唯一性的标识。基于OAuth2.0生成token在后台，可以用SpringSecurity的OAuth2.0这一个工具，用openId来生成前端请求后端数据的附带校验信息token。具体是如何实现的笔者也没有深入了解……获取到了这个token后，前端可将其存入webStorage中，每一次调用后台service的时候，就可以利用请求的拦截器在config参数中加入token。后端就可以确定发送请求的用户身份，保证了系统的安全性。总结：以上大致描绘了小程序后台自定义登录态的开发思路。"}
{"title": "微信小程序使用async/await语法 ", "author": "Rolan", "pub_time": "2019-2-11 00:01", "content": "1.在微信小程序项目添加package.json文件或者直接npm init.2.在package.json中添加regenerator包和版本`\"devDependencies\": {\"regenerator\":\"0.13.3\"}`3.微信开发者工具-》工具-》npm构建4.在需要使用async/await语法的文件引入regeneratorRuntimeconst regeneratorRuntime = require('regenerator-runtime')5.使用async/await语法lifetimes: {\r\n    attached:async function(){\r\n      // 在组件实例进入页面节点树时执行\r\n     let data= await req(this.properties.apiType);\r\n     console.log(data)\r\n    },\r\n    detached() {\r\n      // 在组件实例被从页面节点树移除时执行\r\n    },\r\n  },需要注意this的指向，比如生命周期如果用箭头函数会丢失this或者直接这样lifetimes: {\r\n    async attached(){\r\n      // 在组件实例进入页面节点树时执行\r\n     let data= await req(this.properties.apiType);\r\n     console.log(data)\r\n    },\r\n    async detached() {\r\n      // 在组件实例被从页面节点树移除时执行\r\n     \r\n    },\r\n  },"}
{"title": "口袋工具之历史上的今天 - 小程序云开发实战 ", "author": "Rolan", "pub_time": "2019-2-11 00:25", "content": "本项目是一个基于云开发的小程序。本文选取项目中的一个页面 -- 历史上的今天 来做一个云开发的分享，会涉及云函数和云数据库。由于是实战项目，关于小程序的基础知识请移步官方文档，本文不再赘述。项目地址github.com/GoKu-gaga/t…项目预览微信搜索： 口袋工具y扫一扫：前期遇到的问题数据来源： 没有数据，寸步难行呀如何解决数据来源编写爬虫将需要的数据爬取并保存下来找一些提供数据的平台，如阿凡达数据、聚合数据等等。由于本人偷懒，所以选择第二种方式，并最终选择了聚合数据平台API。项目开始新建项目新建项目，配置好名称、目录、AppID等信息，后端服务选择 小程序·云开发 ，点击新建。关于AppID: 请自行修改为你注册的小程序AppID。点击新建即可完成项目初始化，得到一个云开发模板：目录结构：+-- cloudfunctions|[指定的环境]  // 存放云函数的目录\r\n  +-- miniprogram                 // 小程序代码编写目录\r\n  |-- README.md                   // 项目描述文件\r\n  |-- project.config.json         // 项目配置文件\r\n复制代码新建云开发环境点击左上角菜单项 云开发点击创建资源环境，环境名称及环境ID请自行设置：点击确定即可完成创建编写云函数1. 新建云函数在目录 cloudfunctions 上右键新建云函数，填入新建云函数的名称（如 todayInHistory ）回车或失去焦点即会自动创建并上传。2. 安装依赖云函数目前执行环境仅支持node，所以需要使用js来编写云函数的逻辑。 在控制台中进入该云函数的目录，执行npm i -S axios\r\n复制代码本项目使用 axios 来执行请求的发送，可以使用其他如 request-promise 等等的库来替换3. 编写云函数新建 config.js 文件，添加代码如下：exports.key = YOUR_JUHE_KEY // 在聚合数据平台申请的key\r\nexports.baseUrl = 'http://v.juhe.cn/todayOnhistory/queryEvent.php'\r\n复制代码打开 index.js 文件，编写代码：// 云函数入口文件\r\nconst cloud = require('wx-server-sdk')\r\nconst axios = require('axios')\r\n\r\ncloud.init()\r\nconst db = cloud.database()\r\n\r\n// 聚合数据\r\nconst { baseUrl, key } = require('./config')\r\n\r\n// 云函数入口函数\r\nexports.main = async(event, context) => {\r\n  const {\r\n    month,\r\n    day\r\n  } = event\r\n \r\n  const resp = await axios.get(baseUrl, {\r\n    params: {\r\n      key,\r\n      date: `${month}/${day}`\r\n    }\r\n  }).then(res => {\r\n    return res.data\r\n  })\r\n\r\n  return resp.result\r\n}\r\n复制代码编写页面1. 新建页面在开发小程序的过程中，新建一个页面是很常见的操作，有两个非常方便的方式在 app.json 文件中，在pages项添加我们需要的页面路径，直接保存即可。如：\"pages\": [\r\n  \"pages/today-in-history/index\"\r\n]\r\n复制代码在 pages 目录下新建目录 today-in-history ，在新建的目录上右键 -> 新建page， 填入名称如 index , 回车即可完成页面下四个文件的创建2. 编写 index.wxml<!--pages/today-in-history/index.wxml-->\r\n<view class=\"container\">\r\n  <view class=\"header full-width\">\r\n    <view>{{year}}年{{month}}月{{day}}日</view>\r\n  </view>\r\n  <view class=\"content full-width\">\r\n    <view class=\"list-view\">\r\n      <block wx:for=\"{{list}}\" wx:key=\"index\">\r\n        <navigator url=\"{{'/pages/history-detail/index?id=' + item.e_id}}\" class=\"list-item\">\r\n          <view class=\"item-title\">{{item.title}}</view>\r\n          <view class=\"item-date\">{{item.date}}</view>\r\n        </navigator>\r\n      </block>\r\n    </view>\r\n  </view>\r\n</view>\r\n复制代码3. 编写 index.js// pages/today-in-history/index.js\r\nPage({\r\n\r\n  /**\r\n   * 页面的初始数据\r\n   */\r\n  data: {\r\n    year: 1990,\r\n    month: 1,\r\n    day: 1,\r\n    list: []\r\n  },\r\n\r\n  /**\r\n   * 生命周期函数--监听页面加载\r\n   */\r\n  onLoad: function() {\r\n    const now = new Date();\r\n    const year = now.getFullYear();\r\n    const month = now.getMonth() + 1;\r\n    const day = now.getDate();\r\n    this.setData({\r\n      year,\r\n      month,\r\n      day\r\n    });\r\n    this.doGetList();\r\n  },\r\n\r\n  /**\r\n   * 执行数据获取\r\n   */\r\n  doGetList: function() {\r\n    const {\r\n      month,\r\n      day\r\n    } = this.data;\r\n    wx.cloud.callFunction({\r\n        name: 'todayInHistory',\r\n        data: {\r\n          month,\r\n          day\r\n        }\r\n      }).then(res => {\r\n        let list = res.result.reverse();\r\n        this.setData({\r\n          list\r\n        });\r\n      })\r\n      .catch(console.error)\r\n  }\r\n})\r\n复制代码4. 编写 index.wxss/* pages/today-in-history/index.wxss */\r\n.container {\r\n  padding-bottom: 20rpx;\r\n  background-color: #E8D3A9;\r\n}\r\n\r\n.header {\r\n  display: flex;\r\n  justify-content: space-around;\r\n  align-items: center;\r\n  height: 80rpx;\r\n  color: #FFF;\r\n}\r\n\r\n.content {\r\n  flex: 1;\r\n}\r\n\r\n.list-view {\r\n  height: 100%;\r\n  display: flex;\r\n  flex-direction: column;\r\n  padding: 0 20rpx;\r\n}\r\n\r\n.list-item {\r\n  display: flex;\r\n  flex-direction: column;\r\n  border-radius: 10rpx;\r\n  padding: 16rpx 0;\r\n  box-sizing: border-box;\r\n  margin-top: 20rpx;\r\n  background-color: #fff;\r\n  text-align: center;\r\n  box-shadow: 1px 1px 5px 1px rgb(207, 207, 207);\r\n}\r\n\r\n.item-title {\r\n  font-size: 36rpx;\r\n  padding: 10rpx 16rpx;\r\n  color: #262626;\r\n  line-height: 48rpx;\r\n}\r\n\r\n.item-date {\r\n  font-size: 24rpx;\r\n  height: 30rpx;\r\n  line-height: 30rpx;\r\n  border-top: 2rpx solid #eee;\r\n  padding: 10rpx 16rpx 0;\r\n  color: #595959;\r\n  margin-top: 6rpx;\r\n}\r\n复制代码补充项目中也使用了部分的有赞的小程序组件库vant-weapp由于聚合数据平台API非会员调用次数有限（100次/天），明显是不太够用的。因此，我们可以考虑在请求到数据时，将数据存在云数据库中，其实也就实现了一个类似爬虫的功能啦。流程如下：代码实现：修改 cloudfunctions/todayInHistory/index.js// ... 省略其他无需改动的代码\r\nexports.main = async(event, context) => {\r\n  const {\r\n    month,\r\n    day\r\n  } = event\r\n\r\n  const ret = await db.collection('todayInHistory').where({\r\n    date: `${month}/${day}`\r\n  }).get()\r\n\r\n  if (ret.data.length > 0) {\r\n    return ret.data[0].result\r\n  }\r\n\r\n  const resp = await axios.get(baseUrl, {\r\n    params: {\r\n      key,\r\n      date: `${month}/${day}`\r\n    }\r\n  }).then(res => {\r\n    return res.data\r\n  })\r\n  \r\n  await db.collection('todayInHistory').add({\r\n    data: {\r\n      date: `${month}/${day}`,\r\n      result: resp.result\r\n    }\r\n  })\r\n\r\n  return resp.result\r\n}\r\n复制代码以上即为 历史上的今天 页面的数据获取及展示，其他页面使用到云开发的模式基本大同小异。结语目前只开发了两个小功能 历史上的今天 和 周公解梦 ，后续会继续开发新的功能，希望可以做成一个小工具集合，这也是 口袋工具 这个名称的由来。感谢各位读者的阅读，由于本人水平有限，文章中如有错误或不妥之处，请不吝赐教！如果你喜欢这篇文章或是这个项目，不妨进去点个Star支持下 today 。"}
{"title": "小程序页面动态配置实现 ", "author": "Rolan", "pub_time": "2019-2-11 11:04", "content": "小程序可以根据管理后台配置动态更新展示内容，如实现下面新鲜事栏目图片的来源的可配置，点击跳转url的可配置。实现方案1后端创建一个map结构的数据表，表结构如下：2 管理后台根据不同业务设定不同的key和value，更新数据库如key：ad1url value：a.png如果需要更新页面图片，只需更新ad1url对应的value3 小程序根据对应业务key获取对应的配置项，更新页面显示技术栈后端接口服务：SpringBoot Mybatis MySql管理后台：vue前端：小程序代码实现后端接口为了保证key的唯一性，key在数据库设置为unique属性，新增和更新功能通过以下sql语句实现，主要通过replace into实现配置项的唯一@Insert(\"<script>\"  +\r\n         \"REPLACE INTO `rental`.`t_config`(`key`, `value`) VALUES\" +\r\n         \"<foreach\" +\r\n         \" collection=\\\"list\\\" item=\\\"item1\\\" index=\\\"index\\\"  separator=\\\",\\\">\" +\r\n         \"(#{item1.key}, #{item1.value})\" +\r\n         \"</foreach>\" +\r\n       \"</script>\")\r\n @Options(useGeneratedKeys = true, keyProperty = \"configId\", keyColumn = \"configId\")\r\n复制代码api设计一开始想通过传如list数据给后端实现配置项的批量插入功能，发现后端数据一直接受不到，故而退而求其次，通过json字符串实现vue（网络库使用axios）调用后端接口@ApiOperation(value = \"新增或更新配置列表\")\r\n@RequestMapping(value = \"/add_or_update_config_list\", method = RequestMethod.POST, \r\n                produces =    MediaType.APPLICATION_JSON_UTF8_VALUE)\r\npublic ResponseBean<String> addOrUpdateConfigList(String list) {\r\n    long result =  configService.batchInsertOrUpdate(JSONObject.parseArray(\r\n        list,Config.class));\r\n    ......\r\n}\r\n复制代码管理平台管理平台用vue开发，网络框架采用axios，列表数据通过json字符串传递给后端let config1 = {key: \"ad1Url\", value: this.formData.ad1Url};\r\nlet config2 = {key: \"ad2Url\", value: this.formData.ad2Url};\r\nlet config3 = {key: \"adClick1\", value: this.formData.adClick1};\r\nlet config4 = {key: \"adClick2\", value: this.formData.adClick2};\r\nlet configList = [config1, config2, config3, config4];\r\nlet result = await addConfigList({list: JSON.stringify(co\r\nnfigList)});\r\n......\r\n复制代码小程序小程序调用后端接口返回所有配置项，具体业务根据具体业务key获取配置项getConfigList: function () {\r\n    var that = this;\r\n    wx.request({\r\n      url: constant.HOST + '/config/get_config_list',\r\n      method: 'GET',\r\n      header: {\r\n        'content-type': 'application/json'\r\n      },\r\n      complete: function (res) {\r\n  \r\n      },\r\n      success: function (res) {\r\n        console.log(\"config list response:\" + JSON.stringify(res));\r\n        that.setData({ configList: res.data.data});\r\n      }\r\n    });\r\n },\r\n     \r\ngoAd1: function(){\r\n    wx.navigateTo({\r\n      url: '/pages/webview/webview?url=' + this.data.configList.adClick1\r\n    })\r\n},\r\n\r\n复制代码总结这个功能我在自己的小程序开发过程中设计的页面配置实现思路，主要遇到了两个小问题：1 如果保证key的唯一性 2 前后端批量数据的传输问题；希望能给遇到同样问题的小伙伴一些启示，如果有更好的方案，欢迎一起讨论。"}
{"title": "微信小程序 TypeScript 尝试 ", "author": "Rolan", "pub_time": "2019-2-12 00:08", "content": "自从去年开始在项目里写了一段时间 Javascript 后，感觉没有类型检查的语言还是不太适合我，所以一直想尝试下 TypeScript，然而由于项目庞大，人员协作问题，一时半会没办法切成 TypeScript。正好最近有小程序的需求和小程序去年 11 月开始官方支持了 TypeScript，所以拿来练练手。\r\nWhy TypeScript？\r\n大概是我这半年写的 Swift 比较多，而 Swift 中的静态类型和协议是我很喜欢的特性。正好 TypeScript 为 JavaScript 带来了静态类型和接口。\r\n可选的静态类型\r\n“动态类型一时爽，代码重构火葬场“，对于我这种极度喜欢重（xia）构（gai）代码的人来说，JavaScript 毫无类型提示，类型全靠命名猜测是极度不友好的。而 TypeScript 加上了灵活的类型系统，不仅可以编码期检查，还能增强代码的可读性，并提供了 any 类型进行缓冲。\r\n接口\r\n接口和协议，只是不一样的叫法而已，Java、C#、TypeScript 叫 Interface，Swift、Kotlin 叫 Protocol，就是一种规则声明。项目中，和后端接口数据交互，页面传递数据，数据持有，方法代理的地方，有了接口就会更加方便，易重构。TypeScript 的 Interface + JavaScript 简单的对象就让数据构建变得简单又不容易出错。\r\n小程序对 TypeScript 的支持\r\nTypeScript 有一个很重要的东西，就是 d.ts 文件。d.ts 文件其实相当于 C 系语言里面的 .h 头文件，声明了对外暴露的方法和属性。而小程序官方对 TypeScript 的支持，意味着官方会维护小程序本身 API 的 d.ts 文件，也就是 typing 库，这样当 API 发生变动时，就可以即时变更。\r\n使用也很简单，更新微信开发者工具到最新版，在创建新项目时选择 TypeScript 模板。\r\n\r\n创建后，我们可以看到项目里带上了 typings 库，以及 TypeScript 的配置文件 tsconifg。之后，保存时就不会自动编译了，要点击小程序工具栏的编译按钮才可以。\r\n这里有一个坑，笔者电脑安装的 TypeScript 版本是 3.2.2 版本。编译时会被找不到全局类型 CallableFunction 和 NewableFunction。\r\n\r\n解决方法也很简单，到 node_modules 路径下的 TypeScript 包的 bin 目录下，lib.es5.d.ts 文件里面把这两个类型的 Interface 拷贝到，小程序 typing 目录下的 lib.wa.es6.d.ts 里面就可以了。小程序模板里这个文件应该是拷贝 TypeScript 官方的，但没有随着官方升级而改变。\r\n事件\r\n视图的事件，对应的类型笔者在 typings 中并没有看到有 Interface 定义，所以只能暂时用 any，然后自己再用\r\nas 转一下 event 携带的数据的类型。\r\nPage&Data\r\n每个 Page 对象，在 typing 里是这么定义的。\r\ndeclare const Page: Page.PageConstructor\r\n\r\ninterface PageConstructor {\r\n    <D extends IAnyObject, T extends IAnyObject & PageInstance>(\r\n      options: PageInstance<D, T> & T\r\n    ): void\r\n  }\r\n复制代码也就是说，它支持 D 和 T 两个范型。这两个范型是什么呢？小程序里，Page 是这么写的。\r\nPage({});\r\n复制代码也就是说，options 参数就是一个 PageInstance，范型也被传入了。\r\ninterface PageInstance<D extends IAnyObject = any, T extends IAnyObject = any> extends PageInstanceBaseProps<D>\r\n复制代码PageInstance 里面定义了 Page 声明周期的方法，而且继承自 PageInstanceBaseProps，并将范型 D 传入。\r\ninterface PageInstanceBaseProps<D extends IAnyObject = any> {\r\n    data?: D\r\n    //...\r\n}\r\n复制代码所以这个 D 范型，其实就是 data 的类型接口。因为 data 不是必须实现的，所以这里是可选型 ？。\r\n那么 T 是什么呢？\r\nT extends IAnyObject & PageInstance\r\n复制代码T 其实就是对 PageInstance 的拓展，PageInstance 是 Page 的实例接口，那么 T 其实就是在 Page 里面 this 的类型接口了，也就是说，需要在 Page 里新增的方法和属性，都在 T 里定义。\r\n所以，对于一个普通页面我们可以声明两个接口，一个代表 data， 一个代表 page，举个例子。\r\ninterface IIntroPage {\r\n\tnextButtonTap(event: any): void;\r\n    isLoading: boolean;\r\n}\r\n\r\ninterface IIntroData {\r\n    test: string;\r\n}\r\n\r\nPage<IIntroData, IIntroPage>({\r\n    isLoading: false,\r\n\tnextButtonTap(event: any) {\r\n        this.isLoading = true;\r\n\t}\r\n});\r\n复制代码如果这个页面不需要 data 或者不需要扩展 page，用 IAnyObject 代替 D 或者 T 即可。\r\ninterface PageInstanceBaseProps<D extends IAnyObject = any> {\r\n    data?: D\r\n    setData?<K extends keyof D>(\r\n      data: D | Pick<D, K> | IAnyObject,\r\n      callback?: () => void\r\n    ): void\r\n}\r\n复制代码同时，由于 setData 和 data 都被声明为可选项，使用时需要加上！，this.setData!({}) 和 this.data!。\r\n其他就没什么了，用上 TypeScript 之后，官方的 API 都可以直接看参数和返回值的类型，再也不用去查文档猜测类型了。\r\n调用 JavaScript\r\n为 JavaScript 编写一个简单的 .d.ts 文件，将需要调用的类和方法暴露出来。详情见如何编写一个d.ts文件。\r\n最后\r\n虽然笔者用了 TypeScript 不久，但严格的检查的确让我在增删改接口字段能快速全局重构，而且方法调用联想，API 查看也方便了不少。小程序对 TypeScript 的支持日常使用开发是没有什么问题了，就是官方的文档指引比较少。"}
{"title": "微信小程序-wepy-侧滑删除组件，支持自定义内容区在 ", "author": "Rolan", "pub_time": "2019-2-14 00:04", "content": "在最近的微信小程序开发过程中需要用到侧滑删除的功能，微信小程序官方是没有提供这样的组件，再加上我们的微信小程序使用的是wepy组件开发框架开发的，wepy也没有提供这样的组件，之前也在github上搜索这方面的组件，没有发现合适的，当时只发现了一个开源的: github.com/GeoffZhu/we… 只不过该组件功能单一已经被作者废弃了，无奈自己动手撸了一个侧滑删除组件，现在把它开源出来吧。传送门: github.com/hu670014125…Requirementswepy: \"^1.7.3\"支持功能和特点自定义内容区域：支持之定义内容区域，组件内使用 slot占位。自定义滚动高度：可以自定义scroll-view的高度，默认为屏幕的高度。自定义menu ：如果默认的menu样式不喜欢可以自定义，也可以显示或者隐藏指定的menu。左右滑动：支持左右滑动也可以设置只左右或者右滑。效果如下：如何使用目前支持两种使用模式：1.page页面模式优点：可定制化高，扩展性强。\r\n缺点：集成复杂，代码复用性差。复制代码2.component 组件模式优点：集成简单，代码复用性强，减少包的大小。\r\n缺点：可定制到低。复制代码不建议使用page页面模式，下面详细介绍component 组件模式的使用如何使用// 导入组件\r\nimport SwipeDeleteView from '@/components/wepy-swipe-delete-view'\r\n\r\n// 声明组件\r\n\r\n components = {\r\n      swipeDelete: SwipeDeleteView\r\n    }\r\n    \r\n  // 引用组件\r\n  <template>\r\n  <swipeDelete :list.sync=\"list\">\r\n      <view class=\"item\">{{item.userName}}</view>\r\n    </swipeDelete>\r\n  </template>复制代码配置如下：<swipeDelete   :list.sync=\"list\"\r\n               :scrollHeight=\"scrollHeight\"\r\n               @deleteTap.user=\"deleteTap\"\r\n               @deleteLongTap.user=\"deleteLongTap\"\r\n               @editTap.user=\"editTap\"\r\n               @editLongTap.user=\"editLongTap\"\r\n               @addTap.user=\"addTap\"\r\n               @addLongTap.user=\"addLongTap\"\r\n               @markTap.user=\"markTap\"\r\n               @markLongTap.user=\"markLongTap\">复制代码每个点击事件或者长按事件都会返回两个参数methods = {\r\n      deleteTap(view, item) {\r\n        console.log(item)\r\n        view.deleteItem()\r\n      },\r\n      deleteLongTap(view, item) {\r\n        console.log(item)\r\n        wx.showModal({\r\n          title: '提示',\r\n          content: '确定要删除吗？',\r\n          success: function (res) {\r\n            if (res.confirm) {\r\n              view.deleteItem()\r\n            } else {\r\n              view.closeItem()\r\n            }\r\n          }\r\n        })\r\n      }\r\n   }复制代码view ：view 是SwipeDeleteView对象的本身，可以通过view来做一些其他操作，如:删除当前的itemitem : item 就是当前操作的原始数据，可以通过item获取真正需要的数据当前SwipeDeleteView对外暴露的函数有：如果在使用的过程中遇到什么问题可以告诉我，我及时修复。邮箱：hu670014125@163.com"}
{"title": "用vue重构小程序踩坑之旅(1) --- 微信sdk验签 ", "author": "Rolan", "pub_time": "2019-2-14 00:15", "content": "问题:验签失败　　惨景:用微信sdk实现h5页面的分享,且每个页面分享内容需要自定义.坑1:在Android和ios的系统中,同一个页面Android验签成功,ios验签失败解决方案:因为在使用vue的router时 ios复制出来的页面地址永远都是xxxx.com 而Android系统则是xxx.com/index,这就是照成验签失败的原因;　　查阅解决方案:　　https://www.jianshu.com/p/a470403de789　　大佬写的很详细坑2:某一页面Android验签失败,ios验签成功; --- 脑壳疼解决方案:　　在填埋了坑1后,ios就基本不用考虑单页面验签,但是在某页面中发现Android 验签失败,查出原因是因为url中拼接了中文的埋点.(做小程序跳转时 一般都会加到query中)　　vue中是会把query拼接到url上.建议吧这些数据后期用vuex来保存,(emmm,vue菜鸟,没测过此方案)　 invalid signature签名错误坑3:调用微信sdk的分享接口时,ios成功分享,Android分享失败解决方案(应急解决):　　微信jssdk 1.4使用新的2个分享接口: wx.updateAppMessageShareData 和 wx.updateTimelineShareData 不知道为什么 用了新的接口后就会产生以上问题,所以目前解决方案就是　　用旧的接口wx.onMenuShareTimeline(即将废弃);---脑壳又疼了"}
{"title": "理解小程序的安全与管控 ", "author": "Rolan", "pub_time": "2019-2-14 00:23", "content": "作为一个平台，管控和安全是很有必要性的。虽然说这些是开发自己需要进行防范的，但是平台如果能解决，也算是皆大欢喜了。双线程到底解决了什么先给小程序团队的双线程设计鼓个掌，关于双线程大家也可以回顾下《小程序的底层框架》。H5 的隐患要知道，Web 技术是非常开放灵活的，开发者可以利用 JavaScript 脚本随意地操作 DOM，这是会带来以下的问题：随意地跳转网页，改变界面上的任意内容开发者可以利用 JavaScript 脚本随意地跳转网页，或是改变界面上的任意内容。当然，恶意攻击者也能利用这种便利。获取页面数据小程序也提供可一种可以展示敏感数据的组件，<open-data>能展示包括用户昵称、头像、性别、地理位置等信息（无需用户授权）。如果开发者可以操作 DOM，意味着他们可以随意拿到用户的敏感信息。常见的前端漏洞开发者们普遍重视的安全漏洞，在前端常见的有 XSS 和 CSRF，XSS 是通过注入 JavaScript 脚本的方式来达到特定目的，而 CSRF 则是利用了 cookie。XSS 在双线程的设计中就被过滤了，而 CSRF 会在后面讲到。难以实现的管控为了解决管控与安全问题，小程序需要禁用掉：危险的 HTML 标签或者相关属性，如外跳 url 的 a 标签危险的 API，如操作界面的 API、动态运行脚本的 API如果要一个一个禁止，JavaScript 的灵活性以及浏览器接口的丰富性，会导致很容易遗漏一些危险的接口。并且浏览器内核在不断更新，或许下一版本会新增一个可能会在这套体系下产生漏洞的接口，无法完全避免。安全的逻辑层要怎么彻底解决这些问题呢？给大家点提示：没错，就是沙箱环境。通过提供一个纯 JavaScript 的解释执行环境，这个环境没有浏览器相关接口，当然也不用担心操作 DOM、跳转等问题了。在 iOS 下是用内置的 JavaScriptCore 框架，在安卓下是 JsCore 环境（旧版是腾讯 x5 内核提供，新版是 v8 提供）。一起来回顾下小程序的双线程长什么样子：客户端系统有 JavaScript 的解释引擎，则可以创建一个单独的线程去执行 JavaScript，这个环境下只执行有关小程序业务逻辑的代码。界面渲染相关的任务呢，就丢到 webview 线程里面，通过逻辑层代码去控制渲染哪些界面。把开发者的 JS 逻辑代码放到单独的线程去运行，因为不在 Webview 线程里，所以这个环境没有 Webview 任何接口，自然的开发者就没法直接操作 DOM，也就没法动态去更改界面或者抓取页面数据。同时小程序不支持动态载入脚本，XSS 漏洞自然也无缝可钻。审核机制的管控审核机制，故事要从公众号讲起了。WebView的飞速发展当年随着公众号的出现和繁荣，WebView 的使用频率也越来越高。不少的企业或是小商家、外包公司开始做 H5 页面，各式各样的 H5 活动页、小商城、小测试、小游戏满天飞。当微信中的 WebView 逐渐成为移动 Web 的一个重要入口时，微信就有相关的 JS API 了。2015年初，微信发布了一整套网页开发工具包，开放了拍摄、录音、语音识别、二维码、地图、支付、分享、卡券等几十个API，称之为 JS-SDK。到这个时候，web开发者可以使用到微信的原生能力，去完成一些之前做不到或者很难做到的事情。难管控的 JSSDK由于使用 WebView 和 JSSDK 的人越来越多，微信上越来越多干坏事的人，有人做假红包，有人诱导分享，有伪造一些官方活动，他们会利用 JSSDK 的分享能力变相的去裂变分享到各个群或者朋友圈。由于 JSSDK 是根据域名来赋予 api 权限的，运营人员封了一个域名后，他们立马用别的域名又继续做坏，注册一个新的域名的成本是很低的。小程序的审核机制为了保证小程序的质量，以及符合相关的规范，小程序的发布是需要经过审核的。经过审核的小程序才能对外发布，同时在出现问题时，小程序会被下架停用。另外，每个微信小程序需要事先设置一个通讯域名，小程序只可以跟指定的域名与进行网络通信，包括普通 HTTPS 请求、上传文件、下载文件和 WebSocket 通信，参考框架-网络。这些通讯域名，也都必须要求通过备案。同时，小程序必须使用 HTTPS 发起网络请求。请求时系统会对服务器域名使用的 HTTPS 证书进行校验，如果校验失败，则请求不能成功发起。这些种种的限制和管理模式，都进一步保障了用户的数据和隐私安全。安全的登录机制想必在座的各位前端开发者，都清楚 CSRF 安全漏洞。危险的 cookie跨站请求攻击（CSRF），简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去运行。这利用了 web 中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。通常的罪魁祸首则是浏览器的 cookie 登录态。除了检查 Referer 字段来防范，更有效的一种方式是使用 token。小程序也是这么做的。小程序登录小程序可以通过微信官方提供的登录能力方便地获取微信提供的用户身份标识，快速建立小程序内的用户体系。参考官方时序图：在小程序中调用wx.login()，能拿到一个code作为用户登录凭证（有效期五分钟）。在开发者服务器后台，开发者可使用code换取openid和session_key等信息（code只能使用一次）。可靠的 code假设现在有个接口，请求 https://test.com/getUserInfo?id=1 拉取到微信用户 id 为 1 在我们业务侧的个人信息，那么黑客就可以通过遍历所有的 id，把整个业务侧的个人信息数据全部拉走，会给业务带来很大的安全风险。由于code 5 分钟后会过期，如果黑客要冒充一个用户的话，那他就必须在 5 分钟内穷举所有的身份证 id，然后去开发者服务器换取真实的用户身份。而code在成功换取一次信息之后也会立即失效，即便凭证code生成时间还没过期。显然，黑客要付出非常大的成本才能获取到一个用户信息，同时，开发者服务器也可以通过一些技术手段检测到5分钟内频繁从某个 ip 发送过来的登录请求，从而拒绝掉这些请求。需要保护的 AppSecret开发者的后台就拿到了前边wx.login()所生成的微信登录凭证code，此时就可以拿这个code到微信服务器换取微信用户身份。微信服务器为了确保拿code过来换取身份信息的人就是刚刚对应的小程序开发者，到微信服务器的请求要同时带上AppId和AppSecret。AppId和AppSecret是微信鉴别开发者身份的重要信息，AppId是公开信息，泄露AppId不会带来安全风险，但是AppSecret是开发者的隐私数据不应该泄露，开发者需要好好保护。参考《小程序开发指南》结束语作为一个开放的平台，小程序在提供微信加持、体验加持的能力给开发者使用的同时，也替用户和开发者做了很多安全性上的保障。或许有人说，这是牺牲了开发者的开放性换来的，而我认为这样才是个有灵魂的平台。"}
{"title": "解剖小程序的 setData ", "author": "Rolan", "pub_time": "2019-2-14 00:32", "content": "小程序的双线程，之前也有详细讲过了。而双线程的设计，使得逻辑层和渲染层无法直接进行数据传输。那双线程的渲染机制、通信机制，setData 的出现、工作原理、使用建议等，应该要怎么去理解呢？无处不在的 setData几乎每个开发者都会用到setData，要是在复杂的页面中，写了很多的setData，然后我们会发现页面真的是延迟严重，甚至卡顿、假死。官方在性能优化中有提到：避免频繁的去 setData。避免每次 setData 都传递大量新数据。后台态页面进行 setData。但是到底是为什么呢？setData的出现、设计方案是怎样的，又为何要这么设计呢？一切都还是要从双线程说起。小程序的虚拟 DOM双线程的难题我们知道，小程序的双线程设计，主要为了管控安全，避免操作 DOM。（可参考《小程序的底层框架》）把开发者的 JS 逻辑代码放到单独的线程去运行，因为不在 Webview 线程里，所以这个环境没有 Webview 任何接口，自然开发者就没法直接操作 DOM，也就没法动态去更改界面。但是，这样就产生了新的问题。没法操作 DOM，那用户交互需要界面变化的话怎么办呢？模板数据绑定模版数据绑定的方案，已经成为前端框架中最基础的功能。数据绑定的过程其实不复杂：解析语法生成 AST。根据 AST 结果生成 DOM。将数据绑定更新至模板。浏览器会把 HTML 解析成一棵树，最后渲染出来。整个界面是对应着一棵 DOM 树。其实浏览器页面的 DOM 结构树，也是 AST 的一种，把 HTML DOM 语法解析并生成最终的页面。而模板引擎中常用的，则是将模板语法解析生成 HTML DOM。而最容易引发性能问题的，主要是第三点。而关于数据更新的解决方案，React 首先提出了虚拟 DOM 的设计，而现在也基本被大部分框架吸收，小程序也不例外。虚拟 DOM 机制说到数据更新的 Diff，更多的则是Diff + 更新模板这样一个过程。虚拟 DOM 解决了常见的局部数据更新的问题，例如数组中值位置的调换、部分更新。一般来说计算过程如下：用JS对象模拟DOM树。一个真正的DOM元素非常庞大，拥有很多的属性值。而其中很多的属性对于计算过程来说是不需要的，所以我们的第一步就是简化 DOM 对象。我们用一个 JavaScript 对象结构表示 DOM 树的结构。比较两棵虚拟DOM树的差异。当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异。通常来说这样的差异需要记录，最后得到一组差异记录。把差异应用到真正的DOM树上。对差异记录要应用到真正的 DOM 树上，例如节点的替换、移动、删除，文本内容的改变等。小程序里，由于无法直接操作 DOM，主要也是通过数据传递的方式来进行相关的模版更新。模版绑定的机制、数据更新的机制，都可以参照上面的说明，想更具体理解也可以参考《前端模板引擎》。那么既然不在一个线程，数据的通信是怎么做的呢？小程序的数据通信与渲染机制双线程通信方式小程序的视图层目前使用 WebView 作为渲染载体，而逻辑层是由独立的 JavascriptCore 作为运行环境。在架构上，WebView 和 JavascriptCore 都是独立的模块，并不具备数据直接共享的通道。一个小程序存在多个界面，所以渲染层存在多个 WebView 线程。 逻辑层和渲染层的通信会经由微信客户端（Native）做中转，逻辑层发送网络请求也经由 Native 转发 ，小程序的通信模型如图：当前，视图层和逻辑层的数据传输，实际上通过两边提供的 evaluateJavascript 所实现。即用户传输的数据，需要将其转换为字符串形式传递，同时把转换后的数据内容拼接成一份 JS 脚本，再通过执行 JS 脚本的形式传递到两边独立环境。而 evaluateJavascript 的执行会受很多方面的影响，数据到达视图层并不是实时的。所以我们的setData函数将数据从逻辑层发送到视图层，是异步的。有了线程之间的通信，我们来看看小程序的渲染机制。双线程渲染机制双线程的渲染，其实是结合了前面的一系列机制（模版绑定、虚拟 DOM、线程通信），最后整合的一个执行步骤。1. 通过模版数据绑定和虚拟 DOM 机制，小程序提供了带有数据绑定语法的 DSL 给到开发者，用来在渲染层描述界面的结构。就是我们常见的这些：123<view> {{ message }} </view><view wx:if=\"{{condition}}\"> </view><checkbox checked=\"{{false}}\"> </checkbox>噢，这里顺便吐个槽，wx:if竟然不支持[].indexOf(xx) > -1等等相关的函数运算（摔！）。2. 小程序在逻辑层提供了设置页面数据的 api。不用问就是setData了：123this.setData({  key: value})setData函数用于将数据从逻辑层发送到视图层（异步），同时改变对应的this.data的值（同步）。3. 逻辑层需要更改界面时，只要把修改后的 data 通过 setData 传到渲染层。传输的数据，会转换为字符串形式传递，故应尽量避免传递大量数据。4. 渲染层会根据前面提到的渲染机制重新生成 VD（虚拟 DOM）树，并更新到对应的 DOM 树上，引起界面变化。原生组件的出现原生组件的出现，其实与 setData 的机制也有那么点关系，那么就当题外话一块补充下。频繁交互的性能我们知道，用户的一次交互，如点击某个按钮，开发者的逻辑层要处理一些事情，然后再通过 setData 引起界面变化。这样的一个过程需要四次通信：渲染层 -> Native（点击事件）。Native -> 逻辑层（点击事件）。逻辑层 -> Native（setData）。Native -> 渲染层（setData）。在一些强交互的场景（表单、canvas等），这样的操作流程会导致用户体验卡顿。引入原生组件前面也说过，小程序是 Hybrid 应用，除了 Web 组件的渲染体系（上面讲到），还有由客户端原生参与组件（原生组件）的渲染。引入原生组件主要有 3 个好处：绕过 setData、数据通信和重渲染流程，使渲染性能更好。扩展 Web 的能力。比如像输入框组件（input, textarea）有更好地控制键盘的能力。体验更好，同时也减轻 WebView 的渲染工作。比如像地图组件（map）这类较复杂的组件，其渲染工作不占用 WebView 线程，而交给更高效的客户端原生处理。而原生组件的渲染过程：组件被创建，包括组件属性会依次赋值。组件被插入到 DOM 树里，浏览器内核会立即计算布局，此时我们可以读取出组件相对页面的位置（x, y坐标）、宽高。组件通知客户端，客户端在相同的位置上，根据宽高插入一块原生区域，之后客户端就在这块区域渲染界面。当位置或宽高发生变化时，组件会通知客户端做相应的调整。简单来说，就是 原生组件在 WebView 这一层只需要渲染一个占位元素，之后客户端在这块占位元素之上叠了一层原生界面。有利必有弊，原生组件也是有限制的：最主要的限制是一些 CSS 样式无法应用于原生组件由于客户端渲染，原生组件的层级会比所有在 WebView 层渲染的普通组件要高参考setData《小程序开发指南–6.3 原生组件》结束语总而言之，这一节内容主要是围绕 setData 展开，包括双线程的渲染机制、通信机制，setData 的出现（逻辑层通知渲染层）、工作原理（evaluateJavascript 字符串传递）、使用建议（setData 交互性能）、性能优化（原生组件出现）。小程序乍一看是简单的双线程设计，但仔细研究就会发现设计过程中也遇到了不少问题，不断探索解决才有了现在的美好样子。我们在开发过程中会踩的一些坑，其实在理解原理之后便很容易懂了。现在再来看，官方在性能优化中说到的优化建议，你都能深刻理解了吗？"}
{"title": "node配置微信小程序解密消息以及推送消息 ", "author": "Rolan", "pub_time": "2019-2-15 00:08", "content": "上一篇文章介绍过 微信小程序配置消息推送，没有看过的可以先去查看一下，这里就直接去把那个客服消息接口去解密那个消息了。　　在这里我选择的还是json格式的加密。　　也就是给小程序客服消息发送的消息都会被微信转发到这里配置的地址和接口上面。　　在页面中使用客服消息也就是如下这个效果，是需要用到微信提供的button标签上面的open-type的　　　　点击进入客服消息也就是如下这个效果。　　　　然后你发送的消息就会被转发到上面你配置的那个服务器的端口和那个接口上面，也就是例子中的 　　只不过配置确认的时候的接口是get请求方式，而微信转发消息到这里的接口这里是post请求方式。　　在聊天窗口中发送消息，微信就会把加密后的消息转发到我们的接口  也就是 /checkPushMsg 上面，post请求方式。　　在node中的代码接收，看看微信给我们转发了什么东西呢 1 // 配置前后端的推送消息\r\n 2 router.get('/checkPushMsg', wx_msg.check_push);\r\n 3 \r\n 4 // 那个函数就是如下的处理\r\n 5 exports.handle_customer_sevice = (req, res) => {\r\n 6     console.log('接收到了消息，请求体中');\r\n 7     console.log(req.body);\r\n 8     console.log('接收到了消息，请求url中');\r\n 9     console.log(req.query);\r\n10 }　　我们来查看一下发送过来的什么，我再用文档来比对一下哈。　　现在我在手机上面那个页面里面发送一条消息，任意内容。 　　这里服务器的图片太小了，可以 按住 ctrl + 鼠标滚轮把这里放大看一下，我相信你肯定知道的。　　　　请求url中的内容如下  　　请求体中的内容一个是发送者的 openid，另外一个加密的就是消息内容，它的构成是由  16个字节的随机字符串，4个字节的消息长度，发送的消息，appId由基于AES加解密算法加密而成的。　　这里咱们先不着急解密发送的内容，我们要在解密之前先判断一下是不是微信发送过来的呢，如果不是你在这里解密半天然后发出去那不就难受了。　　上面的图片中也详细的介绍了如何去判断是不是微信发送过来的消息。　　我什么也不想解释了，直接上代码啦。　　 1 exports.handle_customer_sevice = (req, res) => {\r\n 2     console.log('接收到了消息，请求体中');\r\n 3     console.log(req.body);\r\n 4     console.log('接收到了消息，请求url中');\r\n 5     console.log(req.query);\r\n 6     let signature = req.query.signature,\r\n 7         timestamp = req.query.timestamp,\r\n 8         nonce = req.query.nonce,\r\n 9         openid = req.query.openid,\r\n10         encrypt_type = req.query.encrypt_type,\r\n11         msg_signature = req.query.msg_signature,\r\n12         msg_encrypt = req.body.Encrypt; // 密文体\r\n13     \r\n14     // 开发者计算签名\r\n15     let devMsgSignature = sha1(pushToken, timestamp, nonce, msg_encrypt); // 这里的pushToken是 上面那个 配置消息推送 里面设置的Token令牌\r\n16    \r\n17     if(devMsgSignature == msg_signature){\r\n18         console.log('验证成功,是从微信服务器转发过来的消息');\r\n19         \r\n20         res.send('success');\r\n21     }else{\r\n22         console.log('error');\r\n23         res.send('error');\r\n24     }\r\n25 };　　上面的那个sha1函数是这样的 1 /*\r\n 2     @explain sh1加密\r\n 3     @version 1.0.1\r\n 4     \r\n 5     @author : Z\r\n 6     @data : 2019-2-13\r\n 7     \r\n 8     @params : a,b,c……\r\n 9     @return : String 加密完成后的字符串\r\n10  */\r\n11 exports.sha1 = function (...arr) {\r\n12     return crypto.createHash('sha1').update(arr.sort().join('')).digest('hex');\r\n13 };　　上面就可以验证出来如果那个加密的东西确实是那样的就可以验证出来消息确实是由微信发送过来的。  　　然后就要开始解密了，这里我遇到了好多坑，说实话我也不知道下面的代码是谁第一个写出来的，因为官网上面根本就没有Node.js的代码，所以我也是看到了加密消息的构成部分，然后使用下面封装的函数解密。　　 1 /*\r\n 2     @explain: 微信的消息密文解密方法\r\n 3     @version 1.0.1\r\n 4         修复部分消息解析失败的情况\r\n 5     @author: Z\r\n 6     @data :2019-02-14\r\n 7     @params:\r\n 8         obj.AESKey:解密的aesKey值  这里的key就是配置消息推送的那部分\r\n 9         obj.text: 需要解密的密文\r\n10         obj.corpid: 企业的id / 微信小程序的appid\r\n11   \r\n12     @return\r\n13         obj.noncestr  随机数\r\n14         obj.msg_len   微信密文的len\r\n15         obj.msg       解密后的明文\r\n16 */\r\n17 \r\n18 exports.decrypt = function (obj) {\r\n19     let aesKey = Buffer.from(obj.AESKey + '=', 'base64');\r\n20     const cipherEncoding = 'base64';\r\n21     const clearEncoding = 'utf8';\r\n22     const cipher = crypto.createDecipheriv('aes-256-cbc',aesKey,aesKey.slice(0, 16));\r\n23     cipher.setAutoPadding(false); // 是否取消自动填充 不取消\r\n24     let this_text = cipher.update(obj.text, cipherEncoding, clearEncoding) + cipher.final(clearEncoding);\r\n25     /*\r\n26         密文的构成\r\n27             Base64_Encode(AES_Encrypt[random(16B) + msg_len(4B) + msg + $appId])\r\n28         但是由于部分消息是不满足那个 32 位的，所以导致上面那个 cipher.final() 函数报错，所以修改为了自动填充，所以 appId后面还跟着一些字符\r\n29             就无法正常解析了，所以就不返回 corpid 了，然后返回我们想要的东西。\r\n30      */\r\n31     return {\r\n32         noncestr:this_text.substring(0,16),\r\n33         msg_len:this_text.substring(16,20),\r\n34         msg:this_text.substring(20,this_text.lastIndexOf(\"}\")+1)\r\n35     }\r\n36 };　　其中的坑就是我遇到了那个  cipher.setAutoPadding(false) 这里填充的问题，但是有的消息是可以解密出来的，但是有的消息是不可以解密出来的，会报错，所以我就让所有的消息都填充了。　　let this_tex = cipher.update(obj.text, cipherEncoding, clearEncoding) + cipher.final(clearEncoding); 　　解密消息这里的问题是，这是一个加法，前面的那个更新函数会改变 cipher的值，然后导致后面的那个值发生改变，当时找这个错误出现了很多问题。这个问题就是当字体的内容的长度不是32个字节还是什么的倍数的时候，这个函数会报一个500的错误码，然后不知道是哪里的问题，所以我就取消自动填充设置为了false，我就让它一直填充，然后处理那个消息，最后那个明文我再把最后的一个 } 后面截取掉。就可以展示出来了，但是这个里面就无法获取到小程序 appId 了，但是这又有什么必要呢？你后台肯定是知道appId的。　　我把消息处理的完整代码发出来。 1 /*\r\n 2     消息体验证和解密\r\n 3         客服接收到的消息\r\n 4         handle_customer_sevice\r\n 5         \r\n 6 */\r\n 7 \r\n 8 exports.handle_customer_sevice = (req, res) => {\r\n 9     console.log('接收到了消息，请求体中');\r\n10     console.log(req.body);\r\n11     console.log('接收到了消息，请求url中');\r\n12     console.log(req.query);\r\n13     let signature = req.query.signature,\r\n14         timestamp = req.query.timestamp,\r\n15         nonce = req.query.nonce,\r\n16         openid = req.query.openid,\r\n17         encrypt_type = req.query.encrypt_type,\r\n18         msg_signature = req.query.msg_signature,\r\n19         msg_encrypt = req.body.Encrypt; // 密文体\r\n20     \r\n21     // 开发者计算签名\r\n22     let devMsgSignature = sha1(pushToken, timestamp, nonce, msg_encrypt);\r\n23     \r\n24     if(devMsgSignature == msg_signature){\r\n25         console.log('验证成功,是从微信服务器转发过来的消息');\r\n26         \r\n27         let returnObj = decrypt({\r\n28             AESKey: config.server.EncodingAESKey,\r\n29             text: msg_encrypt,\r\n30             corpid: config.app.appId\r\n31         });\r\n32         console.log('解密后的消息');\r\n33         console.log(returnObj);\r\n34         console.log('解密后的消息内容');\r\n35         const decryptMessage = JSON.parse(returnObj.msg);\r\n36         console.log(decryptMessage);\r\n37      \r\n38         /*\r\n39             详细参数请查看官网 消息 https://developers.weixin.qq.com/miniprogram/dev/api/sendCustomerMessage.html\r\n40             @params\r\n41                 access_token  调用接口凭证\r\n42                 touser   用户的openid\r\n43                 msgtype   消息类型\r\n44          */\r\n45         \r\n46         if(JSON.parse(returnObj.msg).Content == '值班'){\r\n47             axios.post(config.url.ip + config.url.P_CustomSend + '?access_token='+config.access_token, {\r\n48                     touser: decryptMessage.FromUserName,\r\n49                     msgtype: \"text\",\r\n50                     text: {\r\n51                         content: \"发送消息\"\r\n52                     }\r\n53                 })\r\n54                 .then(res => {\r\n55                     console.log('消息接口发送成功');\r\n56                     \r\n57                     console.log(res.data);\r\n58                     if(res.data.errcode == 0){\r\n59                         console.log('消息发送成功');\r\n60                     }else if(res.data.errcode == 40001){\r\n61                         console.log('access_token过期');\r\n62                     }else{\r\n63                         console.log('其他错误信息')\r\n64                     }\r\n65                     console.log(res.data);\r\n66                 })\r\n67                 .catch(err => {\r\n68                     console.log('错误消息');\r\n69                     console.log(err);\r\n70                 })\r\n71         }\r\n72         res.send('success');\r\n73     }else{\r\n74         console.log('error');\r\n75         res.send('error');\r\n76     }\r\n77 };　　　　上面用到的两个函数 一个 sha1，另外一个就是 解密函数。　　现在发送一下消息，看一看服务器上面的处理过程。   　　如此是可以解密出来那个消息的内容的，然后我设置了一个发送值班的话会给我发送一个消息。　　   　　如此 就大功告成了。　　看了网上的许多文章大多都是Java，php的代码，很少有Node的代码，而且看了之后也不知道能不能弄出来，如果你遇到这个问题， 仔细看了我的文章之后，还有地方不知道，欢迎打扰我，告诉我哪里不清楚，我也会和你一起把你的问题解决掉。　　如果解决了你的问题我会非常高兴的，其实上面的文章中我也感觉到了有一些地方描述的不是那么清晰，比如说消息加密的那一块，说实话，我也不是那么了解他的加密，只是微信 这里是有讲述的 点击查看　　它的加密我会在最近几天研究一下，把他的加密的细节也给发出来，下一篇文章你可以查看到它的加密。　　如果解决了你的问题我真的会非常高兴，因为我开发了这么久感觉开发出来的东西都没有去影响一些人，甚至我想先给自己做一些程序，并且我已经开始着手去做了，先去方便一下自己再去做一些去对一些人有好处的影响的东西。"}
{"title": "关于小程序的基础库 ", "author": "Rolan", "pub_time": "2019-2-15 00:22", "content": "小程序的基础库，它包含了哪些东西，以及载入、更新的机制又是怎样的呢。小程序基础库的组成基础库成分关于基础库的成分，不得不提到我们之前说过的小程序渲染机制，参考 React 的 Virtual DOM。基础库除了处理 VD 的渲染问题，它还包括内置组件和逻辑层API，总的来说负责处理数据绑定、组件系统、事件系统、通信系统等一系列框架逻辑。小程序的基础库是 JavaScript 编写的，它可以被注入到渲染层和逻辑层运行。在渲染层可以用各类组件组建界面的元素，在逻辑层可以用各类 API 来处理各种逻辑。同时，小程序的一些补充能力：自定义组件和插件，也有相应的基础代码，当然也需要添加到基础库里。所以我们可以看到，小程序的基础库主要是：提供 VD 渲染机制相关基础代码。（Exparser 框架）提供封装后的内置组件。提供逻辑层的 API。提供其他补充能力（自定义组件和插件等）的基础代码。Exparser 框架Exparser 是微信小程序的组件组织框架，内置在小程序基础库中，为小程序的各种组件提供基础的支持。小程序内的所有组件，包括内置组件和自定义组件，都由 Exparser 组织管理。Exparser 会维护整个页面的节点树相关信息，包括节点的属性、事件绑定等，相当于一个简化版的 Shadow DOM 实现。Exparser 的主要特点包括以下几点：基于 Shadow DOM 模型：模型上与 WebComponents 的 ShadowDOM 高度相似，但不依赖浏览器的原生支持，也没有其他依赖库；实现时，还针对性地增加了其他 API 以支持小程序组件编程。可在纯 JS 环境中运行：这意味着逻辑层也具有一定的组件树组织能力。高效轻量：性能表现好，在组件实例极多的环境下表现尤其优异，同时代码尺寸也较小。基于这个框架，内置了一套组件，以涵盖小程序的基础功能，便于开发者快速搭建出任何界面。同时也提供了自定义组件的能力，开发者可以自行扩展更多的组件，以实现代码复用。内置组件小程序基于 Exparser 框架，内置了一套组件，提供了视图容器类、表单类、导航类、媒体类、开放类等几十种组件。内置组件在小程序框架里的定义是：在小程序架构里无法实现或者实现不好某类功能，使用组件内置到小程序框架里。常见包括：开放类组件：如 open-data 组件提供展示群名称、用户信息等微信体系下的隐私信息，有 button 组件里 open-type 属性所提供分享、跳转 App 等敏感操作的能力视图容器类组件：如 movable-view 这种因双线程模型导致手势识别不好实现的组件（在双线程模型中，触摸事件从渲染层发出，派发到逻辑层，这中间是有一定的延时而导致视图跟随手指运动这类交互变得有些卡顿）API宿主环境提供了丰富的API，可以很方便调起微信提供的能力。小程序提供的 API 按照功能主要分为几大类：网络、媒体、文件、数据缓存、位置、设备、界面、界面节点信息还有一些特殊的开放接口。需要注意 API 调用大多都是异步的。自定义组件自定义组件是开发者可以自行扩充的组件。开发者可以将常用的节点树结构提取成自定义组件，实现代码复用。在使用自定义组件的小程序页面中，Exparser 将接管所有的自定义组件注册与实例化。以 Component 为例：在小程序启动时，构造器会将开发者设置的 properties、data、methods 等定义段，写入 Exparser 的组件注册表中。这个组件在被其它组件引用时，就可以根据这些注册信息来创建自定义组件的实例。Page 构造器的大体运行流程与之相仿，只是参数形式不一样。这样每个页面就有一个与之对应的组件，称为“页面根组件”。在初始化页面时，Exparser 会创建出页面根组件的一个实例，用到的其他组件也会响应创建组件实例（这是一个递归的过程）。插件插件是对一组 js 接口、自定义组件或页面的封装，用于嵌入到小程序中使用。插件不能独立运行，必须嵌入在其他小程序中才能被用户使用；而第三方小程序在使用插件时，也无法看到插件的代码。因此，插件适合用来封装自己的功能或服务，提供给第三方小程序进行展示和使用。插件开发者可以像开发小程序一样编写一个插件并上传代码，在插件发布之后，其他小程序方可调用。小程序平台会托管插件代码，其他小程序调用时，上传的插件代码会随小程序一起下载运行。小程序基础库机制基础库的载入在开发网页时，经常会引用很多开源的 JS 库，在使用到这些库所提供的 API 前，我们需要先在业务代码前边引入这些库。同样道理，我们需要在启动 APP 之前载入基础库，接着再载入业务代码。由于小程序的渲染层和逻辑层是两个线程管理，而我们 一般说起基础库，也通常包括 WebView 基础库（渲染层），和 AppService 基础库（逻辑层）。显然，所有小程序在微信客户端打开的时候，都需要注入相同的基础库。所以，小程序的基础库不会被打包在某个小程序的代码包里边，它会被提前内置在微信客户端。将基础库内置在微信客户端，有两个好处：降低业务小程序的代码包大小。可以单独修复基础库中的Bug，无需修改到业务小程序的代码包。小程序的启动在小程序启动前，微信会提前准备好一个页面层级用于展示小程序的首页。这里就包括了逻辑层和渲染层分别的初始化以及公共库的注入。在小程序启动时，微信会为小程序展示一个固定的启动界面，界面内包含小程序的图标、名称和加载提示图标。此时，微信会在背后完成几项工作：下载小程序代码包、加载小程序代码包、初始化小程序首页。基础库的更新小程序的很多能力需要微信客户端来支撑，例如蓝牙、直播能力、微信运动等，可以说，小程序基础库的迭代离不开微信客户端的发布。为了避免新版本的基础库给线上小程序带来未知的影响，微信客户端都是携带上一个稳定版的基础库发布的。等到微信客户端正式发布后，小程序会开始灰度推送新版本的基础库到微信客户端里，在这个过程需要仔细监控各类异常现象以及开发者和用户的反馈，一般灰度时长为12小时，灰度结束后，用户设备上就会有新版本的基础库。如果存在重大Bug，那此次推送会被回退。参考《小程序开发指南——小程序基础库的更新迭代》《小程序开发指南——6.2 组件系统》结束语本节大致结合了小程序的启动来讲了下小程序的基础库。其实很多都能在小程序开发指南里找到，只是文字太多又有些乱，看一遍未必能记住，但是第二遍又找不到了。哈哈哈吐槽下小程序的文档，很详细就是有点容易找不到。"}
{"title": "小程序的底层框架 ", "author": "Rolan", "pub_time": "2019-2-15 00:25", "content": "前端的框架太多让人眼花缭乱，很多相似的地方，优秀的地方大家都会借鉴，同时又会有各自的一些特点。小程序也好，其他框架也好，理解他们的设计缘由、实现原理，还是能学到很多很多东西的。一切始于双线程技术选型上一节《小程序的诞生》中，我们也提到了小程序的双线程设计。目前来说，页面渲染的方式主要有三种：Web 渲染。Native 原生渲染。Web 与 Native 两者掺杂，也即我们常说的 Hybrid 渲染。前面也说过，小程序最终的呈现形式，是 WebView + 原生组件，Hybrid 方式。我们结合之前对小程序的期望来看：开发门槛：Web 门槛低，不过 Native 也有像 RN 这样的框架支持体验：Native 体验比 Web 不要好太多，Hybrid 在一定程度上比 Web 接近原生体验版本更新：Web 支持在线更新，Native 则需要打包到微信一起审核发布管控和安全：Web 可跳转或是改变页面内容，存在一些不可控因素和安全风险由于小程序的宿主是微信，如果用纯客户端原生技术来编写小程序 ，那小程序代码需要与微信代码一起编包，跟随微信发版本，这种方式跟开发节奏必然都是不对的。所以方向应该是需要像 Web 技术那样，有一份随时可更新的资源包放在云端，通过下载到本地，动态执行后即可渲染出界面。如果用纯 Web 技术来渲染小程序，在一些有复杂交互的页面上可能会面临一些性能问题。这是因为在 Web 技术中，UI渲染跟 JavaScript 的脚本执行都在一个单线程中执行，这就容易导致一些逻辑任务抢占UI渲染的资源。总地看来，小程序选择了 Hybrid 的渲染方式，可以用一种近似 Web 的方式来开发，并且还可以实现在线更新代码。同时，引入原生组件有以下好处：扩展 Web 的能力。比如像输入框组件（input, textarea）有更好地控制键盘的能力体验更好，同时也减轻 WebView 的渲染工作绕过 setData、数据通信和重渲染流程，使渲染性能更好现在，我们还剩下一个很重要的问题：管控性和安全性。于是，双线程的设计被提出来了。双线程的小程序也不知道是哪位大佬，能想出双线程这样的模型，反正我是佩服得666的。双线程是什么？我们先来看个官方的图：小程序的渲染层和逻辑层分别由 2 个线程管理：渲染层的界面使用了 WebView 进行渲染，逻辑层采用 JsCore 线程运行 JS 脚本。为什么要这么设计呢？前面提到的管控和安全，为了解决这些问题，我们需要阻止开发者使用一些浏览器提供的，诸如跳转页面、操作 DOM、动态执行脚本的开放性接口。我们可以使用客户端系统的 JavaScript 引擎，iOS下的 JavaScriptCore 框架，安卓下腾讯 x5 内核提供的 JsCore 环境。通过提供一个沙箱环境来运行开发者的 JavaScript 代码来解决。这个沙箱环境只提供纯 JavaScript 的解释执行环境，没有任何浏览器相关接口。这就是小程序双线程模型的由来：逻辑层：创建一个单独的线程去执行 JavaScript，在这个环境下执行的都是有关小程序业务逻辑的代码渲染层：界面渲染相关的任务全都在 WebView 线程里执行，通过逻辑层代码去控制渲染哪些界面。一个小程序存在多个界面，所以渲染层存在多个 WebView 线程双线程通信把开发者的 JS 逻辑代码放到单独的线程去运行，但在 Webview 线程里，开发者就没法直接操作 DOM。那要怎么去实现动态更改界面呢？前面我们知道，逻辑层和渲染层的通信会由 Native （微信客户端）做中转，逻辑层发送网络请求也经由 Native 转发。这是不是意味着，我们可以把 DOM 的更新通过简单的数据通信来实现呢？Virtual DOM 相信大家都已有了解，大概是这么个过程：用JS对象模拟DOM树 -> 比较两棵虚拟DOM树的差异 -> 把差异应用到真正的DOM树上。在这里我们可以用上，如图：在渲染层把 WXML 转化成对应的 JS 对象。在逻辑层发生数据变更的时候，通过宿主环境提供的 setData 方法把数据从逻辑层传递到 Native，再转发到渲染层。经过对比前后差异，把差异应用在原来的 DOM 树上，更新界面。我们通过把 WXML 转化为数据，通过 Native 进行转发，来实现逻辑层和渲染层的交互和通信。而这样完整的一套框架，基本上都是通过小程序的基础库来完成的。小程序的基础库小程序的基础库是 JavaScript 编写的，它可以被注入到渲染层和逻辑层运行。主要用于：在渲染层，提供各类组件来组建界面的元素在逻辑层，提供各类 API 来处理各种逻辑处理数据绑定、组件系统、事件系统、通信系统等一系列框架逻辑由于小程序的渲染层和逻辑层是两个线程管理，两个线程各自注入了基础库。小程序的基础库不会被打包在某个小程序的代码包里边，它会被提前内置在微信客户端。这样可以：降低业务小程序的代码包大小可以单独修复基础库中的 Bug，无需修改到业务小程序的代码包Exparser 框架Exparser 是微信小程序的组件组织框架，内置在小程序基础库中，为小程序的各种组件提供基础的支持。小程序内的所有组件，包括内置组件和自定义组件，都由 Exparser 组织管理。Exparser 特点包括：基于 Shadow DOM 模型：模型上与 WebComponents 的 ShadowDOM 高度相似，但不依赖浏览器的原生支持，也没有其他依赖库；实现时，还针对性地增加了其他API以支持小程序组件编程。可在纯JS环境中运行：这意味着逻辑层也具有一定的组件树组织能力。高效轻量：性能表现好，在组件实例极多的环境下表现尤其优异，同时代码尺寸也较小。关于基础库和 Exparser 框架，更多的也可以参考：《小程序开发指南》结束语这节里大概讲了小程序设计中比较重要的一个模型——双线程，关于双线程的出现、设计、数据通信，到基础库、Exparser 框架，都是一个个相关而又相互影响的选择。关于小程序的底层框架设计，其实还涉及更多更多我们未能一时半会掌握完的内容，自定义组件、原生组件，还有他们做了很多的性能优化工作，都不是只言片语能讲完的。我们能做的，就是多去思考。"}
{"title": "小程序页面管理与跳转 ", "author": "Rolan", "pub_time": "2019-2-15 00:31", "content": "一个小程序有很多页面，每个页面又有各自的线程、生命周期和功能逻辑。关于小程序的生命周期、页面之间的跳转有哪些特殊的地方呢？小程序的启动小程序启动过程初次进入小程序的时候，微信客户端初始化好宿主环境，同时从网络下载或者从本地缓存中拿到小程序的代码包，把它注入到宿主环境。大概是这么个过程：创建线程（渲染层和逻辑层），启动小程序。载入基础库（WebView 基础库和 AppService 基础库）。载入小程序业务代码（下载或者从本地缓存中拿到）。使用App()注册程序实例。为了让小程序业务代码能够调用 API 以及组件，就需要在启动小程序后先载入基础库，接着再载入业务代码。由于所有小程序都需要注入相同的基础库，所以小程序的基础库会被提前内置在微信客户端。而基础库是热更新的，故一般等微信客户端携带上一个稳定版的基础库正式发布后，再进行新版本基础库的灰度和推送。注册 App 实例宿主环境提供了App()构造器用来注册一个程序 App。App 实例是单例对象，在其他 JS 脚本中可以使用宿主环境提供的getApp()来获取程序实例。App() 必须在 app.js 中调用，必须调用且只能调用一次。不然会出现无法预期的后果。App()函数用来注册一个小程序。接受一个Object参数，其指定小程序的生命周期回调等。onLaunch小程序初始化完成时（全局只触发一次）触发onLaunch回调。在微信客户端中打开小程序有很多途径，对不同途径的打开方式，小程序有时需要做不同的业务处理。所以微信客户端会把打开方式带给onLaunch和onShow的调用参数options，我们可以根据参数来判断一些进入方式，以及做对应的逻辑处理。例如，我需要拿到从另外一个小程序跳转过来携带的信息，此时场景值应该是1037（参考场景值）：123456789App({  // ...  onShow: function(e) {    if(e.scene === 1037){      const data = e.referrerInfo && e.referrerInfo.extraData; // 拿到对应的数据      const refAppid = e.referrerInfo && e.referrerInfo.appId; // 拿到对应的小程序appid    }  }})onShow小程序启动，或从后台进入前台显示时触发onShow回调。通常我们用来处理数据和状态的更新。小程序进入后台状态：当用户点击左上角关闭，或者按了设备 Home 键离开微信，小程序并没有直接销毁。onHide小程序从前台进入后台时触发onHide回调。小程序进入前台状态：当再次进入微信或再次打开小程序，又会从后台进入前台。获取 App 实例我们可以使用全局的getApp()函数来获取到小程序 App 实例（在App()内的函数中使用this就可以拿到app实例。）。前面我们可以看到，App 的生命周期是由微信客户端根据用户操作主动触发的。故我们通过getApp()获取实例之后，不应该私自调用生命周期函数。具体的原理是什么呢？小程序的 JS 脚本是运行在 JsCore 的线程里，小程序的每个页面各自有一个 WebView 线程进行渲染，所以小程序切换页面时，小程序逻辑层的 JS 脚本运行上下文依旧在同一个 JsCore 线程中。因此，App 构造器可以传递其他参数作为全局属性以达到全局共享数据的目的。由于所有页面的脚本逻辑都跑在同一个 JsCore 线程，页面使用setTimeout或者setInterval的定时器，即使切换了页面，也需要自行清理定时器。可以选择：在页面离开onUnload、onHide等的时候自行清理做全局的定时器管理（当然也还是需要关闭时清理）说到页面之间的数据共享，我们也该来讲讲小程序里页面的启动。小程序页面页面生命周期宿主环境提供了Page(Object)构造器用来注册一个小程序页面，接受一个Object类型参数，其指定页面的初始数据、生命周期回调、事件处理函数等。注意：Object 内容在页面加载时会进行一次深拷贝，需考虑数据大小对页面加载的开销。这里我们先来看看官方的生命周期图：左侧是渲染层，右侧是逻辑层。几件事：渲染层和逻辑层之间通信，是通过 Native 转发实现的。逻辑层通过 Page 实例的setData方法传递数据到渲染层。由于需要两个线程的一些通信消耗，为了提高性能，每次只设置需要改变的最小单位数据。生命周期顺序：onLoad -> onShow -> onReady。页面生命周期函数：onLoad(Object query)页面加载时触发。一个页面只会调用一次，可以在onLoad的参数中获取打开当前页面路径中的参数。onShow()页面显示/切入前台时触发。onReady()页面初次渲染完成时触发。一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互。onHide()页面隐藏/切入后台时触发。onUnload()页面卸载时触发。和小程序实例的生命周期对比，其实页面也是有些相似。这里需要注意几点：当前页面路径的参数获取，只能在onLoad(query)的query参数中获取，无法在onShow()中获取onLoad、onReady和onUnload，一个页面都只会调用一次页面是卸载还是切换到后台，这些除了与小程序的后台切换有关系，还会与页面的跳转、切换逻辑有关系下面我们就来看下页面的逻辑。页面导航我们知道，一个小程序会拥有多个页面。在小程序里会有页面的层级关系，例如通过wx.navigateTo推入一个新的页面，在首页使用2次wx.navigateTo后，页面层级会有三层：获取页面栈getCurrentPages()函数用于获取当前页面栈的实例，以数组形式按栈的顺序给出，第一个元素为首页，最后一个元素为当前页面。需要注意的是：修改页面栈会导致路由以及页面状态错误App.onLaunch的时候 page 还没有生成，不能在这调用getCurrentPages()但是其实不是每一次切换页面，都会被记录到页面栈里，我们看看页面导航的一些方法和行为：关于导航 API 的几个补充点：wx.navigateTo和wx.redirectTo只能打开非 TabBar 页面，wx.switchTab只能打开 Tabbar 页面，wx.reLaunch可以打开任意页面TabBar 页面指在 app.json 的 TabBar 字段定义的页面（客户端窗口的底部或顶部有 tab 栏可以切换页面）跳转到 TabBar 页面，路径后不能带参数（注意，Tabbar 页面初始化之后不会被销毁）调用页面路由带的参数可以在目标页面的onLoad中获取页面层级准备我们知道页面栈的表现，以及一些常见的导航方法，而小程序基础库也在页面层级做了些体验优化。对于每一个新的页面层级，视图层都需要进行一些额外的准备工作：在小程序启动前，微信会提前准备好一个页面层级用于展示小程序的首页每当一个页面层级被用于渲染页面，微信都会提前开始准备一个新的页面层级，减少每次新开页面的耗时每个页面的准备都有三个阶段：启动一个 WebView。WebView 中初始化基础库（此时还会进行一些基础库内部优化，以提升页面渲染性能）。注入小程序 WXML 结构和 WXSS 样式（小程序能在接收到页面初始数据之后马上开始渲染页面）。PS：wx.redirectTo不会打开一个新的页面层级，而是将当前页面层级重新初始化。参考导航.小程序路由.小程序3.2 程序与页面7.2 页面层级准备结束语页面的路由和跳转、切入方式，其实和用户的使用和交互紧紧相关，设计合理也是能大大提升用户体验的。其实这一节的内容，大部分都是小程序文档里面有的。只不过好些相关的内容被分散在各个地方，理解和使用起来还是需要查找，这一节就当作整理笔记吧。"}
{"title": "小程序：无限自动滚动的Gallery ", "author": "Rolan", "pub_time": "2019-1-17 00:53", "content": "遇到一个需求，需要在小程序内实现自动轮播的画廊效果，如果是网页版的话有大量现成的库可以用，但小程序找了一圈没找到有类似的库，只好自己想办法了。\r\n在踩了多个坑之后找到最简单的方法，就是用CSS animation来实现，但缺点就是不能手动拖动。\r\n先贴一下效果图\r\n\r\n第一步 html\r\n因为要无限滚动，所以放完在最后一个图之后需要切换回第一个图。为了让用户感知不到这个切换过程，需要将最开始图片复制后末尾，小程序里把wx:for复制一遍就行了，注意要修改wx:key的值，避免重复。\r\n为啥是复制全部图片呢，主要是因为keyframes的值不能动态设置，复制全部后只需要将end进度值设置为-50%即可。\r\n<view class=\"series\">\r\n    <view\r\n        style=\"animation: {{duration}}ms scroll-animation linear infinite;width: {{seriesWidth*2}}rpx\"\r\n        class=\"images\">\r\n        <view class=\"row\" wx:for=\"{{productSeries}}\" wx:key=\"{{index}}\">\r\n            <image\r\n                wx:for=\"{{item}}\"\r\n                wx:for-item=\"img\"\r\n                wx:for-index=\"imgIndex\"\r\n                wx:key=\"{{img + imgIndex}}\"\r\n                src=\"{{img}}\"\r\n            ></image>\r\n            <image\r\n                wx:for=\"{{item}}\"\r\n                wx:for-item=\"img\"\r\n                wx:for-index=\"imgIndex\"\r\n                wx:key=\"{{img + imgIndex}}-extra\"\r\n                src=\"{{img}}\"\r\n            ></image>\r\n        </view>\r\n    </view>\r\n</view>\r\n复制代码第二步 css\r\nCSS动画很简单，让gallery转动到-50%的时候跳回0%，并设置infinite。使用style而非class的原因是画廊总长不确定，动画的时长根据图片数量来设置。width也是需要动态设置，自动计算的width会有问题。\r\n.series {\r\n    overflow: hidden;\r\n    .images {\r\n        min-width: 100%;\r\n        .row {\r\n            white-space: nowrap;\r\n            line-height: 1;\r\n            &:last-child {\r\n                transform: translateX(-100rpx);\r\n            }\r\n        }\r\n        image {\r\n            width: 180rpx;\r\n            height: 180rpx;\r\n            margin: 0 10rpx 8rpx 0;\r\n        }\r\n    }\r\n}\r\n@keyframes scroll-animation {\r\n        from {\r\n            transform: translateX(0);\r\n        }\r\n        to {\r\n            transform: translateX(-50%);\r\n        }\r\n    }\r\n复制代码第三步 js\r\n我们还需要通过js计算动画时长和view的长度，数字190是image width + margin-right的值。最后要再减一次margin-right的原因我也不确定，但不减这个值的话动画最后会有一点卡顿的感觉，显得不太流畅，希望有大佬解答一下原理。\r\ndata = {\r\n    productSeries: [\r\n        [\r\n            '/images/house1.png',\r\n            '/images/house2.png',\r\n            '/images/house3.png',\r\n            '/images/house2.png',\r\n            '/images/house3.png',\r\n            '/images/house4.png'\r\n        ],\r\n        [\r\n            '/images/house1.png',\r\n            '/images/house2.png',\r\n            '/images/house3.png',\r\n            '/images/house2.png',\r\n            '/images/house3.png',\r\n            '/images/house4.png'\r\n        ]\r\n    ],\r\n    speed: 40,\r\n    seriesWidth: 400,\r\n    duration: 60000\r\n}\r\nonShow() {\r\n    if (this.productSeries[0].length > 4) {\r\n        this.seriesWidth = 190 * this.productSeries[0].length - 10\r\n        this.duration = Math.floor(this.seriesWidth / this.speed * 1000)\r\n    } else { // 当一行图片太少时就没必要加动画了\r\n        this.seriesWidth = null\r\n        this.duration = 0\r\n    }\r\n}\r\n复制代码"}
{"title": "小程序--语音合成tts 对接多平台（讯飞，思必驰，百度） ", "author": "Rolan", "pub_time": "2019-1-21 00:54", "content": "小程序功能特点文本转语音多平台多发音人可选可调语速可提供音频下载良心产品无广告小程序码\r\n\r\n已对接在线语音识别服务\r\n\r\n思必驰dui平台 (超过40个免费可选发音人)\r\n讯飞开放平台 (5个免费可选发音人)\r\n百度语音(4个免费发音人可选)\r\n\r\n小程序截图\r\n\r\n服务端主要代码\r\nclass TTSController extends Controller {\r\n  async tts () {\r\n    let params = this.ctx.query\r\n    let result = null\r\n    // 根据plat参数来调用不同的接口\r\n    if (params.plat === 'xf') {\r\n      result = await this.ctx.service.xftts.getTts(params)\r\n    } else if (params.plat === 'baidu') {\r\n      result = await this.ctx.service.baidutts.getTts(params)\r\n    } else {\r\n      result = await this.ctx.service.aispeechtts.getTts(params)\r\n    }\r\n    // 设置response的类型，这样客户端接收到的就是一个文件流\r\n    this.ctx.response.type = 'audio/mpeg'\r\n    this.ctx.body = result\r\n  }\r\n}\r\n复制代码小程序客户端template代码（使用的mpvue）\r\n<template>\r\n  <div class=\"container\">\r\n    <div class=\"preview\">\r\n      <textarea :class=\"textAreaFocus? 'focus' : ''\" \r\n      auto-height @focus=\"bindTextAreaFocus\" \r\n      @blur=\"bindTextAreaBlur\" placeholder=\"请输入文本\" \r\n      v-model=\"text\"  maxlength=\"256\"/>\r\n    </div>\r\n    <div class=\"setting\">\r\n      <picker @change=\"bindPlatChange\" v-model=\"platIndex\" range-key=\"name\" :range=\"platArr\">\r\n        <div class=\"item\">\r\n          <div class=\"label\">选择平台</div>\r\n          <div class=\"value voice\">\r\n            {{platArr[platIndex].name}}\r\n          </div>\r\n        </div>\r\n      </picker>\r\n      <picker @change=\"bindPickerChange\" v-model=\"index\" range-key=\"name\" :range=\"array\">\r\n        <div class=\"item\">\r\n          <div class=\"label\">选择发音人</div>\r\n          <div class=\"value voice\">\r\n            {{array[index].name}}\r\n          </div>\r\n        </div>\r\n      </picker>\r\n      <div class=\"item speed\">\r\n        <div class=\"label\">调节语速</div>\r\n        <div class=\"value\">\r\n          <slider @change=\"onSpeedChange\" :value=\"speedObj.default\" :step='speedObj.step' activeColor=\"#6F8FFF\" :min=\"speedObj.min\" :max=\"speedObj.max\" show-value />\r\n        </div>\r\n      </div>\r\n    </div>\r\n    <div style=\"height: 140rpx;\">\r\n      <div class=\"btn-group\">\r\n        <div class=\"item\"><button @click=\"audioPlay\" type=\"main\">播放合成语音</button> </div>\r\n        <div class=\"item\"> <button @click=\"audioDownload\" type=\"submain\">复制链接下载</button> </div>\r\n      </div>\r\n    </div>\r\n    <div class=\"desc\">\r\n      说明：tts是英文 text to speech的缩写，即文本转语音技术\r\n      <contact-button \r\n        type=\"default-light\"\r\n        session-from=\"weapp\">联系客服\r\n      </contact-button>\r\n    </div>\r\n  </div>\r\n</template>\r\n复制代码script 代码\r\n<script>\r\nimport voiceIdArray from './voiceIdArray'\r\n\r\nexport default {\r\n\r\n  data () {\r\n    return {\r\n      array: voiceIdArray.aispeech,\r\n      platArr: [{id: 'xf', name: '科大讯飞'}, {id: 'aispeech', name: '思必驰'}, {id: 'baidu', name: '百度'}],\r\n      platIndex: 1,\r\n      index: 26,\r\n      text: `改革春风吹满地，吹满地，春风吹满地。\\n中国人民真争气，真争气，人民真争气。\\n这个世界太疯狂，耗子都给猫当伴娘。\\n齐德隆，齐东强。\\n齐德隆的咚得隆咚锵。`,\r\n      voiceId: 'lili1f_diantai',\r\n      speed: 1,\r\n      textAreaFocus: false,\r\n      audioCtx: null,\r\n      ttsServer: 'https://tts.server.com',\r\n      audioSrc: '',\r\n      downloadUrl: '',\r\n      xfSpeedObj: {\r\n        min: 0,\r\n        max: 100,\r\n        default: 50,\r\n        step: 1\r\n      },\r\n      aispeechSpeedObj: {\r\n        min: 0.7,\r\n        max: 2,\r\n        default: 1,\r\n        step: 0.1\r\n      },\r\n      baiduSpeedObj: {\r\n        min: 0,\r\n        max: 9,\r\n        default: 5,\r\n        step: 1\r\n      },\r\n      speedObj: {}\r\n    }\r\n  },\r\n  watch: {\r\n    platIndex (newVal, oldVal) {\r\n      if (newVal === 2) {\r\n        this.array = voiceIdArray.baidu\r\n        this.index = 0\r\n        this.speedObj = this.baiduSpeedObj\r\n      }\r\n      if (newVal === 1) {\r\n        this.array = voiceIdArray.aispeech\r\n        this.index = 26\r\n        this.speedObj = this.aispeechSpeedObj\r\n      }\r\n      if (newVal === 0) {\r\n        this.array = voiceIdArray.xf\r\n        this.index = 0\r\n        this.speedObj = this.xfSpeedObj\r\n      }\r\n    }\r\n  },\r\n  onShareAppMessage () {\r\n    return {\r\n      title: '文本转语音服务，多发音人可选'\r\n    }\r\n  },\r\n  methods: {\r\n    onSpeedChange (e) {\r\n      this.speedObj.default = e.target.value\r\n    },\r\n    bindPlatChange (e) {\r\n      this.platIndex = e.target.value * 1\r\n    },\r\n    bindPickerChange (e) {\r\n      this.index = e.target.value\r\n    },\r\n    getAudioSrc () {\r\n      if (this.text === '') {\r\n        return false\r\n      }\r\n      const speed = this.speedObj.default\r\n      const voiceId = this.array[this.index].id\r\n      const plat = this.platArr[this.platIndex].id\r\n      return encodeURI(`${this.ttsServer}/tts?plat=${plat}&voiceId=${voiceId}&speed=${speed}&text=${this.text}`)\r\n    },\r\n    getDownloadUrl () {\r\n      const plat = this.platArr[this.platIndex].id\r\n      const voiceId = this.array[this.index].id\r\n      wx.showLoading({\r\n        title: '加载中'\r\n      })\r\n      wx.request({\r\n        url: 'https://tts.server.com/getdownloadurl',\r\n        data: {\r\n          plat: plat,\r\n          voiceId: voiceId,\r\n          speed: this.speedObj.default,\r\n          text: this.text\r\n        },\r\n        header: {\r\n          'content-type': 'application/json' // 默认值\r\n        },\r\n        success (res) {\r\n          wx.hideLoading()\r\n          wx.setClipboardData({\r\n            data: res.data.short_url,\r\n            success (res) {\r\n              wx.showToast({\r\n                title: '链接已复制请用浏览器下载(ios端无法下载)',\r\n                icon: 'none',\r\n                duration: 3000\r\n              })\r\n            }\r\n          })\r\n        }\r\n      })\r\n    },\r\n    audioPlay () {\r\n      this.audioCtx.src = this.getAudioSrc()\r\n      if (!this.audioCtx.src) {\r\n        wx.showToast({\r\n          title: '请先输入文本',\r\n          icon: 'none',\r\n          duration: 2000\r\n        })\r\n        return false\r\n      }\r\n      wx.showLoading({\r\n        title: '加载中'\r\n      })\r\n      this.audioCtx.play()\r\n    },\r\n    audioDownload () {\r\n      this.getDownloadUrl()\r\n    },\r\n    bindTextAreaBlur (e) {\r\n      this.textAreaFocus = false\r\n      this.text = e.target.value\r\n    },\r\n    bindTextAreaFocus () {\r\n      this.textAreaFocus = true\r\n    }\r\n  },\r\n\r\n  created () {\r\n    this.speedObj = this.aispeechSpeedObj\r\n  },\r\n  mounted () {\r\n    this.audioCtx = wx.createInnerAudioContext()\r\n    this.audioCtx.onEnded((res) => {\r\n      wx.hideLoading()\r\n    })\r\n    this.audioCtx.onPlay((res) => {\r\n      wx.hideLoading()\r\n    })\r\n    wx.showShareMenu({\r\n      withShareTicket: true\r\n    })\r\n  }\r\n}\r\n</script>\r\n复制代码接口对接过程中，百度的是最方便的因为有sdk可以直接使用，讯飞的最麻烦需要自己做参数加密，思必驰dui的虽然没提供SDK但是文档写的比较详细对接过程也很方便快速。\r\n目前无法解决的就是，小程序内无法直接下载的问题，只能提供链接，然后用户自己打开浏览器进行下载（iPhone似乎无解）。"}
{"title": "经验总结--我的小程序开发和进化之路 ", "author": "Rolan", "pub_time": "2019-1-22 00:12", "content": "从接触小程序开始，到现在大大小小做了差不多有五六个小程序项目了，小项目的只有几个页面，大的项目有几十个页面。此篇文章是对之前项目的一个总结，项目的脚手架，开发框架和后期的优化是一个逐渐进化完善的过程，如果你打算开发小程序或者已经在开发小程序，相信这些经验对你会有一定的帮助。脚手架小程序开发者工具可以直接编写小程序的，但是开发工具就像武士手中的剑，多年磨炼，已经达到人剑合一了，突然换把武器，那势必影响杀敌效率，所以使用自己熟悉的开发工具还是很有必要的。本人所在的公司基本都是中小型公司，项目开发周期都很短，前期的准备工作最多也就几天时间，所以自己去撸一套脚手架然后用于项目开发，难度比较大，在网上找优质的资源是最好的选择。大佬justjavac的开源项目 微信小程序开发资源汇总 ，涵盖了大量的优质小程序开发资源，在此推荐一波。当然，脚手架的选择也是视项目而定的，如果只有几个页面的项目，搞一套很重的工具未免有点画蛇添足了。我们的做法是小项目，直接撸，大点的项目选用网络上的优质资源+自己改写。17年的电商项目，模块不多，采用的脚手架比较简单，使用gulp监听文件改动，实时编译，支持ES6+语法。脚手架地址18年中旬的电商项目，到了新的公司，当时选用了WePY进行开发，特性简单介绍下：类Vue的开发风格组件化开发（WePY出来的时候，小程序还不支持组件）支持加载外部NPM包(小程序原生也支持)使用babel编译，支持ES6/7的语法针对原生API进行优化详细介绍请点击WePY文档进行查看，后续框架选择上也会提到，差点被这框架害惨了。最近的一个地产项目，也是下一个项目打算使用的， weapp-start ，上文提到的小程序开发资源汇总中也有提到，特性如下：支持 npm 包引入支持 promise, async/await 等最新语法支持多种编译器，如 pug/less/stylus支持 ESlint支持本地 mock 数据支持一键生成项目，组件模版支持发布前资源压缩支持自定义插件多种工具，加速开发项目的地址为 weapp-start ，其中 weapp-plugin-require（分析依赖，导入第三方 npm） ，存在问题，window操作系统会出现路径错误，我已修复，并给作者提了PR，但作者并没有修复这个问题，如果有同学要用到这个脚手架，请下载我修改好的文件进行替换， 下载地址 。另推荐我根据weapp-start搭建的环境，目录结构为：├── README.md                 // 说明文档\r\n├── dist                      // 编译后的代码，用小程序开发工具打开此文件夹\r\n├── mock.js                   // 模拟数据的文件\r\n├── package-lock.json\r\n├── package.json\r\n├── project.config.json       // 项目配置文件\r\n├── src                       // 项目代码都在这个文件夹下\r\n│   ├── app.js                // 等同于小程序根目录下的app.js\r\n│   ├── app.json              // 等同于小程序根目录下的app.json\r\n│   ├── app.wxss              // 等同于小程序根目录下的app.wxss\r\n│   ├── assets                // 项目中使用到的静态资源\r\n│   │   └── images\r\n│   │       ├── example\r\n│   │       └── tab\r\n│   ├── components            // 公用的组件\r\n│   ├── page                  // 存放小程序的各个页面文件\r\n│   │   ├── example           // example 页面\r\n│   │   │   ├── components    // example页面中的组件\r\n│   │   │   ├── index.js\r\n│   │   │   ├── index.json\r\n│   │   │   ├── index.wxml\r\n│   │   │   ├── index.wxss\r\n│   │   │   ├── services      // example页面中接口\r\n│   │   │   ├── template      // example页面中的模板\r\n│   │   │   └── wxs           // example页面中的wxs文件\r\n│   │   ├── globalStore.js    // 全局共享的数据\r\n│   │   └── test\r\n│   │       ├── index.js\r\n│   │       ├── index.json\r\n│   │       ├── index.wxml\r\n│   │       └── index.wxss\r\n│   ├── template              // 公用的模板\r\n│   └── utils                 // 公用的方法或工具\r\n│       ├── config.js         // 全局的一些配置信息\r\n│       ├── create.js         // 状态管理插件\r\n│       ├── mitt.js           // 状态管理插件\r\n│       ├── obaa.js           // 状态管理插件\r\n│       ├── util.js           // 公用方法\r\n│       ├── wxRequest.js      // 封装的小程序请求数据方法\r\n│       └── wxapi.js          // 对小程序api进行Promise封装\r\n└── weapp.config.js           // 对脚手架的配置文件\r\n复制代码项目地址为 点击查看 ，觉得有用的请Star或者fork哟。当然，网上也有很多优秀的脚手架，大家可以根据自己的需要选择哟。小程序开发框架17年的项目并没有使用开源的框架，直接使用原生小程序写的，开发过程印象中并没有很多的坑，只记得当时用到了一个富文本的插件， wxParse ，现在已5000多个Star了，虽然现在小程序有了富文本组件 rich-text ，但在最近的项目中还是用了这个插件，因为后端的兄弟说，他们不能将html转成 rich-text 需要的数据格式，后端是java的，有使用这个组件的同学，麻烦下面留个言，我要去鄙视后端一下。前文提到自己在项目开发过程中使用过WePY框架，那么下面我就简单列一下现在比较火热的三大小程序框架WePY，mpvue和Taro的特性，然后着重说下WePY：mpvue（美团）彻底的组件化开发能力：提高代码复用性完整的 Vue.js 开发体验方便的 Vuex 数据管理方案：方便构建复杂应用快捷的 webpack 构建机制：自定义构建策略、开发阶段 hotReload支持使用 npm 外部依赖使用 Vue.js 命令行工具 vue-cli 快速初始化项目H5 代码转换编译成小程序目标代码的能力taro （京东）React 语法风格支持使用 npm/yarn 安装管理第三方依赖。持使用 ES7/ES8 甚至更加新的 ES 规范，一切都可自行配置。持使用 CSS 预编译器，例如 Sass 等。持使用 Redux 进行状态管理。持使用 Mobx 进行状态管理。程序 API 优化，异步 API Promise 化等等。WePY （腾讯）上文已列出，此处不再赘述三大框架分别是国内三家大佬的前端团队产物，印象中mpvue和taro都是18年下半年出来的，WePY出来的最早，几乎和小程序同步。mpvue拥抱了vue，taro拥抱了react，WePY握住了vue的手，mpvue和taro都没有用过，我们只是开发个小程序，不用做到H5和RN共用一套代码，所以18年中开发的一个电商小程序选择了WePY，毕竟腾讯的产物，亲儿子。后来了解到，是腾讯的儿子没错，不过是养子，WePY本来是腾讯内部一员工的个人项目，后来腾讯团队看这个项目不错，就由官方来维护了，由此带来了一些问题，曾在掘金看到过对WePY作者的专访（好像是专访，文章我找不到了），作者自己也承认，WePY前期的一些核心代码存在的缺陷，后期很难修复了，像脏检查机制，据说2.0会有很大的改变。贴一张WePY其中的一个 Issue ，我们当时的心情和他是一样一样的，不过我们不用重构了，项目死掉了，哈哈哈哈（悲凉的笑）自己曾经写过一篇 wepy+weappx开发小程序遇到的坑以及解决方案 ，文中列举了开发过程中遇到的一些问题和解决方式，在此就不赘述了，想了解的同学可以点击查看。如果你要问我开发小程序选择那个框架合适？我只能给出一个建议，根据需求来定，如果只是单纯的想做个小程序，就不要用框架了，小程序的语法目前已经很完善了，何必要去学习两套语法呢，出了问题，又改不动他们框架，一句话概括下就是， 小程序原生有的问题他们肯定有，原生没的问题，他们可能给你造出来 。当然，如果有写一套代码适用H5和RN,那么可以考虑下mpvue和taro，作者更新很频繁，有团队维护，至于能不能提高效率，还得看需求，我们现在是不会选用任何框架了，小程序已经玩的很熟，没必要再折腾了。小程序开发建议在开发过程中，我们总结了一些感觉比较好的开发实践，在此奉献一波，大佬别笑哈。目录结构上文中脚手架第三项中贴出的目录结构，是目前我们觉得比较好的一种形式（参照umi项目的建议），按页面组织代码，将一个页面所需要的内容放在同一个文件夹，方便日后的维护和有类似页面开发时候的复制，存在公用组件的时候，放到外部的文件夹中，当一个项目大了以后，这种目录结构，真的很方便。组件的层级组件的层级真的不能太深，2层最好，不能超过3层，之前项目有的封装组件过度，层级太深，后期维护，根据数据传递一层层的去找代码，简直不要太爽（反话）。状态管理目前小程序能用的状态管理框架也是比较多的，Redux，Mobx，还有基于Redux二次开发的像weappx，都很好，在这推荐两个自己用过和打算用的，使用过的 weappx ，打算用的 omi-mp-create ，项目比较小可以不用，大项目还是用上吧，都放到global中，不好维护。频繁setData的功能放到组件中电商项目中，少不了类似倒计时这种功能的，像这种需要频繁setData操作的功能，应该单独放到一个组件中，为啥呢？当你setData的时候，小程序会有一个遍历监听了data数据方法的过程，比如当你setData的时候，小程序wxs中的函数都会执行，在我上文提到自己的脚手架中有这个例子 weapp-quick-start ，感兴趣的可以测试一下。使用WXS小程序对js表达式的支持并不是很好，当然，就算可以，我也曾见过这样的代码<block wx:if=\"{{drawgift.giftDetail.virtualGoods.length>1||((drawgift.giftDetail.realGoods.length>0||drawgift.giftDetail.couponGoods.length>0)&&drawgift.giftDetail.virtualGoods.length>0)}}\">\r\n\r\n复制代码把这些判断的逻辑放到wxs中，统一维护岂不是美哉。还有一点，官方说在 iOS 设备上小程序内的 wxs 会比 javascript 代码快 2 ~ 20 倍，所以，能用还是要用起来的。控制包的大小，分包加载等不用的包，别偷懒，统统删掉，至于分包加载等，推荐看下这篇文章，我就不啰嗦了 微信小程序：一些运行细节及针对性的优化策略"}
{"title": "Hybrid小程序混合开发之路 - 数据交互 ", "author": "Rolan", "pub_time": "2019-1-23 00:34", "content": "很多应用在原生界面中混杂着HTML界面记得xp时代的QQ，有些界面偶尔会弹出熟悉的js错误对话框，还能右键弹出熟悉的IE6的右键菜单，伪装的挺好，差点没认出来，现在的QQ就不知道了。美团、淘宝这些拥有几乎无限界面的手机App，顶部进度条一亮，这是一个H5 没谁了！Electron！好嗨哟~数据交互使用了HTML作界面，那么和原生程序之间的数据交互基本上是少不了的~（仅仅当做浏览器性质来用的就算了）~。如原生程序要控制H5界面变化，就需要由原生程序传出数据到H5。如H5界面用户点击动作触发涉及原生程序业务逻辑的调用，就需要由H5传入数据到原生程序。这两种数据传输组合在一起就成了交互。在自行嵌入浏览器内核、Electron都可以有自己的接口实现，Android、水果~（滑稽，本文与此物种无关，下同）~都有成熟的解决方案。小程序\" style=\"font-size: 21px; line-height: 1.5; margin: 1.3rem 0rem; border-bottom: 3px solid rgb(0, 102, 153); color: rgb(47, 47, 47); font-family: Roboto, \"Hiragino Sans GB\", \"Microsoft Yahei\", \"WenQuanYi Micro Hei\", SimSun, Tahoma, Arial, Helvetica, STHeiti; background-color: rgb(255, 255, 255);\">Hybrid App 与 Hybrid 小程序Hybrid App并非一定是和H5的混合开发，但本文所说的专指H5。同一界面，编写一次代码，就能同时运行在Android、水果、浏览器之上，说没有诱惑力是假的。小程序并非一定指的的某家的小程序，但本文所说的专指微信小程序。拥有一个强大的流量入口，嗯，就只这一点 ~（看好PWA）~。自从微信小程序开放了webview，和Hybrid App就有了共性，然后生了个“Hybrid 小程序”，是我一个人这么叫吗？我不管，我就要叫！然鹅，开发者对小程序底层的话语权几乎为0，小程序给什么我们就吃什么，嗯，真香。虽然提供了webview，但未提直接的供交互手段（记得要双向才能算交互吗，单向传递数据一边玩球）。似乎Hybrid之路已然折戟。Hybrid 小程序数据交互终极手段，合理合法！注：发现有人采用的是websocket来实现的数据交互，原生小程序和H5都通过服务器来中转数据，点评：这也是个好办法。数据传入基本原理：H5使用wx.miniProgram.navigateTo传递数据给小程序原生程序代码。数据传出基本原理：通过改变webview src中的hash，来实现无刷新数据传入原生小程序。最初开放webview时可用，后面有版本不行了，改变src中任意字符会导致重新加载界面，神奇的是现在又恢复了改变hash不会刷新。升级版：通过改变后台webview src中的hash，实现数据传入我们后台页面，不管有没有重新加载，hash始终能被我们的H5代码接收（而且省去了处理url变化的问题）。然后由后台页面传输数据给前台页面。实战举个支付吧，点击H5内的支付按钮，执行完业务逻辑，支付条件准备完毕，现在需要调起微信支付。小程序启动小程序启动。启动Response.wxml，webview加载后台页面。启动Main.wxml，保留Response.wxml后台页面在后台运行，前台主界面加载页面。启动完毕。开始支付主界面请求jssdk wx.miniProgram.navigateTo接口向Request.wxml界面发起请求，path中携带请求数据。Request.wxml原生程序接收到请求，发现支付请求并不需要保留界面，立马返回上一个界面(前台主界面)；然后后台继续处理支付请求，调起微信支付。前台主界面H5此时应该是在等待Request.wxml的响应结果，并且微信已经弹出支付功能。用户支付完成，Request.wxml残留代码收到支付响应结果，立马通知Response.wxml修改后台页面src中的hash，响应结果数据包含在其中。后台页面监听到hash change事件，或 页面刚刚加载完毕事件。从hash中拿到响应数据。后台页面把响应数据写入localStroage，前台页面监听到localStroage数据。成功得到支付响应数据。问题缺陷第2步虽然立即返回了，但还是会有一个短暂的界面切换动画，不过这种数据交互本来就是重量级的，也不可能频繁调用，Android和水果都是一样的，所以用户体验就是这么可观。改变webview src hash产生的行为是不可预测的 ，任性的版本，如果会刷新页面，延迟会比较大，甚至导致两次调用之间相互覆盖结果。应用案例笔者最近开发的小程序《祝福贺卡助手》，主功能采用的纯web网页，底层和微信小程序的数据交互就是本文介绍的这套模式。有2个比较重要的交互接口，一个是获取用户数据、另外一个是调起分享；当然还有一堆其他辅助类的接口。扫码体验网页版：小程序版：界面和功能开发一遍，网页、小程序通吃~ 这就是Hybrid小程序的魅力！围绕着小程序《祝福贺卡助手》的开发和审核上线过程，对于其中一些有趣的东西，我会分享出来。下篇内容预告：Hybrid小程序混合开发之路 - H5录音和水果的对抗。"}
{"title": "以小程序为例，学习如何将异步回调接口 Promise 化 ", "author": "Rolan", "pub_time": "2019-1-23 00:42", "content": "前言\r\nES6 标准的 Promise 解决了 Javascript 代码中比较常见的回调地狱问题，搭配 async/await 可以用同步的方式写异步逻辑，大大提高了开发效率。\r\n但是至今仍有很多库没有实现 Promise 化的接口，其中就包括微信小程序的 api。\r\n为了不向恶势力妥协，写出风格统一的代码，我们有必要了解何为 Promise。\r\n本文假定读者有一定 JavaScript 基础，同时了解 Promise 的基本用法。\r\n回调接口\r\n异步回调接口指的是通过传递函数来处理异步方法调用，一般有两种方式。\r\n\r\n\r\n小程序方式\r\n分别传递成功和失败的回调以处理两种不同情况\r\nwx.showToast({\r\n  title: 'Hello, world',\r\n  success: () => console.log('success'),\r\n  fail: () => console.log('failure'),\r\n})\r\n复制代码\r\n\r\nMongoDB 方式\r\n传递一个以 error 为首参数的回调用以鉴别是否调用成功\r\ndb.find({ name: 'Idan Loo' }, (err, data) => {\r\n  if (err) {\r\n    // err 是调用失败的原因\r\n    console.log(err)\r\n    return\r\n  }\r\n  // data 就是异步传递回来的参数\r\n  console.log(data)\r\n})\r\n复制代码\r\n\r\n两种方式各有千秋，这里仅讨论微信方式，MongoDB 方式的接口 Promise 化相信各位可以举一反三。\r\nPromise 化\r\n简单实现\r\n以 showToast 为例\r\nconst showToast = option =>\r\n  new Promise((resolve, reject) => \r\n    wx.showToast({...option,\r\n      success: resolve,\r\n      fail: reject,\r\n    })\r\n  )\r\n\r\nshowToast({ title: 'Hello, Promise' })\r\n  .then(() => console.log('success'))\r\n  .catch(() => console.log('failure')) \r\n复制代码你已经知道了如何 Promise 化小程序的接口，现在你只需要重复上面的代码，将所有你需要用到的接口改为 Promise 的即可。\r\n高级一点的实现\r\n复制粘贴一把梭虽然快，但是作为一名程序员，自然应该追求更简洁的实现。\r\n通过观察，小程序所有的异步接口都采用了相同的形式，并且都位于 wx 对象中，故我们可以抽象出通用的 promisify 方法用以 Promise 化小程序的接口\r\nconst promisify = name => option => \r\n  new Promise((resolve, reject) =>\r\n    wx[name]({...option,\r\n      success: resolve,\r\n      fail: reject,\r\n    })\r\n  )\r\n\r\nconst showToast = promisify('showToast')\r\nconst request = promisify('request')\r\n复制代码现在只需一行代码，就可以 Promise 化小程序的接口，赶紧把之前写的丑陋的回调代码改过来吧！\r\n更高级的实现\r\n如果你跟我一样，代码洁癖到上述代码都接受不了的话，那恭喜你，通过 Proxy 可以更好的实现我们的目标。\r\nconst pro = new Proxy(wx, {\r\n  get(target, prop) {\r\n    return promisify(prop)\r\n  }\r\n})\r\n\r\npro.showToast({ title: 'Hello, world' }).then(...)\r\npro.request({ url: 'https://github.com' }).then(...)\r\n复制代码在 promisify 方法的基础上，给 wx 对象加了个代理，现在你可以像使用 wx 对象一样使用 pro，并且所有的异步方法都变成了 Promise 形式的！\r\n无需实现\r\n最好的实现就是交给别人实现，正好我已经把前文中的代码打包上传, minapp-promise，不足 1k，开箱即用。\r\n能看到这里着实不易，希望你们能给我点个赞，顺便在 GitHub 给我个星星就更好了。\r\n手机码字，如有错漏，万望斧正。"}
{"title": "小程序使用 Iconfont 的正确姿势 ", "author": "Rolan", "pub_time": "2019-1-24 00:12", "content": "现如今移动设备分辨率不胜枚举，传统的标量图标要分别导出 1 倍图、2 倍图、3 倍图等以适应高分辩率设备。这无疑大大增加了设计师和客户端开发的工作量。矢量图以其无损缩放的优点，在图标方面有着极大的优势。Iconfont 是由阿里推出，功能强大且图标内容很丰富的矢量图标库，提供矢量图标下载、在线存储、格式转换等功能，几乎国内成了矢量图标库的事实标准。每个 Iconfont 项目都可以生成一个远程 .css 文件，下文以 //at.alicdn.com/t/font_883452_bqb4vsc7km8.css 为例。你可以查阅教程了解如何生成 .css 文件。正常 Iconfont 的使用流程是在 HTML 的 head 标签中引入样式文件，然后通过类名调用图标<html>\r\n    <head>\r\n        <link href=\"//at.alicdn.com/t/font_883452_bqb4vsc7km8.css\" />\r\n    </head>\r\n    <body>\r\n        <!-- 这是一个名为 plus 的 icon -->\r\n        <i class=\"iconfont icon-plus\"></i>\r\n    </body>\r\n</html>\r\n复制代码不幸的是小程序不支持引入外部 css 文件，为此我寻遍网络，竟没有找到 Iconfont 在小程序中的正确用法。本文根据我在实践经验所得，是我目前能找到在小程序中使用 Iconfont 最简的方法。引入虽然小程序不支持引入外部样式表，但 .wxss 文件本质上就是 .css 文件，因此我们可以将 Iconfont 的样式表保存到本地的 .wxss 中。下载 at.alicdn.com/t/font_883452_bqb4vsc7km8.css 至 /iconfont.wxss ，并在 app.wxss中引入@import \"/iconfont.wxss\";\r\n复制代码在 .wxml 文件中使用<text class=\"iconfont icon-plus\"></text>\r\n复制代码现在应该可以在开发者工具中看到你想要的图标了。解决了基本的使用问题之后，我们发现，由于小程序组件内部有独立的类作用域，因此在 app.wxss 中引入的 .iconfont 和 .icon-plus 并不能在自定义组件内生效，所以你需要在所有需要用到 Iconfont 的组件内，分别引入 iconfont.wxss 。组件化如果你看过我之前的文章，应该知道我对冗余代码深恶痛绝。自定义组件就是解决重复引入的手段。"}
{"title": "微信小程序-flex布局中align-items和align-self区别 ", "author": "Rolan", "pub_time": "2019-1-24 00:24", "content": "首先看看菜鸟教程中关于align-items和align-self的定义align-items：align-items 属性定义flex子项在flex容器的当前行的侧轴（纵轴）方向上的对齐方式。（对齐弹性盒的各项元素）align-self：align-self 属性定义flex子项单独在侧轴（纵轴）方向上的对齐方式。（对齐弹性对象元素内的某个项）从定义上可以看出是对齐”目标“上存在差异，这样看上去似乎不太便于理解/*index.wxml*/\r\n<view class=\"container\">\r\n\r\n  <view class=\"item\" style='order:/4'>\r\n      1\r\n  </view>\r\n\r\n\r\n  <view class=\"item\">\r\n      2\r\n  </view>\r\n  \r\n  <view class=\"item  i3\">\r\n      3\r\n  </view>\r\n \r\n  <view class=\"item\">\r\n       4\r\n  </view>\r\n\r\n  \r\n\r\n\r\n</view>/*index.wxss*/\r\n.container{\r\n  height: 100px;\r\n  width: 100%;\r\n  background-color: green;\r\n  display: flex;\r\n  /* flex-direction: column; */\r\n  flex-direction: row;\r\n  flex-flow: wrap;\r\n\r\n  justify-content:space-between;  \r\n  align-items: flex-start;\r\n}\r\n.item{\r\n  width: 100rpx;\r\n  height: 100rpx;\r\n  background-color: yellow;\r\n  border: 1px solid white;\r\n\r\n\r\norder: 3;\r\n}\r\n.i3{\r\n  display: flex;\r\n  align-items: flex-end;\r\n  /* flex-grow: 1; */\r\n  order: 1;\r\n}这里用align-items显示的结果如图，可以看到此时文字是在下方，而色块并没到下方如果将代码align-items换为align-self，整个块都以从下往上的方式排列了，而数字的位置仍然是在左上角"}
{"title": "微信小程序复选框实现 多选一功能 ", "author": "Rolan", "pub_time": "2019-1-24 00:32", "content": "功能实现界面data: {\r\n    checkboxItems: [\r\n      { name: '全天(1-8节)', value: 'allday' },\r\n      { name: '上午(1-4节)', value: 'am' },\r\n      { name: '下午(5-8节)', value: 'pm' },\r\n      { name: '晚上(晚自习)', value: 'night' },\r\n    ]\r\n  }  想要实现的功能 四个复选框中只能选一个，且选中另一个会取消其余选中,且能保存选择的value值JS代码实现checkboxChange: function (e) {\r\n    var that = this;\r\n    let checkboxValues=null;\r\n    let checkboxItems = this.data.checkboxItems, values = e.detail.value\r\n    for (var i = 0, lenI = checkboxItems.length; i < lenI; ++i) {\r\n      if(checkboxItems[i].value==values[values.length-1]){\r\n        checkboxItems[i].checked=true;\r\n        checkboxValues = checkboxItems[i].value;\r\n      }\r\n      else{\r\n        checkboxItems[i].checked = false;\r\n      }\r\n    }\r\n    console.log(checkboxValues)\r\n    that.setData({ checkboxItems, checkboxValues })\r\n  }  前端代码 <view class=\"weui-cells weui-cells_after-title\">\r\n      <checkbox-group class=\"weui-flex\" bindchange=\"checkboxChange\">\r\n        <label class=\"weui-cell weui-check__label weui-flex__item\" wx:for=\"{{checkboxItems}}\" wx:key=\"value\">\r\n          <checkbox class=\"weui-check\" value=\"{{item.value}}\" checked=\"{{item.checked}}\" />\r\n          <view class=\"weui-cell__hd weui-check__hd_in-checkbox\">\r\n            <icon class=\"weui-icon-checkbox_circle\" type=\"circle\" size=\"23\" wx:if=\"{{!item.checked}}\"></icon>\r\n            <icon class=\"weui-icon-checkbox_success\" type=\"success\" size=\"23\" wx:if=\"{{item.checked}}\"></icon>\r\n          </view>\r\n          <view class=\"weui-cell__bd\">{{item.name}}</view>\r\n        </label>\r\n      </checkbox-group>\r\n    </view>对应的CSS样式是WeUI"}
{"title": "微信小程序-锚点定位 ", "author": "Rolan", "pub_time": "2019-1-25 00:32", "content": "引言：在商品详情页面，一般会有商品图显示、商品主要信息、评价、商品详情等，这时候最好是在最上面加上导航，点击导航定位到对应的页面位置，比如京东的商品详情页面对于一般的PC端网页，只需要使用 <a href=\"#element_Id\"> ，然后在地址栏最后加上#element_Id，就能很方便的跳转到该元素的位置。那么，微信小程序该怎样解决呢？解决思路查找微信小程序的开发文档，发现可以使用scroll-view组件中的属性scroll-into-view实现重点将page的高度设置为100%；导航下面的内容部分必须用 <scroll-view> 包起来设置scroll-view的高度=屏幕的高度-导航的高度设置scroll-view的属性 scroll-into-view=\"{{toView}}\"设置scroll-view的属性 scroll-y=\"true\"设置锚点 <view id=\"position1\">注意：第4、5步不能换位置，一定是scroll-into-view在scroll-y的前面上代码WXNL<view class=\"navigateBox\">\r\n    <view @tap=\"toViewClick\" data-hash=\"productBox\" class=\"title {{toView=='productBox' ? 'checked':''}}\">\r\n      <image wx:if=\"{{toView=='productBox'}}\" src=\"../images/position.jpg\"/>商品</view>\r\n    <view @tap=\"toViewClick\" data-hash=\"commentBox\" class=\"title {{toView=='commentBox' ? 'checked':''}}\">\r\n      <image wx:if=\"{{toView=='commentBox'}}\" src=\"../images/position.jpg\"/>评价</view>\r\n    <view @tap=\"toViewClick\" data-hash=\"infoBox\" class=\"title {{toView=='infoBox' ? 'checked':''}}\">\r\n      <image wx:if=\"{{toView=='infoBox'}}\" src=\"../images/position.jpg\"/>详情</view>\r\n</view>\r\n\r\n<scroll-view style=\"height:{{winHeight}}\" scroll-into-view=\"{{toView}}\" scroll-y=\"true\">\r\n    <view id=\"productBox\">商品图</view>\r\n    <view id=\"commentBox\">商品评价</view>\r\n    <view id=\"infoBox\">商品详情</view>\r\n</scroll-view>\r\n复制代码JSdata = {\r\n    winHeight: '100%',\r\n    toView: 'productBox',//锚点跳转的ID\r\n}\r\nonLoad(){\r\n    let that = this;\r\n    wx.getSystemInfo({\r\n      success: function (res) {\r\n        //屏幕的宽度/屏幕的高度 = 微信固定宽度(750)/微信高度\r\n        that.winHeight = res.windowHeight-(res.windowWidth*90/750)+'px';//90为导航的告诉80+10(margin-bottom)\r\n      }\r\n    });\r\n}\r\nmethods = {\r\n    toViewClick: function (e) {\r\n      this.toView = e.target.dataset.hash;\r\n    }\r\n}\r\n复制代码WXSS<style lang=\"less\">\r\n\r\n  page{\r\n    height: 100%;\r\n  }\r\n\r\n  .navigateBox{\r\n    background: #fff;\r\n    height: 80rpx;\r\n    padding: 0 100rpx;\r\n    margin-bottom: 10rpx;\r\n\r\n    .title{\r\n      margin: 20rpx 46rpx;\r\n      float: left;\r\n      font-size: 27rpx;\r\n      width: 60rpx;\r\n      padding-left: 30rpx;\r\n    }\r\n\r\n    image{\r\n      width: 30rpx;\r\n      height: 30rpx;\r\n      margin-left: -30rpx;\r\n    }\r\n\r\n    .checked{\r\n      color: #f73c3c;\r\n    }\r\n  }\r\n复制代码"}
{"title": "小程序从手动埋点到自动埋点 ", "author": "Rolan", "pub_time": "2019-1-25 00:52", "content": "前言\r\n小程序由于封闭性较强，要像web应用一样实现灵活的数据收集，会有一定难度。目前开源的埋点SDK，一般采用手动埋点的方式，这种方式有较强的侵入型，为了解决这个问题就有了该文章。\r\n手动埋点\r\n以腾讯移动分析的SDK为例，如果要记录埋点信息，只要插入一句代码即可\r\n// 例如，记录搜索行为\r\nsearch(keyword) {\r\n   if (keyword) {\r\n       ...业务代码\r\n   }\r\n   mta.Event.stat(\"ico_search\", {\"query\":keyword});\r\n}\r\n复制代码示例代码看起来是比较简洁的，但是埋点需要收集的数据往往不是单一的，复杂的埋点代码插入业务代码，会影响代码的阅读体验，而且埋点代码散落在各个地方，不方便管理。\r\n由于手动埋点必须插入到函数中，有时候我们为了获取页面某一元素点击信息，产生了一种叫无业务相关埋点，简单来说就是你的函数定义，就只有埋点代码，当这种埋点频繁出现，代码会被严重污染。\r\n// wxml\r\n<view bindtap=\"track\">这只是一个展示view</view>\r\n\r\n//js \r\ntrack() {\r\n  mta.Event.stat(\"eleClick\", {\"name\":xxxxx});\r\n}\r\n复制代码另外，由于PM会频繁调整埋点信息，而埋点是一个繁琐又无聊的工作，基于Don't Repeat Yourself 原则，手动埋带要不得。\r\n总结以上，手动埋点有下列问题\r\n\r\n影响代码的阅读体验\r\n埋点代码散落在各个地方，不方便管理\r\n代码会被污染\r\n埋点是一个繁琐又无聊的工作\r\n\r\n自动埋点\r\n实现思路：监听用户点击-->读取埋点配置JOSN，判断是否需要上报--> 上报数据\r\n1、小程序监听用户点击行为\r\nweb应用监听用户点击行为是比较容易，但是小程序没有提供Dom的事件监听，不过我们可以通过事件冒泡的方式捕获。\r\n// web监听页面点击\r\ndocument.addEventListener('click',(e) => {console.log(e)})\r\n\r\n// 小程序监听页面点击，用户的点击行为都会执行elementTracker方法\r\n<view catchtap='elementTracker'>\r\n  <view class='buy-now'>\r\n     <button bindtap='buy' animation=\"{{scaleAnim}}\">立即购票</button>\r\n  </view>\r\n</view>\r\n复制代码2、判断点击位置是否落在监听元素中\r\n假设需要监听用户是否点击class为buy-now元素，可以通过获取buy-now元素长宽，定位和点击位置坐标判断是否出现重叠，以判断是否被点击。\r\n/**\r\n * 判断点击是否落在目标元素\r\n * @param {Object} clickInfo 用户点击坐标\r\n * @param {Object} boundingClientRect 目标元素信息\r\n * @param {Object} scrollOffset 页面位置信息\r\n * @returns {Boolean}\r\n */\r\nexport const isClickTrackArea = function (clickInfo, boundingClientRect, scrollOffset) {\r\n    if (!boundingClientRect) return false;\r\n    const { x, y } = clickInfo.detail; // 点击的x y坐标\r\n    const { left, right, top, height } = boundingClientRect;\r\n    const { scrollTop } = scrollOffset;\r\n    if (left < x && x < right && scrollTop + top < y && y < scrollTop + top + height) {\r\n        return true;\r\n    }\r\n    return false;\r\n};\r\n复制代码3、通过配置表声明埋点\r\n为了解决代码入侵问题，可以将所有埋点信息统一管理，通过配置表的方式，除了方便管理，以后还可以做到动态配置，在服务端配置完毕下发到客户端。\r\nconst tracks = {\r\n  path: 'pages/film/detail',\r\n  elementTracks: [\r\n    {\r\n      element: '.buy-now',  // 声明需要监听的元素\r\n      dataKeys: ['film.filmId'], // 声明需要获取Data下的哪些数据\r\n    },\r\n  ]\r\n};\r\n复制代码4、对页面函数埋点\r\n有些场景我们除了对页面元素点击埋点，还要对页面函数进行埋点，例如用户下拉刷新的时候，可以对原方法进行包装，插入埋点代码。\r\n rewritePage() {\r\n    const originPage = Page;\r\n    Page = (page) => {\r\n      Object.keys(page).forEach((methodName) => {\r\n       // 执行埋点逻辑\r\n        typeof page[methodName] === 'function' && this.recordPageFn(page, methodName);\r\n      });\r\n      // 执行原Page对象\r\n      return originPage(page);\r\n    };\r\n  }\r\n复制代码最后\r\n完整的代码已经封装成SDK了，可以快速集成到项目\r\ngithub.com/zhengguoron…"}
{"title": "分享一款拥有历史搜索记录的微信小程序搜索框--wx-search-have-history ... ", "author": "Rolan", "pub_time": "2019-1-28 00:12", "content": "wx-search-have-history一款拥有历史搜索记录的微信小程序搜索框wx-search-have-history使用前提：使用此组件需要依赖小程序基础库 2.2.1 或以上、及开发者工具 1.02.1808300 或以上，同时依赖开发者工具的 npm 构建。具体详情可查阅微信小程序 npm 支持文档。使用效果1、 通过输入进行搜索2、清除单个（全部）历史搜索记录3、点击历史搜索记录进行搜索PS：若想要获得上图中的效果，可参考 test/demo 中的例子实现。使用方法1、 安装 wx-search-have-historynpm install --save wx-search-have-history2、 在需要使用 wx-search-have-history 的页面 page.json 中添加 wx-search-have-history 自定义组件配置{\r\n  \"usingComponents\": {\r\n    \"searchHaveHistory\": \"wx-search-have-history\"\r\n  }\r\n}3、 WXML 文件中引用 wx-search-have-history：调用history组件的同时，需要在调用wx-search-have-history的页面page.js绑定事件接收搜索值（bind:searchEvent=\"searchEvent\"），且须在searchEvent函数里调用wx.hideLoding()，可参考 test/demo/pages/index/index.js 中的例子。<searchHaveHistory id=\"history\"\r\n    bind:searchEvent=\"searchEvent\">\r\n</searchHaveHistory>wx-search-have-history的属性介绍如下：在调用组件的时候，id必须填写且唯一。因为此id作为本地缓存的key值。注意事项在调用wx-search-have-history的页面page.js需绑定事件接收搜索值（bind:searchEvent=\"searchEvent\"），且须在searchEvent函数里调用wx.hideLoding(),可参考 test/demo/pages/index/index.js 中的例子。项目地址：github传送门这是我第一次尝试，如有不当或需改进之处，请君指出，感谢万分！！！"}
{"title": "小程序第三方框架对比 ( wepy / mpvue / taro ) ", "author": "Rolan", "pub_time": "2019-1-28 00:23", "content": "众所周知如今市面上端的形态多种多样，手机Web、ReactNative、微信小程序, 支付宝小程序, 快应用等,每一端都是巨大的流量入口，当业务要求同时在不同的端都要求有所表现的时候，针对不同的端去编写多套代码的成本显然非常高，这时候只编写一套代码就能够适配到多端的能力就显得极为需要。但面对目前市面上成熟的小程序第三方框架如何针对自己的需求进行选择也是一个麻烦事,本文针对当前市面上的三大转译框架进行一个综合对比,希望能对大家的技术选择有所帮助,如有哪里不妥的地方希望指正;在这里我通过对目前已开源的三种常用小程序框架做一个综合对比, 还有一个叫nanchi的基于react的小程序转译框架,由于没来的及研究暂不做比较;WEPY tencent.github.io/wepy/docume…腾讯团队开源的一款类vue语法规范的小程序框架,借鉴了Vue的语法风格和功能特性,支持了Vue的诸多特征，比如父子组件、组件之间的通信、computed属性计算、wathcer监听器、props传值、slot槽分发，还有很多高级的特征支持：Mixin混合、拦截器等;WePY发布的第一个版本是2016年12月份，也就是小程序刚刚推出的时候，到目前为止，WePY已经发布了52个版本, 最新版本为1.7.2;MpVue mpvue.com/mpvue/#-htm…美团团队开源的一款使用 Vue.js 开发微信小程序的前端框架。使用此框架，开发者将得到完整的 Vue.js 开发体验，同时为 H5 和小程序提供了代码复用的能力。mpvue在发布后的几天间获得2.7k的star,上升速度飞起,截至目前为止已经有13.7k的star;Tarotaro.aotu.io/京东凹凸实验室开源的一款使用 React.js 开发微信小程序的前端框架。它采用与 React 一致的组件化思想，组件生命周期与 React 保持一致，同时支持使用 JSX 语法，让代码具有更丰富的表现力，使用 Taro 进行开发可以获得和 React 一致的开发体验。,同时因为使用了react的原因所以除了能编译h5, 小程序外还可以编译为ReactNative;生命周期同为vue规范的mpvue和wepy的生命周期和各种方法不尽相同wepywepy生命周期基本与原生小程序相同,再此基础上糅合了一些vue的特性; 对于WePY中的methods属性，因为与Vue中的使用习惯不一致，非常容易造成误解，这里需要特别强调一下：WePY中的methods属性只能声明页面wxml标签的bind、catch事件，不能声明自定义方法，这与Vue中的用法是不一致的。 `import wepy from 'wepy';export default class MyPage extends wepy.page { // export default class MyComponent extends wepy.component { customData = {} // 自定义数据customFunction () {}  //自定义方法\r\n\r\nonLoad () {}  // 在Page和Component共用的生命周期函数\r\n\r\nonShow () {}  // 只在Page中存在的页面生命周期函数\r\n\r\nconfig = {};  // 只在Page实例中存在的配置数据，对应于原生的page.json文件\r\n\r\ndata = {};  // 页面所需数据均需在这里声明，可用于模板数据绑定\r\n\r\ncomponents = {};  // 声明页面中所引用的组件，或声明组件中所引用的子组件\r\n\r\nmixins = [];  // 声明页面所引用的Mixin实例\r\n\r\ncomputed = {};  // 声明计算属性（详见后文介绍）\r\n\r\nwatch = {};  // 声明数据watcher（详见后文介绍）\r\n\r\nmethods = {};  // 声明页面wxml中标签的事件处理函数。注意，此处只用于声明页面wxml中标签的bind、catch事件，自定义方法需以自定义方法的方式声明\r\n\r\nevents = {};  // 声明组件之间的事件处理函数\r\n复制代码}`mpvuempvue 除了 Vue 本身的生命周期外，还兼容了小程序生命周期，这部分生命周期钩子的来源于微信小程序的 Page， 除特殊情况外，不建议使用小程序的生命周期 钩子。简单示例taro与react生命周期完全相同列表渲染在列表渲染上三者也分别有不同的应用方法wepy当需要循环渲染WePY组件时(类似于通过wx:for循环渲染原生的wxml标签)，必须使用WePY定义的辅助标签mpvue使用v-for与vue一致,只是需要注意一点，嵌套列表渲染，必须指定不同的索引！taro的列表循环用法基本与react相同,有一点需要注意,在 React 中，JSX 是会编译成普通的 JS 的执行，每一个 JSX 元素，其实会通过 createElement 函数创建成一个 JavaScript 对象（React Element），因此实际上你可以这样写代码 React 也是完全能渲染的：但是 Taro 中，JSX 会编译成微信小程序模板字符串，因此你不能把 map 函数生成的模板当做一个数组来处理。当你需要这么做时，应该先处理需要循环的数组，再用处理好的数组来调用 map 函数。例如上例应该写成：事件处理mpvue目前全支持小程序的事件处理器,引入了 Vue.js 的虚拟 DOM ，在前文模版中绑定的事件会被挂在到 vnode 上，同时 compiler 在 wxml 上绑定了小程序的事件，并做了相应的映射，所以你在真实点击的时候通过 runtime 中 handleProxy 通过事件类型分发到 vnode 的事件上，同 Vue 在 WEB 的机制一样，所以可以做到无损支持。同时还顺便支持了自定义事件和 $emit 机制事件映射表，左侧为 WEB 事件，右侧为 小程序 对应事件**click** : 'tap',<br>\r\n**touchstart**: 'touchstart',<br>\r\n**touchmove**: 'touchmove',<br>\r\n**touchcancel**: 'touchcancel',<br>\r\n**touchend**: 'touchend',<br>\r\n**tap**: 'tap',<br>\r\n**longtap**: 'longtap',<br>\r\n**input**: 'input',<br>\r\n**change**: 'change',<br>\r\n**submit**: 'submit',<br>\r\n**blur**: 'blur',<br>\r\n**focus**: 'focus',<br>\r\n**reset**: 'reset',<br>\r\n**confirm**: 'confirm',<br>\r\n**columnchange**: 'columnchange',<br>\r\n**linechange**: 'linechange',<br>\r\n**error**: 'error',<br>\r\n**scrolltoupper**: 'scrolltoupper',<br>\r\n**scrolltolower**: 'scrolltolower',<br>\r\n**scroll**: 'scroll'<br>\r\n复制代码踩坑注意(官方文档)：列表中没有的原生事件也可以使用例如 bindregionchange 事件直接在 dom 上将bind改为@ @regionchange,同时这个事件也非常特殊，它的 event type 有 begin 和 end 两个，导致我们无法在handleProxy 中区分到底是什么事件，所以你在监听此类事件的时候同时监听事件名和事件类型既 <map @regionchange=\"functionName\" @end=\"functionName\" @begin=\"functionName\">小程序能力所致，bind 和 catch 事件同时绑定时候，只会触发 bind ,catch 不会被触发，要避免踩坑。事件修饰符 .stop 的使用会阻止冒泡，但是同时绑定了一个非冒泡事件，会导致该元素上的 catchEventName 失效！ .prevent 可以直接干掉，因为小程序里没有什么默认事件，比如submit并不会跳转页面 .capture 支持 1.0.9 .self 没有可以判断的标识 .once 也不能做，因为小程序没有 removeEventListener, 虽然可以直接在 handleProxy 中处理，但非常的不优雅，违背了原意，暂不考虑其他 键值修饰符 等在小程序中压根没键盘，所以。。。wepy事件绑定区别于vue,根据原生小程序事件提供了语法优化绑定事件bindtap=\"click\" 替换为 @tap=\"click\"，取消冒泡原catchtap=\"click\"替换为@tap.stop=\"click\"。捕获监听事件capture-bind:tap=\"click\" 替换为 @tap.capture=\"click\"，中断捕获监听capture-catch:tap=“click\"替换为 @tap.capture.stop=\"click\"。Taro 元素的事件处理和 DOM 元素的很相似。但是有一点语法上的不同:Taro 事件绑定属性的命名采用驼峰式写法，而不是小写。 如果采用 JSX 的语法你需要传入一个函数作为事件处理函数，而不是一个字符串 (DOM 元素的写法)。 例如，传统的微信小程序模板：Taro 中稍稍有点不同：在 Taro 中另一个不同是你不能使用 catchEvent 的方式阻止事件冒泡。你必须明确的使用 stopPropagation。例如，阻止事件冒泡你可以这样写：request请求wepy对wx.request做了接受参数的修改,值得一提的是它提供了针对全局的intercapter拦截器拦截器taro对request进行了二次封装,可以使用Taro.request(OBJECT)发起网络请求，支持 Promise 化使用。mpvue没有对request做特殊优化,与原生相同,可以自己根据需要进行封装"}
{"title": "小程序点睛之三：才不是你想的那种组件 ", "author": "Rolan", "pub_time": "2019-1-28 00:37", "content": "小程序点睛系列写到第三篇，我才在昨夜临睡前想到这个名字。官方文档讲过的东西我不重复，我只在你会写的基础上，帮你画上点睛一笔。这一篇，是我与小程序鏖战半年苦心孤诣的成果，满满干货。自定义组件从基础库 1.6.3 开始支持，用来抽象功能组件，以便在多个页面复用。如果你有 React 或 Vue等前端类库的开发经验，对自定义组件一定不会陌生。小程序吸收了 Vue 的模板语法， React 的状态管理方式，再加上 Web Component 的 Shadow DOM 残缺版本，总之就是一边抄一点，形成了独具特色的小程序风格组件。这使得你之前在其它类库上获得的经验不能完全适用。接下来，我们就一起聊聊小程序组件的奇技淫巧。JavaScript 部分小程序将组件数据分为父组件传递来的 properties 和自身持有的 data ，这点与主流前端框架类似，我们重点关注 properties 。组件的 property 接收 type 、 value 、 observer 三个参数type: 属性类型，目前支持 String , Number , Boolean , Object , Array , null从 .wxml 传递过来的值到 .js 之前会先经过类型转换。如果想传递混合类型值（如既可能是String 也可能是 Number 的值），可以将 type 设置为 null ，可以避免默认的类型转换。value: 默认值如果不设置 value 的值，那该 property 的默认值就是其类型的零值。对应如下：String => ''\r\nNumber => 0\r\nBoolean => false\r\nObject => {}\r\nArray => []\r\nnull => null\r\n复制代码observer: 属性被改变后执行的函数由于小程序自身不支持 watch ，故而无法监听 data 中某一项的改变。但与 React 不同的是，组件的 properties 在组件运行时会被整合入 data 中，通过 this.data 获取，并且可以调用 this.setData 改动 properties 的值。 因此可以将需要监听的 data 放于 properties 中，利用 observer 监听。同时，为表示其为内部状态，建议以下划线（_）开头，且不再外部设置其值。observer 还可以用来减少 .wxml 模板的重复代码。例如父组件传递了一个 source 对象，要求组件显示其姓名与年龄// component.js\r\nComponent({\r\n    properties: {\r\n        source: Object,\r\n    }\r\n})\r\n复制代码<!-- component.wxml -->\r\n<view>{{ source.name }}</view>\r\n<view>{{ source.age }}</view>\r\n复制代码利用 observer 可以写成// component.js\r\nComponent({\r\n    properties: {\r\n        source: {\r\n            type: Object,\r\n            observer(val) {\r\n                this.setData(val)\r\n            }\r\n        }\r\n    }\r\n})\r\n复制代码<!-- component.wxml -->\r\n<view>{{ name }}</view>\r\n<view>{{ age }}</view>\r\n复制代码这对体量较大的组件犹为有效。同时，将 source 封装为 behavior ，可以最大限度的减少冗余代码// sourceBehavior.js\r\nexport default Behavior({\r\n\tproperties: {\r\n        source: {\r\n            type: Object,\r\n            observer(val) {\r\n                this.setData(val)\r\n            }\r\n    }\r\n  }\r\n})\r\n\r\n// component.js\r\nimport sourceBehavior from 'path/to/sourceBehavior.js'\r\n\r\nComponent({\r\n    behaviors: [sourceBehavior]\r\n})\r\n复制代码WXML 部分.wxml 模块与 Vue 模板大同小异，唯一值得了解的是由于小程序不完全实现了 Shadow DOM ，Vue 中 <template> 标签只能有一个根节点的限制是不存在的。因此在大多数情况下，你都不需要给 .wxml 额外添加根节点。<!-- good.wxml -->\r\n<view>{{ name }}</view>\r\n<view>{{ age }}</view>\r\n\r\n<!-- bad.wxml -->\r\n<view>\r\n\t<view>{{ name }}</view>\r\n    <view>{{ age }}</view>\r\n</view>\r\n复制代码WXSS 部分inherit 关键字我们可以通过将属性值设置为 inherit 来有效减少代码冗余。如果你想保持节点属性与父节点一致，就应当使用这个关键字。回想一下 小程序点睛之二：小程序使用 Iconfont 的正确姿势 ，默认 Iconfont 下载的 CSS 文件中定义了 .iconfont 类的字体大小为 16px ，如果你不想每次更新改动这一值，那么可以在组件样式表中添加.iconfont {\r\n    font-size: inherit;\r\n}\r\n复制代码组件样式表的优先级要高过外部引入的样式表，所以原本的 font-size: 16px 就会被覆盖， .iconfont 的字体大小就会跟其父节点一致。注意：这里 .iconfont 的父节点并不是逻辑上的父节点，而是 shadow-root 。:host 选择器你可以在开发者工具中看到每个自定义组件的 shadow-root ，其默认是行内元素，你可以在组件样式表中通过 :host 选择器修改它的样式:host {\r\n    display: block;\r\n    background: red;\r\n}\r\n复制代码外部样式表所有的属性都是直接作用在 shadow-root （而非模板中的根节点）上，例如<!-- iconfont.wxml -->\r\n<text class=\"iconfont icon-{{icon}}\"></text>\r\n\r\n<!-- page.wxml -->\r\n<iconfont class=\"icon\" icon=\"upload\"></iconfont>\r\n复制代码/* page.wxss */\r\n.icon {\r\n    color: green;\r\n}\r\n\r\n/* iconfont.wxml */\r\n.iconfont {\r\n    color: red;\r\n}\r\n复制代码你会发现图标的颜色是红色而不是绿色。因为 .icon 是样式作用于 shadow-root ， .iconfont 是其子节点，继承其 color 属性，但由于 .iconfont 优先级更高，所以颜色是为红色。优先级关系为 :host 选择器 < 外部样式 < 子节点样式。利用这个特点，配合 CSS 变量，可以达到意想不到的效果。CSS 变量现阶段支持各浏览器的支持度并不高，版本稍旧的浏览器就会遇到问题。但小程度已经完全支持了这个特性。由于小程序使用了 Shadow DOM ，因此在组件内是无法使用全局定义的样式类的。 但是 ，CSS 是可继承并且是全局可用的。因此，我们可以将常用的样式定义在 app.wxss 内，并在任意页面或组件内使用/* app.wxss */\r\npage {\r\n    --primary-color: #aabbcc;\r\n    --accent-color: #ddeeff;\r\n    --spacing: 32rpx;\r\n}\r\n\r\n/* other.wxss */\r\n.component {\r\n    background: var(--primary-color);\r\n    padding: var(--spacing);\r\n}\r\n复制代码如此，你只需要对 app.wxss 稍作修改，就可以改变整个小程序样式。除此之外，我们还可以利用这个特性，优化组件定义。例如，我们需要一个圆形组件，常规的做法是定义相等的宽高，再设定 border-radius: 50% 。我们来看看高级的写法/* circle.wxss */\r\n:host {\r\n    /* 默认直径为 32rpx */\r\n    --diameter: 32rpx;\r\n    \r\n    width: var(--diameter);\r\n    height: var(--diameter);\r\n    border-radius: 50%;\r\n}\r\n\r\n/* outer.wxss */\r\n.circle {\r\n    /* 将 circle 组件的直径设置为 64rpx */\r\n    --diameter: 64rpx;\r\n}\r\n复制代码还记得我刚刚说的优先级规则吗？外部样式的优先级高于 :host 选择器，因此 circle 组件的直径会被设置为 64rpx 。不只如此，通过自定义属性，我们还可以修改嵌套较深的组件样式<!-- component.wxml -->\r\n<view class=\"this\">\r\n\t<view class=\"is\">\r\n    \t<view class=\"a\">\r\n        \t<view class=\"embed-component\"></view>\r\n        </view>\r\n    </view>\r\n</view>\r\n复制代码/* component.wxss */\r\n:host {\r\n    --embed-color: red;\r\n}\r\n\r\n.embed-component {\r\n    color: var(--embed-color);\r\n}\r\n\r\n/* outer.wxss */\r\n.component {\r\n    --embed-color: blue;\r\n}\r\n复制代码Bingo，借助 CSS 属性，我们获得了改动后代节点样式的能力。你大可以说同样的功能使用 externalClasses 或者 addGlobalClass 也可以做到。但是对于组件来说，外部传入的样式可知，处理起来心智负担更小，更符合 高内聚，低耦合 的标准。同时，建议将可改动的自定义 CSS 变量以注释的形式写在 component.js 中，方便其他人理解你的组件。用 em 而不是 rpx为了保持组件可扩展性，应当尽可能的使用 em 作为字体大小单位。我之前用一个小程序解析markdown 的组件库，其中将所有字体大小都写死为 rpx ，例如/* markdown.wxss */\r\n.h1 {\r\n    font-size: 32rpx;\r\n}\r\n\r\n.h2 {\r\n    font-size: 28rpx;\r\n}\r\n\r\n.h3 {\r\n    font-size: 24rpx;\r\n}\r\n复制代码如此固然能实现需求，但却失去了外部改变字体大小的能力。作为一个组件，应该适应更多的可能性，改为 em 作为字体大小单位就能很好的解决这一问题.h1 {\r\n    font-size: 2em;\r\n}\r\n\r\n.h2 {\r\n    font-size: 1.8em;\r\n}\r\n\r\n.h3 {\r\n    font-size: 1.4em;\r\n}\r\n复制代码数值仅为举例大胆使用新特性小程序对 CSS 3 新特性的支持比较完善， vw ， vh ， flex ， calc ，CSS variables 等等只要你想到，你可以大胆地使用，完全不需要考虑兼容性问题，这简直就是前端梦寐以求的试验田。所以，好好学习，大胆使用吧！后记写了这么多，自己都忘了要写些什么。本来是准备日更的，但是这两天一直在忙社保的事。刚刚从公司离职，办理灵活就业人员耽误了不少时间。感谢各位耐心阅读至此，这都是我工作半年以来的经验之谈，希望可以对你们有一点帮助。如果你也想发布小程序的组件， 官方模板 虽不失为一个选择，但我也要强推一下我写的脚手架工具 tacer ，只需一行 npx tarcer wx-component 就可以开始你的项目了哦！小程序点睛系列还剩下一篇，最后一篇，我们单纯聊 JavaScript ，关注我哟。"}
{"title": "微信小程序---分包加载（SUBPACKAGES）及报错 ", "author": "Rolan", "pub_time": "2019-1-30 00:36", "content": "某些情况下，开发者需要将小程序划分成不同的子包，在构建时打包成不同的分包，用户在使用时按需进行加载。分包很简单，具体步骤如下：在app.json中，创建subPackages，root表示分包A的根目录（eg.跟pages同级目录），pages中的页面就是分包A的子目录。 注意：这里有一点要注意，经常出现这个问题“pages *** 不应该在分包 subPackages[*] 中” 我们如果通过编辑器右键添加page的话，主包中会自动加入page路径，此时我们再去创建新的分包如果没有去掉主包路径就会报错。解决方案就是去掉主包中的路径就可以了 {\r\n  \"pages\": [\r\n    \"pages/success/success\",\r\n    \"pages/fail/fail\"\r\n  ],\r\n  \"window\": {\r\n    \"backgroundTextStyle\": \"light\",\r\n    \"navigationBarBackgroundColor\": \"#f37938\",\r\n    \"navigationBarTitleText\": \"WeChat\",\r\n    \"navigationBarTextStyle\": \"white\"\r\n  },\r\n  \"tabBar\": {\r\n    \"color\": \"#999999\",\r\n    \"selectedColor\": \"#f37938\",\r\n    \"borderStyle\": \"black\",\r\n    \"backgroundColor\": \"#ffffff\",\r\n    \"font-size\": \"50rpx\",\r\n    \"list\": [\r\n      {\r\n        \"pagePath\": \"tabbar/xxx/xxx\",\r\n        \"iconPath\": \"../../images/icon_home.png\",\r\n        \"selectedIconPath\": \"../../images/icon_home2.png\",\r\n        \"text\": \"首页\"\r\n      },\r\n      {\r\n        \"pagePath\": \"tabbar/xxx/xxx\",\r\n        \"iconPath\": \"../../images/icon_mine.png\",\r\n        \"selectedIconPath\": \"../../images/icon_mine2.png\",\r\n        \"text\": \"我的\"\r\n      }\r\n    ]\r\n  },\r\n  \"subPackages\": [\r\n    {\r\n      \"root\": \"A/\",\r\n      \"pages\": [\r\n        \"index/index\",\r\n        \"form/form\"\r\n      ]\r\n    },\r\n    {\r\n      \"root\": \"B/\",\r\n      \"pages\": [\r\n        \"index/index\",\r\n        \"form/form\"\r\n      ]\r\n    }\r\n  ]\r\n}"}
{"title": "2019微信公开课PRO开讲 小程序发布两周年最新重磅数据 ", "author": "Rolan", "pub_time": "2019-1-10 00:08", "content": "腾讯科技讯 1月9日消息，2019微信公开课PRO在广州正式启动。作为微信团队每年与各行合作伙伴的重要“约会”，本届微信公开课PRO版聚焦“同行”：小程序、小游戏、微信支付和企业微信4大产品线在现场晒出过去一年的“成绩单”，并在现场发布“优质小程序计划”、“小游戏创意鼓励计划”等新措施。活动现场，微信团队还介绍了未来新的“同行者”：微信智言对话系统、Hardcoder等全新产品与能力，全景展现微信生态在产业互联网的布局与未来同行计划。所有这些都强烈展示出微信对生态建设的态度和To B业务拓展的决心。此外，微信团队在现场发布的《2018微信数据报告》再现了微信过去一年的发展足迹：报告显示，目前微信与WeChat合并与活跃账户数达10.82亿；消息日发送次数450亿，较去年增长18%；音视频通话次数达4.1亿次，较去年增长100%。在出行、零售、餐饮、公共服务领域，2018年每月支付人数都较去年有了较大幅度的增长，从社交到商业，微信已经深入到了我们生活的方方面面。本届微信公开课PRO版上分享的同行伙伴也迎来史上最全阵容：覆盖零售、餐饮、政务民生、交通、教育、时尚生活等多领域，用超过40个案例分享了他们如何利用微信的能力，加速迈入移动互联网下半场的经验。林肯中国作为2019微信公开课PRO的特约合作伙伴，为部门VIP演讲嘉宾提供了接送车队支持，并在VIP嘉宾签到入口处进行了豪华的车队展示。服务超1000亿人次，2岁的小程序年交易增长超过600%迎来2岁生日的小程序如今不仅是亿万用户的“新国民工具”，越来越多的开发者的加入也让小程序更加明确了自己的商业路径：官方数据显示，小程序已覆盖超过200个细分行业，服务超过1000亿人次用户，年交易增长超过600%，创造了超过5000亿的商业价值。“小程序的数量很重要，这是丰富场景的基石，但小程序的好坏也同样重要，我们希望让用户用上更好的小程序，”在2019微信公开课PRO现场，小程序团队正式宣布将在2019年上线小程序评分体系及“优质小程序计划”，帮助用户更好的发现、使用优质的小程序。小程序团队希望通过开放更多的能力及助力措施，做好各行各业的助手：开发者方面，小程序团队将提供系列能力和支持，帮助更多开发者将能力变为价值：2019年，小程序团队将上线“大家都在用”、小程序搜索、全新的附近的小程序等能力，给予开发者更多的曝光机会；同时降低开发门槛、提供小程序助手、物流相关的助手和接口，帮助开发者更容易开发出好的小程序；并通过开发者社区、服务平台进一步加强与开发者的关系。同时，在2019微信公开课PRO上，腾讯云宣布推出总价值超过10亿元的“小程序o云开发”资源扶持计划，对超过一百万小程序开发者提供免费云开发资源扶持，全面助力开发者打造优秀小程序。在行业方面，小程序团队将陆续推出更精准的行业解决方案、为行业提供数据分析及运营方案，以及提供包括激励视频、插屏广告、个人小程序变现等全新的盈利方式，让行业用户可以更快获得商业支持。小游戏继续鼓励创意，欲孵化更多千万盈利级小游戏如何让小游戏更有创意，更好玩？2018年，小游戏平台启动了“创意鼓励计划”，持续完善运营环境及开发环境，帮助开发者更好地发挥自己的创意。2019年，平台一方面将延续2018年分成优惠策略，推出更便捷的资金经营流转方案，同时也会开拓新的商业模式，为创意小游戏提供资金支持及政策倾斜，让更多小游戏发挥其价值。“小游戏的本质是创意，”2018年，微信小游戏团队曾在《致小游戏开发者的一封信》中，鼓励开发者通过创意为用户带来更多优质的小游戏产品。小游戏上线1年来，共有超过10万的开发者加入到小游戏生态中，截至目前，优质小游戏活跃用户次日留存率高达60%，七日留存率达54%，其中，10款优质小游戏安卓内购月流水实现了千万盈利、11款小游戏广告月流水过千万。如何孵化出更多盈利大户？小游戏团队在活动现场公布了全新的小游戏解决方案，平台还将从研发架构、玩法内容、测试发布以及用户体验等层面，多方位帮助开发者优化小游戏启动性能及开发效率，为用户提供更优质的游戏体验。针对新上线小游戏面临的用户获取难问题，小游戏团队最新推出“新游种子用户”计划，通过两个阶段为新游戏提供不同程度的扶持。第一阶段，新游将获得随机分配的“种子用户”，帮助新游利用初始用户进行运营和传播扩散；第二阶段，针对高品质小游戏进一步提供“种子用户”，帮助优质小游戏加快增长。微信支付化身智慧化工具，帮更多企业平滑切入产业互联网“未来还将持续通过智慧化工具帮助企业提升经营效能，从‘人货场‘的数字化改造、消费链升级、数字化工具等方面切入，帮助更多行业实现从消费互联网到产业互联网的升级，” 微信支付团队在活动现场表示。过去一年，微信支付秉持极致开放的原则，为合作伙伴提供了基础支付工具、商户营销工具、商户管理工具、质量运营工具等助力，并通过与腾讯其他智慧化能力的结合，帮助合作伙伴实现了用户行为消费链的全面升级。以零售为例，商家可以借助以微信支付为核心的数字化能力实现精准发券、扫码购、智慧收银、电子会员识别、无感停车、“到家”等服务。去年11月，天虹就与微信支付合作打造了首家智慧零售标杆店，以到家、扫码购、人脸支付等服务及基础，打造全流程数字化零售场景体验，实现门店数字化率高达85%，自助化率达到50%，不仅让用户购物更加智慧，也帮助天虹实现了更高效率的销售转化。活跃用户新增120%，企业微信成50+行业专属内外连接器在腾讯产业互联网战略中，企业微信是一个重要的工具，通过解决企业沟通壁垒、管理隔阂、信息数据难以沉淀等问题，帮助企业打通内外部资源连接，快速实现企业运营管理的数字化转型。目前，企业微信已经覆盖了超过50个行业，新增企业100%，活跃用户新增120%。2018年，与微信的互通成为企业微信发展的重要节点。越来越多的企业通过企业微信连接微信生态，并打通了企业支付、小程序、客户服务等能力，实现企业无缝触达与管理微信侧的客户，帮助企业从连接员工、连接组织，延伸到连接消费者。长安汽车用企业微信连接上千家经销商,将上下游的问题反馈处理时间从原来的平均2.13天缩短至0.13天,效率提升了1538%,直接解决了企业上下游协作的问题；德邦物流的团队管理者,一键发起上千人的跨部门大群,轻松实现高效对接。随着企业微信能力的不断迭代，服务商在生态中所扮演的角色越来越重要，企业微信对服务商合作伙伴始终秉持开放、共赢的原则。目前，企业微信生态中拥有超过14000个服务商，开放了201个接口，让服务商可以通过接口帮助企业连接内外部人员、连接应用、小程序、硬件，真正实现帮贡数字化、移动化升级。企业微信团队表示，2019年，企业微信还将进一步下沉行业解决方案，深化连接概念并落地到具体的功能，触及到细分领域的每一环,以独特的方式连接产业、服务产业、也服务于人。微信生态更“硬”了：微信“智言”+Hardcoder全新发布，万物互联更近了除了对微信商业生态的解读，微信团队还在活动现场带来了更“硬核”的分享。以人工智能、语音识别为核心的微信智言对话系统“小微”在2019微信公开课PRO正式亮相。通过整合小程序、QQ音乐、企鹅FM、即时通讯等生态能力及第三方生态内容，让用户通过耳机、音箱等设备连接“小微”即可获得全方位的智能服务。微信智言对话系统还面向开发者提供了硬件SDK和云端AP的一键式款速接入，降低开发者的门槛，目前，微信智言对话系统技术方案已经应用于百余款硬件产品。除此以外，微信团队还在现场发布了“Hardcoder性能优化框架”，通过“Hardcoder”开发者可以更轻松地优化程序，突破性能。截至目前，Hardcoder微信用户覆盖量已经超过了2亿。2018年，微信创造就业岗位超2200万个，其中小程序拉动就业超过180万，较去年增长近80%。随着微信生态日益壮大，围绕小程序、公众平台、企业微信、微信支付聚集了大量开发者、运营者、服务商等生态合作伙伴，微信也始终在与这些合作伙伴同行，共创价值。"}
{"title": "小程序性能优化总结 ", "author": "Rolan", "pub_time": "2019-1-10 00:26", "content": "历史总结：小程序倒计时深究小程序实战踩坑之B2B商城项目总结初试小刀自我简历小程序启动加载优化在小程序启动时，微信会在背后完成几项工作：下载小程序代码包、加载小程序代码包、初始化小程序首页。初始化小程序环境是微信环境做的工作,我们只需要控制代码包大小，和通过一些相关的缓存策略控制，和资源控制，逻辑控制，分包加载控制来进行启动加载优化。勾选开发者工具中， 上传时压缩代码（若采用wepy高级版本，自带压缩，请按官网文档采取点击）精简代码，去掉不必要的WXML结构和未使用的WXSS定义。减少在代码包中直接嵌入的资源文件。（比如全国地区库，微信有自带的，在没必要的时候，勿自用自己的库）及时清理无用的资源（js文件、图片、demo页面等）压缩图片，使用适当的图片格式，减少本地图片数量等如果小程序比较复杂，优化后的代码总量可能仍然比较大，此时可以采用分包加载的方式进行优化，分包加载初始化时只加载首评相关、高频访问的资源，其他的按需加载。提前做异步请求，页面最好在onLoad时异步请求数据，不要在onReady时请求启用缓存数据策略，请求时先展示缓存内容，让页面尽快展示，请求到最新数据之后再刷新避免白屏，使用骨架屏等数据通信优化为了提升数据更新的性能，开发者在执行setData调用时，最好遵循以下原则：不要过于频繁调用setData，应考虑将多次setData合并成一次setData调用；数据通信的性能与数据量正相关，因而如果有一些数据字段不在界面中展示且数据结构比较复杂或包含长字符串，则不应使用setData来设置这些数据；与界面渲染无关的数据最好不要设置在data中，可以考虑设置在page对象的其他字段下。提升数据更新性能方式的代码示例：Page({\r\n  onShow: function() {\r\n\r\n    // 不要频繁调用setData\r\n    this.setData({ a: 1 })\r\n    this.setData({ b: 2 })\r\n    // 绝大多数时候可优化为\r\n    this.setData({ a: 1, b: 2 })\r\n\r\n    // 不要设置不在界面渲染时使用的数据，并将界面无关的数据放在data外\r\n    this.setData({\r\n      myData: {\r\n        a: '这个字符串在WXML中用到了',\r\n        b: '这个字符串未在WXML中用到，而且它很长…………………………'\r\n      }\r\n    })\r\n    // 可以优化为\r\n    this.setData({\r\n      'myData.a': '这个字符串在WXML中用到了'\r\n    })\r\n    this._myData = {\r\n      b: '这个字符串未在WXML中用到，而且它很长…………………………'\r\n    }\r\n\r\n  }\r\n})事件通信优化视图层会接受用户事件，如点击事件、触摸事件等。当一个用户事件被触发且有相关的事件监听器需要被触发时，视图层会将信息反馈给逻辑层。这个反馈是异步的，会产生延迟，降低延迟的方法有两个：去掉不必要的事件绑定（WXML中的bind和catch），从而减少通信的数据量和次数；事件绑定时需要传输target和currentTarget的dataset，因而不要在节点的data前缀属性中放置过大的数据。渲染优化页面方法onPageScroll使用， 每次页面滚动都会触发，避免在里面写过于复杂的逻辑 ，特别是一些执行重渲染页面的逻辑（另外，可以看我的文章——移动端滚动研究，说明了在滚动的情况下导致的渲染性能低下的各种分析和应付方法总结）在进行视图重渲染的时候，会进行当前节点树与新节点树的比较，去掉不必要设置的数据、减少setData的数据量也有助于提升这一个步骤的性能。"}
{"title": "手摸手聊聊小程序持续集成Jenkins ", "author": "Rolan", "pub_time": "2019-1-10 00:49", "content": "本文首发在我的github博客 github.com/Pasoul/blog… ，感兴趣的同学可以点个star，不要迷路哦~\r\n\r\n我们为什么要持续集成？\r\n试想以下两个场景：\r\n场景一：你在开发新功能的时候，同事A找你要小程序体验二维码，于是你只能：\r\ngit stash // 缓存本地修改\r\ngit checkout release // 切换到测试分支\r\nyarn test // 打测试包\r\n... // 预览、切回分支\r\ngit stash pop // 还原本地修改\r\n复制代码然后整理被打断的代码思路，继续coding，暗自吐槽（二维码是有35min过期时间的，一会又得找我了...）\r\n场景二：小程序到了提测日期，恰巧负责开发的你今天请假了，意味着没人可以为测试同学打包，因此耽误了项目进度。\r\n以上两个场景我们发现一个共同的问题，小程序的体验发布太依赖开发者，因为通常只有开发者熟悉微信开发者工具一系列的上传流程，从而导致影响开发进度、发布流程不可控等一系列问题...\r\n\r\n如果小程序可以通过Jenkins集成，将大大解放开发者的生产力，将Jenkins权限收回到测试同学手里，每次发布都需要测试同学执行构建，一定程度上解决发布过程不可控的问题。\r\n小程序持续集成的限制\r\n微信开发者工具目前只支持Mac和Windows环境，可以在单独的Mac mini机器上搭一个Jenkins环境，专门用于打包ios app和小程序。\r\n前期知识储备\r\n除了图形化工具，开发者工具还提供了命令行与 HTTP 服务两种接口供外部调用，开发者可以通过命令行或 HTTP 请求指示工具进行登录、预览、上传等操作。官方文档\r\n我们先尝试使用命令行工具启动并登录微信开发者工具：\r\n命令行工具所在位置：\r\nmacOS: <安装路径>/Contents/MacOS/cli\r\nWindows: <安装路径>/cli.bat\r\n以下示例皆运行在MacOS 10.13.5环境：\r\n如果微信开发者安装在应用程序里面，其中<安装路径>则为 /Applications/wechatwebdevtools.app\r\n启动微信开发者工具\r\n终端执行/Applications/wechatwebdevtools.app/Contents/MacOS/cli -o，结果如下：\r\n\r\n并且开发者工具已经启动：\r\n\r\nps: mac环境下如果是新安装的开发者工具，一定要先打开并通过安全验证。\r\n登录微信开发者工具\r\n终端执行/Applications/wechatwebdevtools.app/Contents/MacOS/cli -l，结果如下：\r\n\r\n扫描二维码后，终端打印login success，并且此时开发者工具已经登录：\r\n\r\n我们尝试使用HTTP 服务预览项目：\r\n在启动和登录开发者工具后，我们需要获取工具运行所在的端口号（端口是不固定的），然后调用http服务预览此项目，执行以下命令获取端口号：\r\nport=$(cat \"/Users/pengyong/Library/Application Support/微信web开发者工具/Default/.ide\")\r\necho \"微信开发者工具运行在${port}端口\"\r\n复制代码假设我的项目地址在：/User/demo，开发者工具开启在55228端口，在浏览器输入http://127.0.0.1:55228/preview?projectpath=/User/demo，可以查看预览二维码\r\n\r\n我们知道开发者可以通过命令行或 HTTP 请求指示工具进行启动、登录、预览等操作，接下来就进入正题：安装和部署Jenkins。\r\n配置Jenkins\r\nJenkins运行依赖java环境，终端输入java -version，看输出是否正确比如：java version \"1.8.0_151\"\r\n一般Mac安装Jenkins有两种方法：\r\n\r\nJenkins官网（jenkins.io/ ）下载安装包，一路Next。\r\nTomcat + War\r\n\r\n这里我推荐第二种安装方式，因为第一种方式会生成一个共享的用户Jenkins，接下来所有构建的操作都是基于Jenkins这个用户的，它的权限与你当前登录的系统用户权限不同，导致构建过程中出现很多问题。\r\n安装Tomcat\r\n\r\n官网下载Tomcat安装包，我下载的是apache-tomcat-8.5.37.tar.gz这个版本，重命名为Tomcat8，放在/Users/用户/Library这个目录下。\r\n将Tomcat的bin路径添加到环境变量中：\r\n\r\nsudo vi ~/.bash_profile\r\nexport PATH=$JAVA_HOME/bin:$PATH:/Users/pengyong/Library/Tomcat8/bin\r\nsource ~/.bash_profile\r\n复制代码\r\n为了避免权限问题，给你的Tomcat/bin/*.sh分配权限\r\n\r\nsudo chmod 755 /Users/pengyong/Library/Tomcat8/bin/*.sh\r\n\r\n查看8080端口是否被占用，使用kill PID解除占用\r\n\r\nlsof -i:8080\r\nkill PID\r\n复制代码\r\n终端输入startup.sh，如果出现下图所示内容，则启动成功\r\n\r\n\r\n\r\n浏览器访问http://localhost:8080/\r\n\r\n\r\n\r\n关闭Tomcat使用shutdown.sh\r\n\r\n至此，Tomcat的安装基本上完成了，接下来安装Jenkins\r\n安装Jenkins\r\n1. 官网下载Jenkins war包，放入你的Tomcat/webapps目录下\r\n\r\n\r\n\r\n浏览器访问http://localhost:8080/jenkins\r\n\r\n\r\n初次访问会让你输入密码，可以根据路径提示获取密码\r\n如果文件提示没有权限无法打开，需要先修改权限，如下：\r\n\r\n\r\n输入密码，点击continue，进入插件安装页面\r\n\r\n\r\n\r\n点击推荐安装，等待安装完成\r\n\r\n\r\n\r\n安装成功后，进入创建Jenkins用户界面，填写完成点击Save and Continue\r\n\r\n\r\n\r\n用户创建完成后进入配置Jenkins URL界面，你可以将其修改成你期望的地址，然后点Save and Finish\r\n\r\n\r\n\r\n到了这个界面，恭喜你设置Jenkins成功，但是我们还差最后一步：重启Jenkins\r\n\r\n\r\n\r\n浏览器访问http://localhost:8080/jenkins/restart(你的jenkins地址+restart)，点击Yes重启\r\n\r\n\r\n有可能页面一直展示loading，你可以尝试直接访问Jenkins主页，如果出现这个页面，Jenkins的安装过程到此结束，你可以创建任务了。\r\n\r\n\r\n插件安装：系统管理 - 插件管理 - 可选插件(Available)\r\n\r\nGit parameter: 能够实现选择指定分支进行构建的功能\r\ndescription setter: 用于生成预览二维码\r\n至此准备工作已完成，让我们开始构建小程序吧。\r\n任务构建-配置\r\n\r\n我们新建一个名为wechat的任务，选择构建一个自由风格的软件项目，点击ok进入到配置界面\r\n\r\n\r\n\r\nGeneral配置选择参数化构建过程\r\n\r\nbuild_type用于选择构建的是开发版、测试版还是生产版的小程序\r\n\r\nbranch用于选择构建的分支（如果没有这个选项，检查Git parameter这个插件有没有安装）\r\n\r\nupload_desc和upload_version两个文本参数分别用于在构建时填写小程序的备注和版本\r\n\r\n\r\n源码管理选择Git，填上仓库地址，分支这里默认是master，改成我们构建时选择的分支（注：本地生成的 id_rsa.pub 添加到git仓库的ssh认证，否则jenkins无法连接git）\r\n\r\n\r\n\r\n构建选择执行shell\r\n\r\n脚本如下，可以按需修改：\r\necho -------------------------------------------------------\r\necho GIT_BRANCH: ${GIT_BRANCH}\r\necho -------------------------------------------------------\r\n# 执行项目构建\r\nyarn install \r\nif [ \"$build_type\" == \"dev\" ]\r\n  then\r\n  yarn run test\r\nelse\r\n  yarn run $build_type\r\nfi\r\n# 打开微信开发者工具\r\n/Applications/wechatwebdevtools.app/Contents/Resources/app.nw/bin/cli -o\r\nport=$(cat \"/Users/pengyong/Library/Application Support/微信web开发者工具/Default/.ide\")\r\necho \"微信开发者工具运行在${port}端口\"\r\nreturn_code=$(curl -sL -w %{http_code} http://127.0.0.1:${port}/open)\r\nif [ $return_code == 200 ]\r\n  then\r\n  echo \"返回状态码200，devtool启动成功！\"\r\nelse\r\n  echo \"返回状态码${return_code}，devtool启动失败\"\r\n  exit 1\r\nfi\r\nif [ \"$build_type\" == \"dev\" ]\r\n  then\r\n  echo \"发布开发版！\"\r\n  # wget -o下载预览二维码，以build_id命名\r\n  /usr/local/bin/wget -O $BUILD_ID.png http://127.0.0.1:${port}/preview?projectpath=/Users/pengyong/.jenkins/workspace/wechat\r\n  echo \"预览成功！请扫描二维码进入开发版！\"\r\nelif [ \"$build_type\" == 'prod' ] || [ \"$build_type\" == \"test\" ] || [ \"$build_type\" == \"test:demo\" ]\r\n  then\r\n  echo \"准备上传！\"\r\n  # 上传到微信平台\r\n  /Applications/wechatwebdevtools.app/Contents/Resources/app.nw/bin/cli -u $upload_version@/Users/pengyong/.jenkins/workspace/wechat --upload-desc $upload_desc\r\n  echo \"上传成功！请到微信小程序后台设置体验版或提交审核！\"\r\nfi\r\n复制代码\r\n构建后操作选择Set build description（没有则检查description setter插件是否安装）\r\n\r\n\r\n这里使用img标签用于展示构建后的二维码（注：端口号是你jenkins启动的端口，任务名称是我们任务构建这一步填写的名称，这里我们是wechat）:\r\n<img src=\"http://本机ip:端口/job/任务名称/ws/${BUILD_ID}.png\" alt=\"非开发版请到后台预览\" width=\"200\" height=\"200\" /> <a href=\"http://本机ip:端口/job/任务名称/ws/${BUILD_ID}.png\" target=\"_blank\">二维码${BUILD_ID}</a>\r\n至此我们的任务构建配置基本完成了\r\n任务构建-预览小程序\r\n\r\n选择Build with parameters，选择你要构建的类型、分支等参数，这里我们选择的是开发版：\r\n\r\n\r\n\r\n构建完成后发现二维码以文本的形式展示，没有展示图片\r\n\r\n\r\n解决的方法是在系统管理 -> 全局安全配置 -> 标记格式器 -> 选择Safe HTML\r\n\r\n这时预览二维码就出来了，注意二维码是有过期时间的（35min）\r\n\r\n至此预览二维码的构建任务已经完成，我们尝试上传代码到微信平台\r\n任务构建-上传代码\r\n\r\n依然是选择构建类型、分支，不同的是上传代码需要填小程序版本号和项目备注，然后执行构建\r\n\r\n\r\n\r\n到运营平台或开发平台查看提交的版本\r\n\r\n\r\n友情提示\r\n\r\n开发者工具必须在登录状态下进行预览、上传的操作，为了避免账户冲突，可以在Jenkins服务器上使用专门的微信账号进行登录，这个账户要开启开发者和体验者权限，尽量不要使用开发者的账号。\r\n不要直接在官网下载Jenkins安装运行，坑真的很多。\r\n\r\n总结\r\n目前小程序的发布大多还是依赖开发者手动上传，并且小程序持续集成还是有很多问题：开发者工具不支持Linux环境、无法通过命令行生成体验版二维码等等。但是持续集成这个方向还是值得大家研究的，开发和发布要两开花嘛...\r\n参考：\r\n\r\n微信小程序集成 Jenkins\r\nMac Jenkins的安装和使用"}
{"title": "在小程序中集成赞赏 ", "author": "Rolan", "pub_time": "2019-1-11 00:18", "content": "好吧，我承认我标题党了，如果你是进来找如何搭建小程序中的支付流程的，请你下车吧~ 这篇文章是介绍个人小程序如何集成赞赏功能的，利用微信小程序提供的支付接口必须具有公司资质才可以。或者你也可以集成有赞，不过会抽取一定的手续费。 言归正传，让我们一步一步来集成赞赏吧，让那些喜欢你的用户也可以打赏你一下。生成一个赞赏码。打开微信，点击右上角加号->收付款->赞赏码，这里你可以进行一些赞赏设置，然后点击保存赞赏码。这样你就拥有了你专属的赞赏码了。获取一个图片地址如果你有服务器或者其他的存储空间，你可以把你的赞赏码上传到你的存储空间，然后拿到图片的htts地址，后面会用到。 如果你没有，那么还可以利用小程序给我们提供的免费的云开发。下面先来说一下如何将图片上传到云存储中。1、打开小程序开发工具，找到云开发后点击，如果你没有开通，则会提示你开通，需要在控制台中开通，路径是：开发->开发者设置->腾讯云。2、开通后再点击云开发，打开控制台，找到存储管理->上传文件,上传上一步你的专属赞赏码图片。上传完成后，就能看到文件了，将fileid字段复制下来，后面会用到。图片预览这一步需要根据实际情况分开来处理了，下面针对上一步说的两种形式一一讲解。1. 使用其他云存储拿到图片的https链接后，在你的小程序wxml添加一个打赏的按钮，然后给按钮添加如下点击事件：wx.previewImage({     urls: ['https://xxxxx/admire-qrcode.jpg'],});写到这里相信大家应该就很清楚了，不错，我们就是利用微信的图片预览功能来加载网络图片。当加载出预览大图二维码后，用户就可以长按识别二维码，弹出微信的识别图中二维码功能，最终跳转到微信自带的赞赏页面，是不是很赞呢~2. 使用云开发存储使用云开发存储的思路是一致的，只不过需要在代码中初始化一些云开发环境。初始化云开发 在app.js中加入如下代码进行初始化：onLaunch: function() {    wx.cloud.init({      traceUser: true    });}添加按钮点击事件 点击事件中传入的url就是第二步获取到的fileid。previewImage: function() {    wx.previewImage({        urls: ['cloud://carutil-007.6361-carutil-007/admire-qrcode.jpg'],    });  },大功告成，最终效果如下图所示。你可以扫描下方的小程序码来体验该功能，在首页最底部有个打赏按钮~"}
{"title": "小程序仿淘宝五级地址选择 ", "author": "Rolan", "pub_time": "2019-1-11 00:29", "content": "所有的抽奖都是由后台计算后 <!-- 轮播展示中奖信息区域 -->  <swiper autoplay=\"{{true}}\" interval=\"{{1500}}\" circular=\"{{true}}\" vertical='{{true}}'>    <block wx:for=\"{{prizeInfo}}\" wx:key=\"index\">      <swiper-item>        <view>{{item.name}}{{item.prize}}</view>      </swiper-item>    </block>  </swiper></view><!-- 轮播结束 抽奖转盘 --><view class='turntable' bindtap='doLottery'>  <image class='turntable-bj' style=\"transition:all {{time?time:'3s ease-in'}}; transform:rotate({{transformDeg + 'deg'}}) \" src='../../../img/turntable.png'></image>  <image class='arrow' src='../../../img/arrow.png'>  </image></view>得到的，前台只做动画展示const app = getApp();var index = {  data:{     prizeInfo:[      {        name:'qiphon',        prize:'5元'      },      {        name:'qiphon23423',        prize:'53元'      },      {        name:'qipsdfhon',        prize:'35元'      }    ],    transformDeg:0, // 旋转角度    transition:'all 3s cubic-bezier(0.005, 1.340, 1.000, 0.865)',    time:'999s'  },  onLoad(opt){    console.log(opt)  },  onReady(){    this.animation = wx.createAnimation({      timingFunction:'esse-in-out',      duration:2000    });    this.animationDeg = 360;  },  loadCoupons(){ // 加载获奖信息  欢迎加入全栈开发交流划水交流圈：582735936面向划水1-3年前端人员帮助突破划水瓶颈，提升思维能力  },  doLottery(){ // 抽奖    var _this = this;    if(this.aniRotate)return;    this.aniRotate = true;    this.setData({      transformDeg:this.data.transformDeg + 360*900,      time:'100s ease'    })    setTimeout(function(){      console.log('请求完成'+_this.data.transformDeg) // setTimeout 模拟ajax请求      _this.setData({        transformDeg:-360*4,        time:'3s ease'      })欢迎加入全栈开发交流划水交流圈：582735936面向划水1-3年前端人员帮助突破划水瓶颈，提升思维能力      setTimeout(function(){        console.log('返回结果'+_this.data.transformDeg)        _this.setData({          transformDeg:360*2 + 0,          time:'6s cubic-bezier(0.000, 0.765, 0.000, 0.955)'        })        setTimeout(function(){          _this.aniRotate = false;          wx.showModal({            title:'中奖信息',            content:'恭喜获得奖品'          })        },6000)      },2000)    },3000)  },}Page(index);.top-banner{  background: #fff;  padding:20rpx;}.top-banner swiper{  height: 50rpx;  line-height: 50rpx;}/* 转盘 */.turntable{  position: relative;  width: 100%;  height: 530rpx;}.turntable-bj{  display: block;  margin:0 auto;  width:600rpx;  height: 530rpx;}.turntable .arrow{  position: absolute;  top:0;  right:0;  left:0;  bottom:110rpx;  margin:auto;  width:93.5rpx;  height: 212rpx;}以上就是本文的全部内容，希望对大家的学习有所帮助。"}
{"title": "微信小程序实现换肤功能 ", "author": "Rolan", "pub_time": "2019-1-14 00:08", "content": "在手机、电脑使用频率如此高的当下，应用可以更换皮肤，以提升美观性，并减轻屏幕对眼睛的刺激，无疑对用户体验有很大的帮助。\r\n这里闲话少说，先放码出来\r\n\r\n  github地址：我的年目标-微信小程序\r\n演示\r\n扫码即可体验，或搜索“我的年目标”\r\n    \r\n\r\n下面为更换皮肤效果图\r\n \r\n实现功能\r\n要实现如上更换皮肤的效果，有几个思路：\r\n\r\n准备皮肤相关的wxss，引入到app.wxss中，方便每个页面使用；\r\n设置皮肤时，动态改变wxml中元素的类名或id，使页面应用对应的皮肤；\r\n将选中皮肤的值保存在小程序本地缓存中，保证其他页面及下一次打开小程序时，页面展示正确的皮肤；\r\n\r\n下面介绍一些实现的细节\r\nwxml\r\n<view class=\"page\" id='{{skin}}'>  \r\n  <view class=\"container\">\r\n  \t...\r\n  </view>\r\n</view>\r\n复制代码wxml部分比较简单，只需要动态切换id即可，注意因为page无法动态设置背景色，所以这里的最外层需要width: 100%;height: 100%;，否则将无法使皮肤铺满页面。\r\nwxss\r\n/* app.wxss主题颜色 */\r\n\r\n/* 深黑 */\r\n#dark-skin{\r\n  background: #000;\r\n}\r\n#dark-skin .bColor{\r\n  background: #333;\r\n  color: #999;\r\n}\r\n#dark-skin .borderColor{\r\n  border-color:#999;\r\n}\r\n/* 粉红 */\r\n#red-skin{\r\n  background: #f9e5ee;\r\n}\r\n#red-skin .bColor{\r\n  background: #f9e5ee;\r\n  color: #8e5a54;\r\n}\r\n#red-skin .borderColor{\r\n  border-color:#8e5a54;\r\n}\r\n/* 橘黄 */\r\n#yellow-skin{\r\n  background: #f6e1c9;\r\n}\r\n#yellow-skin .bColor{\r\n  background: #f6e1c9;\r\n  color: #8c6031;\r\n}\r\n#yellow-skin .borderColor{\r\n  border-color:#8c6031;\r\n}\r\n...\r\n复制代码写好皮肤对应的颜色样式，直接放入app.wxss中即可，如果样式过多，可以使用单独的wxss文件，方便管理。\r\n@import \"style/skin/dark.wxss\";\r\n复制代码js\r\n存储选中的皮肤值\r\n//wxml\r\n//<view bindtap=\"setSkin\" data-flag='yellow'>橘黄</view> \r\n//bindtap事件函数\r\n  setSkin:function(e){\r\n    var skin = e.target.dataset.flag;\r\n\r\n    this.setData({\r\n      skin: skin + '-skin',\r\n      openSet:false\r\n    })\r\n\r\n    wx.setStorage({\r\n      key: \"skin\",\r\n      data: skin + '-skin'\r\n    })\r\n    app.setSkin(this);\r\n  }\r\n复制代码这里使用setData使页面立即切换id，使用wx.setStorage存储值，app.setSkin是定义在app.js上的公共方法，下面会有介绍\r\n//app.js\r\nApp({\r\n  data: {\r\n  },\r\n  setSkin:function(that){\r\n    wx.getStorage({\r\n     key: 'skin',\r\n     success: function(res) {\r\n       if(res){\r\n         that.setData({\r\n          skin: res.data\r\n        })\r\n         var fcolor = res.data == 'dark-skin' ? '#ffffff' : '#000000',\r\n             obj = {\r\n               'normal-skin':{\r\n                 color:'#000000',\r\n                 background:'#f6f6f6'\r\n               },\r\n               'dark-skin': {\r\n                 color: '#ffffff',\r\n                 background: '#000000'\r\n               },\r\n               'red-skin': {\r\n                 color: '#8e5a54',\r\n                 background: '#f9e5ee'\r\n               },\r\n               'yellow-skin': {\r\n                 color: '#8c6031',\r\n                 background: '#f6e1c9'\r\n               },\r\n               'green-skin': {\r\n                 color: '#5d6021',\r\n                 background: '#e3eabb'\r\n               },\r\n               'cyan-skin': {\r\n                 color: '#417036',\r\n                 background: '#d1e9cd'\r\n               },\r\n               'blue-skin': {\r\n                 color: '#2e6167',\r\n                 background: '#bbe4e3'\r\n               }\r\n             },\r\n           item = obj[res.data],\r\n           tcolor = item.color,\r\n           bcolor = item.background;\r\n\r\n         wx.setNavigationBarColor({\r\n           frontColor: fcolor,\r\n           backgroundColor: bcolor,\r\n         })\r\n\r\n         wx.setTabBarStyle({\r\n           color: tcolor,\r\n           backgroundColor: bcolor,\r\n         })\r\n       }\r\n     }\r\n   })\r\n    }\r\n})\r\n\r\n复制代码app.setSkin提供给所有页面调用，并通过已有的皮肤颜色，设置头部和导航区域的背景及文字颜色。\r\n打开一个普通wxml页面，并设置皮肤\r\nconst app = getApp();\r\n\r\nPage({\r\n  data: {\r\n    skin: 'normal-skin',\r\n  },\r\n  onLoad: function() {\r\n    app.setSkin(this); \r\n  },\r\n  onShow:function(){\r\n    app.setSkin(this); \r\n  }\r\n})\r\n\r\n复制代码在onLoad及onShow触发时设置皮肤，这里的onShow是为了避免重新设置皮肤时，页面还显示上一次的皮肤，由于首次加载会设置两次，onLoad里的app.setSkin其实可以去掉。\r\n至此，一个精美的设置皮肤功能就实现了，小伙伴们快去试一试吧！\r\n\r\n最后\r\n新的2019，新的人生目标，欢迎体验微信小程序“我的年目标”，如有建议，望告知或pull requests，tks 。\r\n\r\n该小程序的其他介绍：\r\n你的年目标实现了吗，记一次开发微信小程序"}
{"title": "微信小程序电商实战-骨架屏实现 ", "author": "Rolan", "pub_time": "2019-1-14 00:15", "content": "本文章是一个系列文章，以一个完整的可用于生产的实际项目探索微信小程序开发中我们经常会遇到的问题，希望能提供完美的解决方案，这次是本系列文章的第二篇了，以下列出该系列文章链接。微信小程序及h5，基于taro，zoro最佳实践探索 微信小程序电商实战-登录模块设计 微信小程序电商实战-自定义顶部导航栏工作忙碌，难得有时间继续开发研究这个项目，目前完成了，基础设施开发及首页得开发，话不多说，老规矩，先来看下效果吧骨架屏效果演示.png这是根据页面布局自动生成得骨架屏，目前非常流行的一种提升体验的办法 为了能看到骨架屏的渲染，我调慢了所有接口的响应速度，因此演示响应较慢整体效果还不错吧（沾沾自喜中～）骨架屏的思路骨架屏的实现思路相对较简单，使用方法也很方便 我们知道微信小程序已经开发了选择器功能，可以利用此特性获取到dom节点，为了能让骨架屏组件知道该如何绘制，我们需要做如下约定：约定.skeleton样式类为骨架屏查找绘制节点的根节点 约定.skeleton-square样式类，表示绘制当前节点的骨架节点样式为方形（如商品卡片） 约定.skeleton-circular样式类，表示绘制当前节点的骨架节点为圆形（如logo） 约定.skeleton-cylinder样式类，表示绘制当前节点的骨架节点为长条形（如搜索框） 约定.skeleton-light与.skeleton-dark为块元素背景骨架样式骨架屏的使用首先我们需要引入skeleton组件到页面中，并且在页面根元素上加上.skeleton样式<View className={classNames(styles.home, 'skeleton')}>  {initialize && <ComponentCommonSkeleton />}</View>然后在对应元素中加入不同的样式类，绘制骨架<View className={classNames(styles.hotsale, 'skeleton-light')}>  <View className={styles.header}>    <View className={classNames(styles.title, 'skeleton-square')}>      今日热卖    </View>    <View className={classNames(styles.tip, 'skeleton-square')}>      每日推荐，超值抢购    </View>  </View></View>骨架屏的实现完整的实现逻辑，由于代码较多，不与全部给出，有兴趣的直接去仓库吧skeleton源码 我们来看一下关键代码，如何获取骨架节点// 利用微信小程序的selectorQuery查找相关节点selectAll = selector =>  new Promise(resolve =>    Taro.createSelectorQuery()      .selectAll(selector)      .boundingClientRect()      .exec(res => resolve(res[0])),  )componentDidMount() {  const { selector } = this.props  // 利用微信小程序跨自定义组件选择器`>>>`获取节点信息  Promise.all([    this.selectAll(`.${selector} >>> .${selector}-light`),    this.selectAll(`.${selector} >>> .${selector}-dark`),    this.selectAll(`.${selector} >>> .${selector}-square`),    this.selectAll(`.${selector} >>> .${selector}-circular`),    this.selectAll(`.${selector} >>> .${selector}-cylinder`),  ]).then(([lights, darks, squares, circulars, cylinders]) =>    // 存储节点信息，用于渲染骨架屏    this.setState({      lights,      darks,      squares,      circulars,      cylinders,    }),  )}获取到了相关节点信息，比如width，height，top，left等信息后，便可以利用绝对定位或者fixed绘制骨架了 当然这只能解决常驻组件的获取，对于一些动态组件，比如列表渲染我们该如何处理呢，这里是一个比较麻烦的问题，我们需要在数据还未获取之前，给列表数据设置部分默认数据比如： 设置默认的props或者state，这样项目初始化时便会渲染默认数据，也就可以获取到节点了该项目托管于github，如有需要，请自取weapp-clover，感谢关注，感谢star"}
{"title": "在小程序中使用 React with Hooks ", "author": "Rolan", "pub_time": "2019-1-15 00:11", "content": "介绍一下 RemaxRemax 是一个跨多端小程序 React 开发方案，之所以称其为“方案”而非框架是因为这并非一个新的框架，其主要能力就是让 React 能够直接运行在 微信小程序/支付宝小程序/字节跳动小程序/H5（当然这个本来就支持） 等环境。可能会有人要会问 “React 不是早就可以运行在小程序中了么“？本文会介绍一下现如今的一些小程序框架的解决方案，以及为什么我们认为把 React 直接搬进小程序是个更为合理的方案。静态编译类框架由于大多开发者都更熟悉 React 和 Vue 的 API 和语法，加上小程序本身的开发方式确实让人痛苦，于是便有了一些框架来将这些熟悉的语法编译到小程序的 WXML/WXSS/JS 上，其中比较具有代表性的例如 taro，其目标就是让开发者能够用 React 的开发方式编写小程序。而这类框架的实现原理其实并非真的是一个 React 或者类 React 框架，而是把看起来像是 JSX 的模板通过静态编译的方式翻译成小程序自身的模板。这样做的限制非常明显，那就是 JSX 是 JavaScript 的拓展语言（React Blog 写的是 is a syntax extension to JavaScript），而小程序所采用的 WXML 却是一个表达能力非常受限的模板语言，我们不可能完成从一个通用编程语言到模板语言的编译。而静态编译类框架为了做到这一点，采取的方式就是限制开发者的写法，这也是为什么上面称之为看起来像是 JSX 的模板，这也是为什么 taro 对 JSX 的写法做出了诸多限制。这种方案大多声称这些限制并没有限制生产力，或者符合最佳实践等等。然而我们其实都知道这是由于小程序本身的坑造成的，静态编译方案编译的永远都只会是模板语言，而不是 JSX。React Hooks之所以我说这些限制并非基于最佳实践，是因为 React 本身对于 JSX 的定位就 并非模板。JSX is a syntax extension to JavaScript.在最近 React 团队已经向我们介绍了 Hooks，期望可以 functional component 不仅仅可以是无状态组件，也可以是 useState 的。import { useState } from 'react';\r\n\r\nfunction Example() {\r\n  // Declare a new state variable, which we'll call \"count\"\r\n  const [count, setCount] = useState(0);\r\n\r\n  return (\r\n    <div>\r\n      <p>You clicked {count} times</p>\r\n      <button onClick={() => setCount(count + 1)}>\r\n        Click me\r\n      </button>\r\n    </div>\r\n  );\r\n}\r\nReact 官方博客提到 Classes confuse both people and machines，我们也明显可以看到基于 function 的组件明显更为简洁，噪声更小，未来 React 社区的方向更是会逐渐从 class component 过渡到 functional component。在这种趋势下，把 JSX 当做模板写，且未来永远也不可能支持 functional component 的方案绝非真的基于最佳实践的选择。在 Remax 中，我们完全可以使用全新的 Hooks API 来开发组件因为 Remax 中的 React 就是 React.js，而 JSX 就是 JavaScript 的超集。上图中使用小程序的原生语法，classname 和 inline style 就只能写成<view class=\"weui-navbar__item {{activeIndex == index ? 'weui-bar__item_on' : ''}}\">\r\n</view>\r\n<view style=\"left: {{sliderLeft}}px; transform: translateX({{sliderOffset}}px); -webkit-transform: translateX({{sliderOffset}}px);\"></view>\r\n而使用 remax 后就可以写成正常的 react：const innerStyle = {\r\n    left: `${sliderLeft}px`,\r\n    transform: `translateX(${sliderOffset}px);`,\r\n    '-webkit-transform': `translateX(${sliderOffset}px)`,\r\n    width: sliderWidth,\r\n  };\r\nconst itemClassName = classnames({\r\n   'weui-navbar__item': true,\r\n    'weui-bar__item_on': activeIndex === index,\r\n});\r\n\r\nreturn <View className={itemClassName}>\r\n    <View style={innerStyle} />\r\n    </View>\r\n实现原理核心部分Remax 的实现原理和基于静态编译的方案有所不同，其核心其实是重新实现了 ReactDOM 的部分。众所周知，React 本身的设计就是支持跨端渲染的，render 部分和 React 的核心逻辑是解耦的（甚至不在一个 npm 包里）。主要的 render 有 ReactDOM（浏览器），ReactDOMServer（服务器端）和 ReactNative。Remax 要做的事情和 ReactNative 要做的事情非常类似，我们重新接管了 ReactDOM 的 render。在原有的 React 页面中，React 在完成 Diff 发现需要修改界面时，又 ReactDOM 把改变 Patch 到页面上。而在小程序中由于我们不能直接修改页面，则由 React 完成 DIFF 后由 Remax 把修改 Patch 到内存中的虚拟 DOM 上，然后再通过小程序自己的虚拟 DOM 最后把改变同步到页面上。在这里我把这个过程说得非常简单，但实际上是有些坑要填的，主要也都是来自于小程序的限制，后续会有新的文章展开来讲。但是这种实现方式使得我们完全可以把 React 的代码放在小程序的环境中运行。工程化工程化很理所当然的用 Webpack 来实现， 除了我们常用的打包等功能外，Webpack 插件也使我们很容易构建一些我们需要的东西出来，例如我们需要在每个 js 入口除了放一个 js 外还需要添加一个 wxml 文件，就可以通过一个很简单的 Webpack 插件来实现。function GeneraeWxmlWebpackPlugin() {\r\n  const content = `<view>...</view>`;\r\n  const apply = (compiler) => {\r\n    const emit = (compilation, cb) => {\r\n      const {\r\n        chunks,\r\n      } = compilation;\r\n      chunks.forEach((item) => {\r\n        compilation.assets[`${item.name}.wxml`] = {\r\n          source: () => content,\r\n          size: () => content.length,\r\n        };\r\n      });\r\n\r\n      cb();\r\n    };\r\n\r\n    if (compiler.hooks) {\r\n      const plugin = { name: 'GeneraeWxmlWebpackPlugin' };\r\n      compiler.hooks.emit.tapAsync(plugin, emit);\r\n    } else {\r\n      compiler.plugin('emit', emit);\r\n    }\r\n  };\r\n\r\n  return {\r\n    apply,\r\n  };\r\n}\r\n跨端这种方案想实现同一套代码跨到 H5 端显然没有什么问题，至于支付宝小程序目前验证了一下可行性也是可行的。项目结构这个项目主要由几块组成@remax/core核心部分，负责 React 组件的 render@remax/cli顾名思义，CLI 工具，用于构建生成相应的小程序项目等工作@remax/components底层 Component，包括诸如 View 等一些基础组件，用于抹平不同环境的差异@remax/ui自带的基础组件库，这部分还待开发，目前只有一两个示例组件由于目前整个项目才刚刚起步，暂时还不能用于生产环境，目前的几个主要开发者（和打算参与的）有 @CodeFalling @bramblex @ahonn @SimplyY目前的 DEMO 可以扫码体验：或者在可以按照 https://github.com/CodeFalling/remax#%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B 体验本地 DEMO。如果有人想要参与进来一起开发可以联系我，开发相关的细节文档会陆续更新在 https://github.com/CodeFalling/remax/wiki/%E5%85%A5%E9%97%A8 。讨论群@remax/dev推荐阅读https://reactjs.org/docs/introducing-jsx.htmlhttps://reactjs.org/docs/hooks-intro.htmlReact v16.7 \"Hooks\" - What to Expect"}
{"title": "微信小程序自定义组件实现 tabBar、navBar ", "author": "Rolan", "pub_time": "2019-1-15 00:17", "content": "最近App项目要将其中一个模块抽出来做成小程序，\r\n功能包含 ：底部的Tab栏，顶部的标题栏\r\n这里选择自定义的原因有两点：\r\n\r\nnarBar 微信原生不支持设置返回图标，且在 Android 上标题是居左显示，在 iOS 上是居中显示。\r\n底部的 tabBar 不支持点击跳页面，图标布局不支持超过 tabBar 的高度。\r\n\r\n下面两张图是简单实现的效果。\r\n\r\n实现分析\r\n源码地址\r\n\r\n实现分析\r\n\r\n以上效果我也是参考的网上例子来实现，可看该效果原作的分析。或者看看下面我的理解。\r\n\r\n微信小程序自定义组件\r\n\r\n官方文档地址 developers.weixin.qq.com/miniprogram…\r\n\r\n文档中说明了自定义组件\r\n\r\n可以将页面内的功能模块抽象成自定义组件，以便在不同的页面中重复使用。\r\n也可以将复杂的页面拆分成多个低耦合的模块，有助于代码维护。\r\n\r\n创建自定义组件\r\n在最新的开发工具中已经支持直接创建组件了，创建一个 components目录，然后在创建一个组件对于的目录，例如这里创建的是tabbar目录，然后在该目录点击鼠标右键选择新建Component，输入组件名称即可，例如这里输入的是tabbar。\r\n\r\n组件模板和样式\r\n\r\n官方文档 developers.weixin.qq.com/miniprogram…\r\n\r\n类似于页面，自定义组件拥有自己的wxml 模板和 wxss 样式\r\n在组件模板中可以提供一个<slot>节点，用于承载组件引用时提供的子节点。这个<slot>节点相当于组件占位符。\r\n\r\n默认情况wxml中只支持一个<solt>节点，可以设置支持多个<solt>节点：\r\n\r\n布局编写好之后就开始设置样式了，在页面中可以通过wxss来定义，也可以通过设置组件的class名称，然后再调用该组件的 wxss中定义样式。\r\n\r\n\r\n组件的wxss默认是不支持app.wxss样式的，但是可以像设置多<slot>一样，进行设置：\r\n\r\n模板数据绑定\r\n\r\n通过调用 Component构造器时可以指定组件的属性、数据、方法等。developers.weixin.qq.com/miniprogram…\r\n\r\nComponent({\r\n  // 详细使用看文档\r\n  behaviors: [],\r\n\r\n  properties: {\r\n    myProperty: { // 属性名\r\n      type: String, // 类型（必填），目前接受的类型包括：String, Number, Boolean, Object, Array, null（表示任意类型）\r\n      value: '', // 属性初始值（可选），如果未指定则会根据类型选择一个\r\n      observer(newVal, oldVal, changedPath) {\r\n        // 属性被改变时执行的函数（可选），也可以写成在methods段中定义的方法名字符串, 如：'_propertyChange'\r\n        // 通常 newVal 就是新设置的数据， oldVal 是旧数据\r\n      }\r\n    },\r\n    myProperty2: String // 简化的定义方式\r\n  },\r\n  data: {}, // 私有数据，可用于模板渲染\r\n\r\n  lifetimes: {\r\n    // 生命周期函数，可以为函数，或一个在methods段中定义的方法名\r\n    attached() { },\r\n    moved() { },\r\n    detached() { },\r\n  },\r\n\r\n  // 生命周期函数，可以为函数，或一个在methods段中定义的方法名\r\n  attached() { }, // 此处attached的声明会被lifetimes字段中的声明覆盖\r\n  ready() { },\r\n\r\n  pageLifetimes: {\r\n    // 组件所在页面的生命周期函数\r\n    show() { },\r\n    hide() { },\r\n    resize() { },\r\n  },\r\n\r\n  methods: {\r\n    onMyButtonTap() {\r\n      this.setData({\r\n        // 更新属性和数据的方法与更新页面数据的方法类似\r\n      })\r\n    },\r\n    // 内部方法建议以下划线开头\r\n    _myPrivateMethod() {\r\n      // 这里将 data.A[0].B 设为 'myPrivateData'\r\n      this.setData({\r\n        'A[0].B': 'myPrivateData'\r\n      })\r\n    },\r\n    _propertyChange(newVal, oldVal) {\r\n\r\n    }\r\n  }\r\n\r\n})\r\n复制代码在上面的代码中我们可以通过properties和setData结合实现动态设置数据，在methods中可以定义方法，用于给外部调用，也就是组件间的通信。\r\n组件间通信\r\n\r\n可以通过triggerEvent或者直接获取组件this.selectComponent示例来调用方法和属性。\r\n\r\n\r\ntriggerEvent\r\n父组件还可以通过 this.selectComponent 方法获取子组件实例对象，这样就可以直接访问组件的任意数据和方法。\r\n\r\n\r\n\r\n开始使用组件\r\n在页面的json文件中配置组件的路径，如下：\r\n{\r\n  \"usingComponents\": {\r\n    \"navbar\": \"/components/navbar/index\",\r\n    \"tabbar\": \"/components/tabbar/tabbar\"\r\n  }\r\n}\r\n复制代码在页面的wxml布局中添加，如下：\r\n// 引入组件\r\n<navbar navbar-data='{{nvabarData}}'></navbar>\r\n// 内容\r\n<view class=\"home-page\">\r\n  <view style='margin-top: {{height}}px;margin-bottom:10px;'></view>\r\n</view>\r\n// 引入组件\r\n<tabbar tabbar=\"{{tabbar}}\"></tabbar>\r\n复制代码自定义 tabBar 组件分析\r\n\r\n看文章顶部原作者的分析。下面介绍一些坑。\r\n\r\n\r\n\r\n虽然在组件的js文件中已经设置了tabbar 但是在app.json中还是需要配置tabbar，详细配置可看文章顶部github链接。\r\n\r\n\r\n在页面的onload中还需要再设置一次\r\n\r\n\r\nwx.hideTabBar({\r\n    })\r\n复制代码因为从分享页面点击左上角的首页图标回到首页会出现两个tabbar，所以在首页还需要再隐藏一次tabbar.\r\n\r\n注意路径问题，新版的开发工具components文件应该在miniprogram下，和pages为同级，否则在引入组件的路径中可能会出错。\r\n\r\n自定义 navBar 组件分析\r\n小程序中分享出去的页面是没有返回按钮的，为了用户能够再次回到我们的小程序中，我们在 navbar 上自定义了一个返回按钮和返回首页的按钮。\r\n这里通过小程序的场景值和使用一个全局的变量share来判断是否是从分享页面进来。在 app.js中做了处理：\r\n// 判断是否由分享进入小程序\r\n    if (options.scene == 1007 || options.scene == 1008) {\r\n      this.globalData.share = true\r\n    } else {\r\n      this.globalData.share = false\r\n    };\r\n复制代码为了适配顶部的高度，在wxml布局中还动态设置了一个margin-top的高度，这个高度通过获取系统的状态栏高度得到。\r\n getSystemInfo: function () {\r\n    let t = this;\r\n    wx.getSystemInfo({\r\n      success: function (res) {\r\n        // 获取高度\r\n        t.globalData.height = res.statusBarHeight;\r\n      }\r\n    });\r\n  },\r\n复制代码然后在页面的data中设置组件的数据和状态栏的高度：\r\ndata: {\r\n    // 组件所需的参数\r\n    nvabarData: {\r\n      showCapsule: 0, //是否显示左上角图标   1表示显示    0表示不显示\r\n      title: '让故事发生', //导航栏 中间的标题\r\n    },\r\n    // 此页面 页面内容距最顶部的距离\r\n    height: app.globalData.height * 2 + 20,\r\n    // tabbar\r\n    tabbar: {},\r\n  },\r\n复制代码原作者在实现图标的显示和隐藏部分逻辑和我的预期不一致，我想实现的是从分享页面进入才显示左上角的返回首页图标，正常也就只显示返回按钮。修改点后的wxml如下：\r\n      <view bindtap='_navback' wx:if='{{!share}}'>\r\n        <image src='/images/back.png' mode='aspectFill' class='back-pre'></image>\r\n      </view>\r\n// 这里把 share 取反去掉\r\n      <view class='navbar-v-line' wx:if='{{share}}'></view>\r\n// 这里把  share 取反去掉\r\n      <view bindtap='_backhome'  wx:if='{{share}}'>\r\n        <image src='/images/icon/icon_home.png' mode='aspectFill' class='back-home'></image>\r\n      </view>\r\n复制代码本文完~，喜欢就点个赞呗"}
{"title": "微信小程序之scroll-view的flex布局问题 ", "author": "Rolan", "pub_time": "2019-1-16 00:03", "content": "关于微信小程序的scroll-view组件，第一次写的时候是直接在scroll-view中用了一层容器包裹子元素，然后用了flex布局，并且是用了组件来实现的横向滚动，后面有提出改进，但是不记录下，就发现过了几天，就有点懵了1.效果图2.在scroll-view里加一层容器，使用flex布局实现这里用flex布局实现的话，就要用组件的形式wxss文件.scrollView{\r\n  padding: 0 20rpx;\r\n  white-space: nowrap;\r\n  box-sizing: border-box;\r\n}\r\n.item{\r\n  display: inline-block;\r\n  margin-right: 20rpx;\r\n  width: calc(100% / 3);\r\n  height: 100rpx;\r\n  background: #ff00ff;\r\n}\r\n\r\n.scrollView1{\r\n  display: flex;\r\n  margin-top: 40rpx;\r\n  padding: 0 20rpx;\r\n  width: 100%;\r\n  flex-wrap: nowrap;\r\n  box-sizing: border-box;\r\n}\r\n.item1{\r\n  margin-right: 20rpx;\r\n  width: calc(100% / 3);\r\n  height: 100rpx;\r\n  background: #ff00ff;\r\n}\r\n.scrollView2{\r\n  margin-top: 40rpx;\r\n  padding: 0 20rpx;\r\n  width: 100%;\r\n  box-sizing: border-box;\r\n}\r\n.itemContainer{\r\n  display: flex;\r\n  width: 100%;\r\n  flex-wrap: nowrap;\r\n}\r\n.scrollItem{\r\n  margin-right: 20rpx;\r\n}\r\n\r\n.scrollView3{\r\n  margin-top: 40rpx;\r\n  padding: 0 20rpx;\r\n  width: 100%;\r\n  box-sizing: border-box;\r\n}\r\n.item3{\r\n  margin-right: 20rpx;\r\n  /* width: calc(100% / 3); */\r\n  width: 240rpx;\r\n  height: 100rpx;\r\n  background: #aa22dd;\r\n}wxml文件<!-- 要想使用flex布局实现横向滚动，就要在scroll-view里加一层容器包裹，并且使用子组件才会出现滚动效果 -->\r\n<scroll-view scroll-x class=\"scrollView2\">\r\n  <view class=\"itemContainer\">\r\n    <block wx:for=\"{{4}}\" wx:key=\"{{index}}\">\r\n      <view-item class=\"scrollItem\" />\r\n    </block>\r\n  </view>\r\n</scroll-view>子组件里就一个view标签，可以自己直接写3.直接使用display：inline-blockwxml文件<scroll-view scroll-x class=\"scrollView\">\r\n  <block wx:for=\"{{4}}\" wx:key=\"{{index}}\">\r\n    <view class=\"item\"></view>\r\n  </block>\r\n</scroll-view>4.自己的理解scroll-view不可以直接使用flex布局，使用flex布局会使得他不会按照预想的那样横向排列、滚动要使用flex布局则要麻烦一点如果直接使用flex布局，不用子组件的话，则会被挤成一排正在努力学习中，若对你的学习有帮助，留下你的印记呗（点个赞咯^_^）"}
{"title": "微信小程序商品筛选，侧方弹出动画选择页面 ", "author": "Rolan", "pub_time": "2019-1-16 00:21", "content": "微信小程序商品筛选，侧方弹出动画选择页面，在一点点的零碎的时间里面写出来的代码，和前两篇效果结合出来的。点击按钮的同时，要实现这两个功能的叠加。小程序动画animation向左移动效果：https://www.jianshu.com/p/1cdf36070205小程序点击按钮出现和隐藏遮罩层：https://www.jianshu.com/p/1193bf63a87d效果是这样的:demo是这样的： wxml<view class=\"\">  <view class=\"animation-button\" bindtap=\"translate\">筛选</view>  <view class=\"float {{isRuleTrue?'isRuleShow':'isRuleHide'}} \">    <view class=\"animation-element\" animation=\"{{animation}}\">      <view class='use'>        <view class='iconuse'>用途</view>        <ul class=\"useage\">          <li bindtap=\"tryDriver\" style=\"background:{{background}};\">全部</li>          <li>经济实惠型</li>          <li>家用学习型</li>        </ul>        <ul class=\"useage\">          <li bindtap=\"tryDriver\" style=\"background:{{background}};\">豪华发烧型</li>          <li>疯狂游戏型</li>          <li>商务办公型</li>        </ul>        <ul class=\"useage\">          <li>经济实惠型</li>          <li>家用学习型</li>        </ul>      </view>      <!-- 价格 -->      <view class='use'>        <view class='iconprice'>价格</view>        <ul class=\"useage\">          <li bindtap=\"tryDriver\" style=\"background:{{background}};\">全部</li>          <li>经济实惠型</li>          <li>家用学习型</li>        </ul>        <ul class=\"useage\">          <li bindtap=\"tryDriver\" style=\"background:{{background}};\">豪华发烧型</li>          <li>疯狂游戏型</li>          <li>商务办公型</li>        </ul>        <ul class=\"useage\">          <li>经济实惠型</li>          <li>家用学习型</li>        </ul>      </view>      <view class='buttom'>      <view class=\"animation-reset\" >重置</view>      <view class=\"animation-button\" bindtap=\"success\">完成</view>      </view>    </view>  </view></view>wxss.isRuleShow {  display: block;}.isRuleHide {  display: none;}.float {  height: 100%;  width: 100%;  position: fixed;  background-color: rgba(0, 0, 0, 0.5);  z-index: 2;  top: 0;  left: 0;  /* margin-top:80rpx; */}.iconuse {  margin-left: 11rpx;}.iconprice {  margin-left: 11rpx;}.animation-element {  width: 580rpx;  height: 1175rpx;   background-color: #ffffff;   border: 1px solid #f3f0f0;  position: absolute;  right: -572rpx;}.useage {  height: 40rpx;}.useage li {  width: 177rpx;  margin: 12rpx 7rpx;  height: 70rpx;  line-height: 70rpx;  display: inline-block;  text-align: center;  border: 1px solid #f3f0f0;  border-radius: 15rpx;  font-size: 30rpx;}.buttom{  position: fixed;  bottom: 0;}.animation-reset{float: left; line-height: 2;  width: 260rpx;  margin: 15rpx 12rpx;  border: 1px solid #f3f0f0;  text-align: center;}.animation-button{float: left; line-height: 2;  width: 260rpx;  margin: 15rpx 12rpx;  border: 1px solid #f3f0f0;  text-align: center;}jsPage({  onReady: function () {    this.animation = wx.createAnimation()  },  translate: function () {    this.setData({      isRuleTrue: true    })    this.animation.translate(-245, 0).step()    this.setData({ animation: this.animation.export() })  },  success: function () {    this.setData({      isRuleTrue: false    })    this.animation.translate(0, 0).step()    this.setData({ animation: this.animation.export() })  },  tryDriver: function () {    this.setData({      background: \"#89dcf8\"    })  }})ok完成了，今天再说一点，有人问我关于技术博客日更的事情，一来是参加了简书的日更活动，不想断开，二来是一路走来，能看见自己每天学习到的知识点和解决的问题，所以才会感到很充实，不会觉得自己每天在空空度日。如果你也想坚持一件事情，可以私聊我，我们相互监督，互相帮助，让自己变得更好。原文作者：祈澈姑娘 技术博客：https://www.jianshu.com/u/05f416aefbe1 90后前端妹子，爱编程，爱运营，爱折腾。 坚持总结工作中遇到的技术问题，坚持记录工作中所所思所见，对于博客上面有不会的问题，可以加入qq群聊来问我：473819131。"}
{"title": "小程序----page级别的骚操作之禁用页面滚动 ", "author": "Rolan", "pub_time": "2019-1-16 00:24", "content": "page级别的骚操作之禁用页面滚动在做小程序项目的时候，遇到了这么一个问题。那就是希望能够动态的设置页面的滚动与否。 然鹅，官方提供的page级别的api操作里面显然是没有的。 首先，我们要知道的一点是小程序的每个页面的根元素为page，在对应的xxx.wxss中我们可以对其样式进行调整。    page{      background: #000;      color: #fff;    }书归正传，那么怎么动态的设置页面的滚动与否呢？在wxml的布局里面使用一个最外层view组件包含其它内容    <view class=\"test_page {{isScroll?'hidden':''}}\">        <view class=\"test_modal first_modal\">我是第一屏</view>        <view class=\"test_modal second_modal\">我是第二屏</view>        <button class=\"btn\" bind:tap=\"bindScrollStatus\">点我控制滚动</buttton>    </view>    page{      background: #000;      height: 100%;      color: #fff;    }    .test_page{        width: 100%;        height: 100%;    }    .hidden{        overflow: hidden;    }    .test_modal{        height: 100%;    }    .first_modal{        background: red;    }    .second_modal{        background: green;    }    .btn{        position: fixed;        width: 100%;        height: 88rpx;        bottom: 0;        display: flex;        align-items: center;        justify-content: center;        background: #0099ff;        font-size: 36rpx;        color: #fff;    }    Page({        data:{            isScroll:true        },        bindScrollStatus(){            this.setData({                isScroll: !this.data.isScroll            })        }    })可滚动时不可滚动时至此小程序----page级的骚操作之动态设置页面滚动篇结束。 此种方法只能算是hack的一种手段。相对应的可能会失去一些其它api的使用。希望官方能够提供对应的api为最好（--_--）。此处作为抛砖引玉，有更好的处理方法还请指教。如果对你觉得本章不错，请不要吝啬给个赞呗!"}
{"title": "微信小程序组件化的解决方案 ", "author": "Rolan", "pub_time": "2019-1-17 00:14", "content": "从小程序基础库版本1.6.3 开始，小程序支持简洁的组件化编程。查看自己使用的小程序基础库版本，可以通过在开发者工具右侧点击详情查看最基本的组件小程序的组件，其实就是一个目录，该目录需要包含4个文件：xxx.jsonxxx.wxmlxxx.wxssxxx.js声明一个组件首先需要在 json 文件中进行自定义组件声明（将 component 字段设为 true 可这一组文件设为自定义组件）{ \"component\": true}\r\n复制代码其次，在要引入组件的页面的json文件内，进行引用声明{  \r\n    \"usingComponents\": {   \r\n      \"component-tag-name\": \"path/to/the/custom/component\"  \r\n    }\r\n}\r\n复制代码component-tag-name 字段是自定义的组件名称后面的是组件路径，注意是相对路径，不能是绝对路径这样，在主页面就可以使用了。相比于vue的组件引入，小程序的方案更简洁。vue组件引入是需要 import 之后，同时在 components 里面注册，而小程序的组件只需要在 .json 里面注册，就可以在 wxml 里面使用。使用slot和vue 相同，小程序也有slot概念。单一slot在组件模板中可以提供一个 <slot> 节点，用于承载组件引用时提供的子节点。// 主页面内，<addlike>是组件\r\n<addlike item=\"item\" my_properties=\"sssss\">   \r\n\t<text>我是被slot插入的文本</text>\r\n</addlike> \r\n\r\n// addlike 组件\r\n<view class=\"container\">    \r\n\t<view>hello, 这里是组件</view>    \r\n\t<view>hello, {{my_properties}}</view>    \r\n\t<slot></slot>\r\n</view> \r\n\r\n// 渲染后\r\n<view class=\"container\">    \r\n\t<view>hello, 这里是组件</view>    \r\n\t<view>hello, {{my_properties}}</view>    \r\n\t<text>我是被slot插入的文本</text>\r\n</view>\r\n复制代码多个slot如果需要在组件内使用多个slot， 需要在组件js中声明启用：Component({\r\n  options: {\r\n    multipleSlots: true // 在组件定义时的选项中启用多slot支持\r\n  },\r\n  properties: { /* ... */ },\r\n  methods: { /* ... */ }\r\n})\r\n复制代码使用：// 主页面\r\n<addlike item=\"item\" my_properties=\"sssss\">\r\n    // 在普通的元素上加入 slot 属性，指定slotname, 就可以变成子元素的slot了\r\n    <text slot=\"slot1\">我是被slot1插入的文本</text>\r\n    <text slot=\"slot2\">我是被slot2插入的文本</text>\r\n</addlike>\r\n \r\n// 子页面\r\n<view class=\"container\">\r\n    <view>hello, 这里是组件</view>\r\n    <view>hello, {{my_properties}}</view>\r\n    <slot name=\"slot1\"></slot>\r\n    <slot name=\"slot2\"></slot>\r\n</view>\r\n复制代码Component构造器刚才我们说了，一个组件内应该包括js, wxml, wxss, json 四个文件。wxml 相当于是 HTML，wxss 相当于是 css, 那么js 里面应该写什么呢？微信官方提供的案例中：Component({\r\n \r\n  behaviors: [],\r\n \r\n  properties: {\r\n   \r\n  },\r\n  data: {}, // 私有数据，可用于模版渲染\r\n \r\n  // 生命周期函数，可以为函数，或一个在methods段中定义的方法名\r\n  attached: function(){},\r\n  moved: function(){},\r\n  detached: function(){},\r\n \r\n  methods: {\r\n    onMyButtonTap: function(){\r\n     \r\n    },\r\n    _myPrivateMethod: function(){\r\n     \r\n    },\r\n    _propertyChange: function(newVal, oldVal) {\r\n \r\n    }\r\n  }\r\n})\r\n复制代码里面调用了一个Component构造器。Component构造器可用于定义组件，调用Component构造器时可以指定组件的 属性、数据、方法 等。具体 Component里面可以放什么东西，如下所示：组件与数据通信组件化必然要涉及到数据的通信，为了解决数据在组件间的维护问题，vue, react，angular 有不同的解决方案。而小程序的解决方案则简洁很多。主页面传入数据到组件properties相当于vue的props，是传入外部数据的入口。// 主页面使用组件\r\n<a add_like=\"{{add_like}}\">\r\n</a>\r\n \r\n// 组件a.js 内\r\nComponent({\r\n    properties:{\r\n        add_like:{\r\n            type:Array,\r\n            value:[],\r\n            observer:function(){\r\n                \r\n            }\r\n        }\r\n    }\r\n})\r\n复制代码注意： 传入的数据，不管是简单数据类型，还是引用类型，都如同 值复制 一样（ 和红宝书里面描述js函数参数传入是值复制还不一样，红宝书里面的意思是：简单数据类型直接复制数值，引用类型复制引用，也就是说在函数内修改参数对象的属性，会影响到函数外对象的属性 ）。如果是Vue的props， 则可以通过 .sync 来同步，而在小程序子组件里面，调用this.setData()修改父组件内的数据，不会影响到父组件里面的数据, 也就是说，子组件 property 的修改，仿佛和父组件没有任何关系。那么，如果是在子组件内修改父组件的数据，甚至是修改兄弟组件内的数据，有没有简单的方法呢？下面会有讲到组件传出数据到主页面和vue类似，组件间交互的主要形式是自定义事件。组件通过 this.triggerEvent() 触发自定义事件，主页面在组件上 bind:component_method=\"main_page_mehod\" 来接收自定义事件。其中， this.triggerEvent() 方法接收自定义事件名称外，还接收两个对象， eventDetail 和 eventOptions 。// 子组件触发自定义事件\r\nontap () {\r\n    // 所有要带到主页面的数据，都装在eventDetail里面\r\n\tvar eventDetail = {\r\n\t\tname:'sssssssss',\r\n\t\ttest:[1,2,3]\r\n\t}\r\n\t// 触发事件的选项 bubbles是否冒泡，composed是否可穿越组件边界，capturePhase 是否有捕获阶段\r\n\tvar eventOption = {\r\n\t\tcomposed: true\r\n\t}\r\n\tthis.triggerEvent('click_btn', eventDetail, eventOption)\r\n}\r\n \r\n// 主页面里面\r\nmain_page_ontap (eventDetail) {\r\n    console.log(eventDetail)\r\n    // eventDetail\r\n    // changedTouches\r\n    // currentTarget\r\n    // target\r\n    // type\r\n    // ……\r\n    // detail   哈哈，所有的子组件的数据，都通过该参数的detail属性暴露出来\r\n}\r\n\r\n复制代码组件之间数据通信和vue提出的vuex的解决方案不同，小程序的组件间的通讯简单小巧。你可以和主页面与组件通讯一样，使用自定义事件来进行通讯，当然更简单方便的方法，是使用小程序提供的relations.relations 是Component 构造函数中的一个属性，只要两个组件的relations 属性产生关联，他们两个之间就可以捕获到对方，并且可以相互访问，修改对方的属性，如同修改自己的属性一样。Component({\r\n   relations:{\r\n    './path_to_b': {                 // './path_to_b'是对方组件的相对路径\r\n        type: 'child',               //  type可选择两组：parent和child、ancestor和descendant\r\n        linked:function(target){  }  // 钩子函数，在组件linked时候被调用 target是组件的实例，\r\n        linkChanged: function(target){}\r\n        unlinked: function(target){}\r\n        }\r\n    },\r\n})\r\n复制代码比如说，有两个组件如代码所示：// 组件a slot 包含了组件b\r\n<a>    \r\n  <b></b>\r\n</a>\r\n复制代码他们之间的关系如下图所示：两个组件捕获到对方组件的实例，是通过 this.getRelationNodes('./path_to_a')方法。既然获取到了对方组件的实例，那么就可以访问到对方组件上的data, 也可以设置对方组件上的data, 但是不能调用对方组件上的方法。// 在a 组件中\r\nComponent({\r\n    relations:{\r\n        './path_to_b': {\r\n            type: 'child',\r\n            linked:function(target){  }  // target是组件b的实例，\r\n            linkChanged: function(target){}\r\n            unlinked: function(target){}\r\n        }\r\n    },\r\n    methods:{\r\n        test () {\r\n            var nodes = this.getRelationNodes('./path_to_b')\r\n            var component_b = nodes[0];\r\n            \r\n            // 获取到b组件的数据\r\n            console.log(component_b.data.name)\r\n            \r\n            // 设置父组件的数据\r\n            // 这样的设置是无效的\r\n            this.setData({\r\n                component_b.data.name:'ss'\r\n            })\r\n            // 需要调用对方组件的setData()方法来设置\r\n            component_b.setData({\r\n                name:'ss'\r\n            })\r\n        }\r\n    }\r\n})\r\n \r\n// 在b 组件里面\r\nComponent({\r\n    relations:{\r\n        './path_to_a': {                      //注意！必须双方组件都声明relations属性\r\n            type:'parent'\r\n        }\r\n    },\r\n    data: {\r\n        name: 'dudu'\r\n    }\r\n})\r\n复制代码注意：1. 主页面使用组件的时候，不能有数字，比如说 <component_sub1> 或 <component_sub_1>，可以在主页面的json 里面设置一个新名字{\r\n    \"usingComponents\":{\r\n        \"test_component_subb\": \"../../../components/test_component_sub2/test_component_sub2\"\r\n    }\r\n}\r\n复制代码relations 里面的路径，比如说这里：是对方组件真实的相对路径，而不是组件间的逻辑路径。如果relations 没有关联，那么 this.getRelationNodes 是获取不到对方组件的本组件无法获取本组件的实例，使用this.getRelatonsNodes('./ path_to_self ') 会返回一个nulltype 可以选择的 parent 、 child 、 ancestor 、 descendant现在我们已经可以做到了两个组件之间的数据传递，那么如何在多个组件间传递数据呢？如上图所示，同级的组件b 和同级的组件c , b 和 c 之间不可以直接获取，b可以获取到a， c 也可以获取到a，而a可以直接获取到 b 和 c。所以，如果想获取到兄弟元素，需要先获取到祖先节点，然后再通过祖先节点获取兄弟节点我在 组件b 里面，我需要先找到 祖先组件a 的实例，然后用 祖先组件a 的实例的 getRelationNodes 方法获取到 组件c 的实例。看见没？恐怕我们又要写一大堆重复性的代码了。幸好，微信小程序还提供了behavior 属性, 这个属性相当于 mixin，很容易理解的，是提高代码复用性的一种方法。思路：假设目前有三个组件，组件a, 组件b, 组件c， 其中组件b和组件c是兄弟组件，组建a是b和c的兄弟组件。为了减少代码的重复性，我们把获取父组件的方法，和获取兄弟组件的方法封装一下，封装在 behavior 的 methods 中。只要是引入该behavior的组件，都可以便捷的调用方法。实现：新建一个behavior文件，命名无所谓，比如说relation_behavior.js// 在 get_relation.js 文件里面\r\nmodule.exports = Behavior({\r\n\tmethods:{\r\n\t    // 获取父组件实例的快捷方法\r\n\t\t_parent () {\r\n\t\t\t// 如果根据该路径获取到acestor组件为null，则说明this为ancesor\r\n\t\t\tvar parentNode =  this.getRelationNodes('../record_item/record_item')\r\n\t\t\tif (parentNode&&parentNode.length !== 0) {\r\n\t\t\t\treturn parentNode[0]\r\n\t\t\t} else {\r\n\t\t\t\treturn this\r\n\t\t\t}\r\n\t\t},\r\n\t\t// 获取兄弟组件实例的快捷方法\r\n\t\t_sibling(name) {\r\n\t\t\tvar node = this._parent().getRelationNodes(`../${name}/${name}`)\r\n\t\t\tif (node &&node.length > 0) {\r\n\t\t\t\treturn node[0]\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n})\r\n复制代码然后在组件b, 和 组件c 上引入该behavior，并且调用方法，获取父组件和兄弟组件的实例// 组件b中\r\nvar relation_behavior = require('./path_to_relation_behavior')\r\nComponent({\r\n    behaviors:[relation_behavior],\r\n    methods:{\r\n        test () {\r\n            // 获得父组件的实例\r\n            let parent = this._parent()\r\n            \r\n            // 访问父组件的数据d\r\n            console.log(parent.data.name)\r\n            \r\n            // 修改父组件的数据\r\n            parent.setData({\r\n                name: 'test1'\r\n            })\r\n            \r\n            // 获得兄弟组件的实例\r\n            let sibling = this._sibling('c')\r\n            \r\n            // 访问兄弟组件的数据\r\n            console.log(sibling.data.name)\r\n            \r\n            // 修改兄弟组件的数据\r\n            sibling.setData({\r\n                name:\"test\"\r\n            })\r\n        }\r\n    }\r\n})\r\n \r\n// 组件c中\r\nvar relation_behavior = require('./path_to_relation_behavior')\r\nComponent({\r\n    behaviors:[relation_behavior],\r\n    methods:{\r\n        test () {\r\n            // 获得父组件的实例\r\n            let parent = this._parent()\r\n            \r\n            // 访问父组件的数据d\r\n            console.log(parent.data.name)\r\n            \r\n            // 修改父组件的数据\r\n            parent.setData({\r\n                name: 'test1'\r\n            })\r\n            \r\n            // 获得兄弟组件的实例\r\n            let sibling = this._sibling('b')\r\n            \r\n            // 访问兄弟组件的数据\r\n            console.log(sibling.data.name)\r\n            \r\n            // 修改兄弟组件的数据\r\n            sibling.setData({\r\n                name:\"test\"\r\n            })\r\n        }\r\n    }\r\n})\r\n复制代码同时需要注意，c和b两个组件，从relations属性的角度来说，是a的后代组件。但是组件b和组件c 所处的作用域, 都是主页面的作用域，传入的property都是主页面的property，这样就保证了组件数据的灵活性。relations 像一个隐形的链子一样把一堆组件关联起来，关联起来的组件可以相互访问，修改对方的数据，但是每一个组件都可以从外界独立的获取数据。看了这么多理论的东西，还是需要一个具体的场景来应用。比如说，我们有个一个分享记录图片心情的页面，当用户点击【点赞】的按钮时候，该心情的记录 点赞按钮会变红，下面的一栏位置会多出点赞人的名字。如果不通过组件化，很可能的做法是 修改一个点赞按钮，然后遍历数据更新数据，最后所有记录列表的状态都会被重新渲染一遍。如果是通过组件化拆分：把点赞的按钮封装为 组件b , 下面点赞人的框封装为 组件c, 每一个心情记录都是一个 组件a下面是代码实现// 在主页面内\r\n<view wx:for='{{feed_item}}'>\r\n    <a item='{{item}}'>\r\n        <b></b>\r\n        <c></c>\r\n    </a>\r\n<view>\r\n \r\n \r\n// 在组件a内\r\nvar behavior_relation = require('../../relation_behavior.js)  //这里引入上文说的Behavior\r\nComponent({\r\n    behaviors:[behavior_relation],\r\n    relations:{\r\n        '../b/b':{\r\n            type: 'descendant'\r\n        }\r\n    }\r\n})\r\n \r\n// 在组件b内\r\nvar behavior_relation = require('../../relation_behavior.js)  //这里引入上文说的Behavior\r\nComponent({\r\n    behaviors:[behavior_relation]\r\n    relations:{\r\n        '../a/a':{\r\n            type: 'ancestor'\r\n        }\r\n    },\r\n    data: {\r\n        is_like: false  //控制点赞图标的状态\r\n    },\r\n    methods:{\r\n        // 当用户点赞的时候\r\n        onClick () {\r\n            //  修改本组件的状态\r\n            this.setData({\r\n                is_like: true\r\n            })\r\n            // 修改 c 组件的数据\r\n            this._sibling('c').setData({\r\n                likeStr: this._sibling('c').data.likeStr + '我' \r\n            })\r\n        }\r\n    }\r\n})\r\n \r\n// 在组件c内\r\nvar behavior_relation = require('../../relation_behavior.js)  //这里引入上文说的Behavior\r\nComponent({\r\n    behaviors:[behavior_relation],\r\n    relations:{\r\n        '../a/a':{\r\n            type: 'ancestor'\r\n        }\r\n    },\r\n    data:{\r\n        likeStr:'晓红，小明'\r\n    }\r\n})\r\n复制代码这样，组件b 可以修改组件c中的数据。同时，组件b 和 组件c 又可以通过 properties 和 事件系统，和主页面保持独立的数据通信。"}
{"title": "手把手教你用Taro框架写一个图像处理类微信小程序 ", "author": "Rolan", "pub_time": "2019-1-17 00:32", "content": "18年年中的时候，笔者所在的公司让我们开发一款微信小程序（马卡龙玩图）。主要的玩法是用户上传一张人像照片，图片经过后端的AI算法处理后识别出人物，将人物和周围环境进行分割（俗称抠图）；前端将返回的抠像进行样式处理，包括设置大小位置旋转等；通过预设（或自定义上传）的一些主题场景以及点缀的贴纸或滤镜，用户对这些元素进行移动或缩放，可以衍生出很多好玩的修图玩法，比如更换动态背景，合成带有音频的动态视频等（文末有微信二维码）。开发初期，当时可选的成熟的微信小程序框架只有wepy，经过开发实践发现，wepy在多层嵌套列表渲染，组件化支持等方面体验不是很友好。后面美团的技术团队开源了一款基于vue的小程序框架mpvue，经过体验后感觉上，虽然在组件化上体验和vue别无差异，但是在性能上并不占优势。直到某天有位朋友拉我进了一个Taro的开发群，原来京东的前端团队也在开发一款基于React规范的小程序框架，由于当时笔者担心Taro尚处早期，功能上也许不足抑或bug，迟迟没有入手。直到最近更新到1.2.4的版本，群里有道友不吝溢美之词进行了一波安利，所以笔者决定对项目的部分模块进行了重构，发现Taro确实在开发体验和性能上都得到了非常好的提高，在此向taro的贡献者致以崇高的敬意。本着开源的精神，笔者也将此次重构的demo源码以及心得体会和大家一起分享。需求分析用户上传的人像经过抠图处理后，将展示在作图区，同时展示的元素还有背景图片，可动或固定的贴纸。为了获取更好的用户视觉体验，每个场景下，通过预设人像和贴纸的大小和位置（参数为作图区域的百分比等）。人像和贴纸需支持单指和双指手势操作来改变大小和位置等样式，因此可以将人像和贴纸都封装为Sticker的组件，子组件Sticker向页面父组件传递手势操作变更后的样式参数，触发父组件setState来刷新,最终通过传递props到子组件来控制样式。关于Sticker组件的一些细节还包括：贴纸组件具有激活状态（点击当前组件显示控制器，而其他组件则隐藏）；切换场景后，要缓存之前用户的操作，当切回到原先的场景时，则恢复到该场景下用户最后的操作状态。用户点击保存后，将作图区的所有元素按照层级大小进行排序，然后通过微信提供的canvas接口进行绘制，最终返回所见即所得的合成美图。准备工作根据Taro的文档，安装CLI工具以及创建项目模板，建议选择Typescript开发方式。项目目录简要分析下项目结构Taro-makaron-demo\r\n├── dist                   编译结果目录\r\n├── config                 配置目录\r\n|   ├── dev.js             开发时配置\r\n|   ├── index.js           默认配置\r\n|   └── prod.js            打包时配置\r\n├── src                    源码目录\r\n|   ├── assets             静态资源\r\n|   |   ├── images         图片\r\n|   ├── components         组件\r\n|   |   ├── Sticker        贴纸组件\r\n|   |   ├── ...            其他组件\r\n|   ├── model              Redux数据流\r\n|   |   ├── actions        \r\n|   |   ├── constants        \r\n|   |   ├── reducers        \r\n|   |   ├── store        \r\n|   ├── pages              页面文件目录\r\n|   |   ├── home           首页\r\n|   |   |   ├── index.js   index 页面逻辑\r\n|   |   |   └── index.css  index 页面样式\r\n|   |   ├── dynamic        作图页\r\n|   |   |   ├── index.js   index 页面逻辑\r\n|   |   |   └── index.css  index 页面样式\r\n|   ├── services           服务\r\n|   |   ├── config.ts      全局配置\r\n|   |   ├── api.config.ts  api接口配置\r\n|   |   ├── http.ts        封装的http服务\r\n|   |   ├── global_data.ts 全局对象\r\n|   |   ├── cache.ts       缓存服务\r\n|   |   ├── session.ts     会话服务\r\n|   |   ├── service.ts     基础服务或业务服务\r\n|   ├── utils              公共方法\r\n|   |   ├── tool.ts        工具函数\r\n|   ├── app.css            项目总通用样式\r\n|   └── app.js             项目入口文件\r\n└── package.json\r\n复制代码核心代码分析sticker贴纸组件贴纸组件相较其他展示型组件，涉及手势操作，大小位置计算等，所以稍显复杂。// 使用\r\nclass Page extends Component {\r\n    state = {\r\n        foreground: { // 人像state\r\n          id: 'foreground', // id\r\n          remoteUrl: '', // url\r\n          zIndex:2, // 层级\r\n          width:0, // 宽\r\n          height:0, // 高\r\n          x: 0, // x轴偏移量\r\n          y:0, // y轴偏移量\r\n          rotate: 0, // 旋转角度\r\n          originWidth: 0, // 原始宽度\r\n          originHeight: 0, // 原始高度\r\n          autoWidth: 0, // 自适应后的宽度\r\n          autoHeight: 0, // 自适应后的高度\r\n          autoScale: 0, // 相对画框缩放比例\r\n          fixed: false, // 是否固定\r\n          isActive: true, // 是否激活\r\n          visible: true, // 是否显示\r\n        }\r\n    }\r\n    render () {\r\n        reuturn <Sticker \r\n                    ref=\"foreground\"\r\n                    url={foreground.remoteUrl}\r\n                    stylePrams={foreground}                \r\n                    framePrams={frame}\r\n                    onChangeStyle={this.handleChangeStyle}\r\n                    onImageLoaded={this.handleForegroundLoaded}\r\n                    onTouchstart={this.handleForegroundTouchstart}\r\n                    onTouchend={this.handleForegroundTouchend}\r\n              />\r\n    }\r\n}\r\n\r\n// 组件定义\r\nclass Sticker extends Component {\r\n...\r\n    render() {\r\n        const { url, stylePrams } = this.props\r\n        const { framePrams } = this.state\r\n        const styleObj = this.formatStyle(this.props.stylePrams)\r\n        return (\r\n          <View \r\n            className={`sticker-wrap ${stylePrams.fixed ? 'event-through' : ''} ${(stylePrams.visible && stylePrams.width > 0) ? '' : 'hidden' }`}\r\n            style={styleObj}\r\n          > \r\n            <Image \r\n              src={url} \r\n              mode=\"widthFix\" \r\n              style=\"width:100%;height:100%\"\r\n              onLoad={this.handleImageLoaded} // 图片加载后将原始尺寸信息通知给父组件\r\n              onTouchstart={this.stickerOntouchstart} \r\n              onTouchmove={this.throttledStickerOntouchmove} // touchmove比较频繁，需要节留\r\n              onTouchend={this.stickerOntouchend}/>\r\n            <View className={`border ${stylePrams.isActive ? 'active' : ''}`}></View>\r\n            <View className={`control ${stylePrams.isActive ? 'active' : ''}`}\r\n              onTouchstart={this.arrowOntouchstart} \r\n              onTouchmove={this.throttledArrowOntouchmove}\r\n              onTouchend={this.arrowOntouchend}\r\n            >\r\n              <Image src={scale} mode=\"widthFix\" style=\"width:50%;height:50%\"/>\r\n            </View>\r\n          </View>\r\n        )\r\n    }\r\n}\r\n\r\n复制代码缓存服务 缓存服务对提高性能非常有帮助，比如canvas绘图需要图片是本地图片，可以通过数据字典的方式将图片的远程地址和下载到本地的地址进行一一对应，节省了大量的网络资源和时间// services/cache.ts 缓存服务\r\nfunction Cache (name) {\r\n  this.name = name\r\n}\r\nCache.prototype = {\r\n  set: function (key, value) {\r\n    this[key] = value\r\n    return this[key]\r\n  },\r\n  get: function (key) {\r\n    return this[key]\r\n  },\r\n  clear: function () {\r\n    // 清空\r\n    Object.keys(this).forEach(v => {\r\n      this[v] = null\r\n    })\r\n  }\r\n}\r\n\r\nexport const createCache = (name:string) => {\r\n  return new Cache(name)\r\n}\r\n// 使用\r\nimport {createCache} from '../../services/cache'\r\nclass Page extends Component {\r\n  cache = {\r\n    source: createCache('source'),\r\n  }\r\n  // 下载照片并存储到本地\r\n  downloadRemoteImage = async (remoteUrl = '') => {\r\n    const cacheKey = `${remoteUrl}_localPath`\r\n    const cache_source = this.cache['source']\r\n    let localImagePath = ''\r\n    if (cache_source.get(cacheKey)) {\r\n      // 有缓存\r\n      return cache_source.get(cacheKey)\r\n    } else {\r\n      try {\r\n        const result = await service.base.downloadFile(remoteUrl)\r\n        localImagePath = result.tempFilePath\r\n      } catch (err) {\r\n        console.log('下载图片失败', err)\r\n      }\r\n    }\r\n    return cache_source.set(cacheKey, localImagePath)\r\n  }\r\n}\r\n\r\n复制代码性能优化避免频繁setState由于微信小程序逻辑层和视图层各自独立，两边的数据传输是靠转换后的字符串。因此当setData频率过快，内容庞大时，会导致阻塞。由于本项目又涉及很多的手势操作，touchmove事件的频率很快，所以项目早期时候，在安卓系统下卡顿十分明显。优化方式有：通过做函数节流，降低setData频次；将页面无关的数据不要绑定到data上，而是绑定到组件实例上（牺牲运算效率换取空间效率）。使用微信的自定义组件，也是一个很大的提升因素，个人认猜测可能是自定义组件内部data的改变不会导致其他组件或页面的data更新。项目早期采用的是wepy框架，由于历史局限性（当时微信还未公布自定义组件方案），所以效率问题一直很是头疼。好在Taro框架通过编译的方式完美的支持了这个方案。归并setState例如，当图片加载，获取到原始尺寸后，需要计算出该图片在当前场景下的预设尺寸和位置。必须先计算出自适应后的宽高，然后才能计算出预设的偏移量。因此可以将尺寸和位置参数都计算完毕后，再调用setState更新视图，这样不仅降低了频次，同时也解决了图片闪烁的bug.利用缓存前面有提到过利用缓存模块来存储组件状态或资源信息，在此不再赘述。心得Taro框架采取的是一种编译的方式，将源代码分别编译出可以在不同端（微信/百度/支付宝/字节跳动小程序、H5、React-Native 等），因此可以在性能上与各个平台保持一致。而mpvue的方案则是修改vue的runtime，将vue 实例与小程序 Page 实例建立关联以及生命周期的绑定。私以为，这种通过映射的方式可能会导致通信效率上的降低，并且vue和微信又各自独立迭代，后期的协调也越来越费劲，所以个人感觉上，还是Taro的方案略胜一筹。个人薄见，还请海涵。"}
{"title": "微信小程序云开发之云函数创建 ", "author": "Rolan", "pub_time": "2019-1-3 00:07", "content": "云函数云函数是一段运行在云端的代码，无需管理服务器，在开发工具内编写、一键上传部署即可运行后端代码。小程序内提供了专门用于云函数调用的 API。开发者可以在云函数内使用 wx-server-sdk 提供的 getWXContext 方法获取到每次调用的上下文（appid、openid 等），无需维护复杂的鉴权机制，即可获取天然可信任的用户登录态（openid）。1. 云函数创建根据官网提示，创建一个云函数，命名为 add， 功能是将 a , b 两数相加，步骤如下：在文件夹 cloudfunctions 目录下创建文件夹 add, 编辑add中的index.js文件：// 云函数入口文件\r\nconst cloud = require('wx-server-sdk') \r\n\r\n// 云函数入口函数\r\nexports.main = async (event, context) => {\r\n  console.log(event)\r\n  console.log(context)\r\n\r\n  const {a, b} = event\r\n  const {OPENID, APPID} = cloud.getWXContext() // 这里获取到的 openId 和 appId 是可信的\r\n  const sum = a + b\r\n\r\n  return {\r\n    OPENID,\r\n    APPID,\r\n    sum\r\n  }\r\n}在小程序中调用这个云函数前，我们还需要先将该云函数部署到云端。在云函数目录上右键，在右键菜单中，我们可以将云函数整体打包上传并部署到线上环境中。2. 云函数调用部署完成后，我们可以在小程序中调用该云函数：//小程序端调用方法\r\nwx.cloud.callFunction({\r\n  // 需要调用的云函数名\r\n  name: 'sum',\r\n  // 传给云函数的参数\r\n  data: {\r\n    a: 1,\r\n    b: 2,\r\n  },\r\n  success: function(res) {\r\n    console.log(res.result.sum) // 3\r\n  },\r\n  fail: function(err) {\r\n      console.log(err)\r\n  }\r\n})\r\n也可以使用 Promise 调用方式：wx.cloud.callFunction({\r\n  // 云函数名称\r\n  name: 'add',\r\n  // 传给云函数的参数\r\n  data: {\r\n    a: 1,\r\n    b: 2,\r\n  },\r\n}).then(res => {\r\n    console.log(res.result) // 3\r\n  })\r\n  .catch(console.error)"}
{"title": "干货 | 小程序授权导致你流失50%用户？ ", "author": "Rolan", "pub_time": "2019-1-3 00:12", "content": "就是这个东西！导致你流失20%-50%的新用户。作者：楼兰古国来源：楼兰古国(ID:loulan630)本文为作者授权鸟哥笔记发布，转载请联系作者并注明出处。就是这个东西！导致你流失20%-50%的新用户。而市场上，至少一半的小程序开发者，正在进行着错误的授权方式。很多开发者，新用户流失而不自知；或者面对流失，不知怎么办。。。NOW，我们来一一解说，记得准备小本本记录有用的干货。如何看自己家小程序，有没有因为授权而流失，流失了多少？方法：1.当用户登录时（小程序生命周期onload加载时），立即获取Openid；2.授权时将头像昵称等信息存入数据库；3.然后对比数据库里授权用户数和openid数量，授权人数/总用户数；4.另外现在大部分都是要Button按钮唤起的用户授权，可以埋点统计授权按钮点击人数，也是一个参考依据。为什么会因为授权，流失这么多用户呢？猜测原因：1.用户对授权有顾虑，担心泄露隐私（当前部分国人已经开始注重隐私了，腾讯公司也十分在意隐私问题，不将用户基础信息直接开发给开发者。并且还必须要用按钮button触发，将隐私风险转移给开发者）；2.用户还不了解你这个产品的价值，在不知道这个小程序对其是否有用的情况下，用户不愿意暴露自己的隐私。（刚需的牛逼产品，可忽略这条）3.用户进入小程序其实和进入一个网页（一篇微信文章页面），是几乎一样的感觉，很多时候没有授权的准备，没有这个习惯。（和下载APP的感觉，习惯是不一样的，下载APP后有注册的习惯）4.部分老年用户，以及对小程序不熟悉的用户，对授权有恐惧感，不敢随便授权。但是用户授权有时候又是必须的？怎么办？小程序到底要不要授权用户头像昵称等？该怎么授权？什么阶段授权？首先普及一下openid的知识点：小程序拥有openid概念，即用户只要一进入小程序，通过wx.login()接口获取code值，发至后台服务器，可向微信平台获取该用户对自己这个小程序的唯一id，也可成为userid。其后续所有的操作以及数据皆可被记录在这个Id之下。这和app是完全不一样的，app注册之前，没有网络唯一Id。（当然也可以向微信或QQ等索取授权，不过第三方授权是要用户进行操作的，不像 小程序，是用户完全无感知的情况下获取到的Openid。 ）我们再来看一下APP的授权演变，有助于看清小程序未来授权的演变：APP注册授权，从很久以前注册账号+自定义密码，演变到用手机号+短信验证码注册，再演变成微信第三方登陆（有些app需要再验证一下手机号码，而有些甚至不需要授权手机号码）从这个演变过程中，可以看出来是在逐渐的让新用户注册变得简洁（毕竟每个新用户来之不易）此外注意：APP天然没有网络唯一ID  [唯一真实的ID]，所以必须要注册。（至于识别手机码，需考虑手机被盗的情况，非网络上的唯一id）至于有些人说的：不授权的用户不是你的用户，这完全是无稽之谈。每个新用户进来，应该先让他领略你这个应用的魅力所在，功能所在，然后再让用户判断是否留下or离开。而不是让他在授权用户信息这一步导致退却。Userinfo到底有什么用？是不是真的必须要用到，这也是一个很多开发者容易犯的错误。userinfo内包含用户昵称，头像，性别，语言，城市/省份/国家，UnionID。用户头像昵称，可以在会话转发卡片、生成分享海报的时候使用，提高转发会话卡片打开率、图片二维码识别率，能够让每一个分析者带来的用户增多。还可以在个人中心展示头像昵称，提高归属感。（这个其实可以用open-data，可不需授权，直接展示）（在这里多聊一句：非常希望微信提供用户备注名的Open-data功能，在排行榜上可使用，像王者荣耀那样，效果会比头像昵称好很多）性别可以用于数据分析、看那些忠实用户男女比例，可在投放广告的时候进行针对性投放。此外还可以做信息匹配，如婚恋类，给女性提供单身男性信息。城市/省份/国家/语言在排行榜，信息匹配上也大有妙用。unionid常常用在与公众号连接中，如关注公众号获得奖励。如果你的小程序用不到这些，则不需要授权！！！不用去授权的！！！finally，然而鱼与熊掌不可兼得。新用户流失with用户信息获取。该如何取舍，心中掂量掂量。这里建议的方法：1.用户信息在小程序领域并不是必须要获得的。他和保存到相册，收货地址，地理位置等授权是一样的。如果用不到这些头像昵称，性别，城市信息。可以永远不需要获取。2.如果需要用到用户信息，什么时候用到那些数据，什么时候去授权。3.尽量不要在新用户一进入应用的时候就授权，要让新用户体验一下你的产品，用户根据产品对其是否有吸引力来觉得是否留下或离开。而不是授权不授权。但具体要看你的产品了。具体怎么结合进入您的小程序，要自己细细思索了。也可加我 个人微信：loulan0176 （昵称：楼兰古国），共同探讨。"}
{"title": "小程序·云开发初级FAQ ", "author": "Rolan", "pub_time": "2019-1-3 00:29", "content": "之前参加过小程序·云开发相关的分享, 在团队内进行了推广, 感觉官方的宣传不够直接, 还是太玄乎了, 这是收集了猫眼娱乐前端工程师的问题, 和相关答疑, 部分问题是和小程序·云开发的同学沟通过的结论主要面向初级前端工程师, 快速了解云开发是怎么回事, 不涉及复杂代码有小程序开发经验理解 server 端基础, 并有少量node.js server端经验1. 小程序云开发是什么?官方文档, 不用着急点, 下面FAQ未提及的可以进来看主要提供两种能力1.1 提供持久存储持久存储是指删除微信或更换手机后, 用户重新打开我们的小程序, 仍旧能让用户看到自己的信息主要通过两种存储容器类mangodb的 数据库存储 , 比如用户提交的文章文件存储 , 比如用户上传的照片1.2 提供简化的server端编程环境云函数简单解释: 在小程序端写上函数名 + 参数, 就能调用远端的一个函数为什么不直接写到小程序端, 而要绕弯子要这样? 最常见的原因是:有些业务逻辑涉及 保密信息 , 不能写在小程序上, 比如: 价格计算, 交易流程有些操作需要 更高的权限 , 比如: 管理员可以删除所有用户的数据.桥接到第三方接口, 小程序https接口域名数量超限, 或者第三方接口不是https接口.2. 直接操作数据库会不会有安全问题云开发的数据库和传统数据库有些区别, 他会自动给每个数据表增加一个 创建人字段 + 表权限设置 , 后续的操作都会基于这些约束, 一般的策略是每个用户只能修改自己创建的信息, 比如自己发的文章每个用户只能读取其他用户的信息, 但不能修改, 比如其他人发的文章每个用户只能读取公共信息, 但不能修改, 比如公告信息, 一般会允许通过管理端修改3. 直接操作文件存储会不会有安全风险类似上一个数据库的权限, 通过 文件创建人 + 文件夹权限设置文件的操作使用服务端生成的唯一ID, 不会被穷举4. 别人会不会调用我的云函数不会, 云函数的网络协议是私有的, 并且有加上数字签名验证这套机制是在微信app内部实现的, 除非微信这套机制被攻破5.云函数是用js写么, 运行环境是什么?是js, 运行环境是nodejs 8.9, 支持async await关键字目前还不支持修改运行环境, 未来应该会支持自选环境6. 使用了云开发, 是不是就不能使用自己的服务端了不是, 两个可以并存, 就当是看起来不一样的异步调用就好// 云开发相关api\r\nwx.cloud.xxxx()\r\n\r\n// 自有服务\r\nwx.request()\r\n复制代码由于是nodejs的运行环境, 所以云函数可以使用http tcp模块, 这样就能通过云函数转发请求到任意域名, 不受小程序端的请求域名限制7. 典型的云函数是什么样的?// 小程序端, 调用\r\nwx.cloud.callFunction({\r\n    name: 'foo',\r\n    data: { a: 1, b: 2 },\r\n    success: function(res) {\r\n        console.log(res.result)\r\n    }\r\n)\r\n\r\n// 云函数, 声明\r\n// cloudfunctionRoot/functions/foo/index.js\r\nexports.main = async function(e, ctx) {\r\n    return e.a + e.b\r\n}\r\n复制代码函数名和目录名对应, 根路径在project.config.json中定义, 详细参考官方文档中的\"我的第一个云函数\"8. 云函数还有什么特殊能力?直接获取用户的openId// index.js\r\nexports.main = (event, context) => {\r\n  return event.userInfo\r\n}\r\n复制代码如要获取用户头像 昵称等信息, 还是需要在小程序端进行授权才行9. 云函数需要我们考虑服务器运维的工作么不需要, 只要开发好上传就行, 运行环境是独立 封闭的, 类 CentOS 7 的环境10. 开发时和线上环境有隔离么提供1个生产环境, 和1个开发环境, 存储和云函数都是独立的这意味着多个开发者并行开发协作可能会有些小麻烦, 同时只能有一套代码在开发环境, 这就只能通过一些工作流程约定, 比如收敛上传权限, 每日自动部署. 应用类似git-flow的分支策略11. 云开发是否提供有定位 地理信息 支付相关业务的支持暂时没有, 这方面的需求还是很强的, 毕竟小程序是提倡线下扫码, 扫码后还是期望能够获取到附近的相关信息, 简单的比如城市 区划, 详细的比如商家小程序云开发的同学目前还在收集这方面的需求12. 什么版本的基础库支持云开发基础库 2.2.3 之后开始支持, 但对于旧版本可以加个配置也能支持app.json/game.json{\r\n  \"cloud\": true\r\n}\r\n复制代码13. 费用呢目前免费, 正在调研计费策略, 可能是按照调用量, 存储量计费结语目前看云开发基本成型, 典型的业务都能覆盖到了, 还有一些周边的东西需要完善比如数据库存储这边的批量操作, 事务的支持, 存储容器还可以在增加一些, 比如消息队列, 其它的杂项如任务调度, 开发者环境隔离, 数据迁移升级另一方面, 作为前端工程师, 技术能力边界的延伸, 并不完全意味着获益, 还包括背景知识成本, 只有学习好这些, 才能驾驭好新的能力, 比如领域建模, 设计模式, 封装和隔离.大家好，我是猫眼娱乐前端技术专家-曹宇，我主要负责猫眼娱乐电影选座交易业务前端, 除了大家能看到的各种 Web 页面, 还有小程序端和供应链端. 同时负责猫眼内部的前端基础设施, 质量保证相关工作。猫眼电影小程序从零发展到票务类别第一, 主要关注点都集中在线上, 这次分享的是一个线上 线下联动的活动, 从开发到上线后遇到的一些有趣的事情, 除了小程序技术的深度应用, 还包括产品 运营层面的思考."}
{"title": "微信小程序解码工具 ", "author": "Rolan", "pub_time": "2019-1-4 00:40", "content": "项目地址起因  前段时间想学习微信小程序开发但是又没有什么深厚前端功底，看到很多很好玩的小程序想要做一个类似的学习学习，所以想着借鉴一下现有的小程序。但是苦于没有源码，抓包也没有办法获取源码。  google后知道可以用安卓模拟器安装微信然后安装小程序，然后在文件系统中找到小程序对应的wxapkg文件，拿到压缩包解压后就可以得到小程序源码。  但是压缩包是2进制文件，找了一遍后发现一个现有现有的开源项目可以直接解压小程序压缩包。废话不多说，直接开干～使用源码安装安装golang没有用过golang的人可以直接去官网下载go get github.com/sjatsh/unwxapkgcd ~/go/src/github.com/sjatsh/unwxapkg使用可执行文件下载地址使用unwxapkg -f dest/102.wxapkg图片发自简书App项目地址"}
{"title": "快速小程序开发之微信小程序内嵌 H5 ", "author": "Rolan", "pub_time": "2019-1-4 00:45", "content": "今日励志语要接受自己行动所带来的责任而非自己成就所带来的荣耀。前言微信小程序中可以直接运行 web 页面，这一新组件 web-view 的产生，可能直接导致小程序数量迎来一波高峰。本篇博文将从业务选型，微信小程序后台配置，使用 web-view 完成登录业务以及在实战中如何调试一次性带你感受小程序内嵌 H5 的风采，帮你更有底气的使用微信小程序新组件 web-view。技术选择H5 转成小程序方案路线优缺点对比上表是从原有 H5 转相似业务逻辑的微信小程序的方案路线优缺点对比，基于时间的限制以及当前主流多端编译的可靠性考量，最终团队认为通过使用小程序组件 web-view 内嵌 H5 的方式比较适合当前的开发需求。 web-view 的兼容性问题主要是要在基础库在1.6.4+及以上才可以用，而微信官方统计基础库在1.6.4+ 的覆盖率已达 95% 以上，这个指标也符合产品大人的要求，于是便愉快的选择了 web-view 内嵌 H5 的技术方案。H5 和小程序技术对比从上表中可以对比出 H5 相较于小程序的优缺点，方便各位前端大大评估需求。尤为重要的是因为小程序封装的比较严重所以小程序开发的灵活性没有 H5 那么高，这就要我们注意对交互设计的评估。web-view 微信小程序配置系列问题配置域名业务域名中配置的就是小程序以及 H5 和 H5 中引用 iframe 的域名。这里要特别注意的是假如 H5 中有内嵌的 iframe 也要配置进去这里需要服务端的朋友配合一下，将校验文件放置在将要嵌套的业务域名的根目录。所以要注意后端是否可以支持，否则会有各种扯皮的问题选择基础库开发的时候不要忘记配置微信小程序的基础库，注意 web-view 要在基础库1.6.4以上的版本库才能使用H5 中引入微信的 jssdk,其中包含了h5和小程序直接的通讯方法web-view 与小程序的通信官方给出了两种通信方法（如下图所示） 1、postMessage 通信 在 H5 中需要先用 wx.miniProgram.postMessage 接口，把需要分享的信息，推送给小程序。 在用户点击了小程序后退、组件销毁、分享这些特殊事件之后，小程序页面通过 bindmessage 绑定的函数读取 post 信息。 2、设置 web-view 组件的 URL 通信 H5 跳转小程序：toWeixin() {\r\n wx.miniProgram.navigateTo({url: '/pages/myWelfare/myWelfare'});\r\n}小程序跳转 H5： 首先在 .wxml 中引入 web-view 组件<view>\r\n<web-view src=\"{{url}}\" ></web-view>\r\n</view>之后在小程序的 js 文件中设置通过 URL 以问号传参的方式传入参数到 H5 中if(!option.page){\r\n      this.setData({\r\n        url: `${this.data.url}?${test}`\r\n      });\r\n    } else {\r\n      this.setData({\r\n        url: `${this.data.url}${option.page}?${test}`\r\n      });\r\n    }小程序内嵌 H5 登录实例小程序登录实现方案流程图：如上图所示：整个登录的 cookie 的传递经历了四个步骤：在小程序登录后获取到后端传递的 cookie 并保存通过 web-view 中的 url 传递到 H5 中在 H5 中得到传递的值并写到 cookie 中在访问接口的时候带上 cookie 2、从微信小程序响应头中获得 cookie 存到 storage 中：首先在登录页获取到响应头中的登录 cookie 放到 storage 中wx.setStorageSync('cookie', res.header[\"Set-Cookie\"]);在微信小程序中每次请求接口的时候，将 storage 中的 cookie 取出来，放到请求头中，如果传入不正确或者没有传入 cookie 值，后台将返回 errorCode 为 3002 ，此时前端跳转到登录页面。 var headerCookie = wx.getStorageSync('cookie');\r\n   wx.request({\r\n            url: murl,\r\n            data: parameter.data || {},\r\n            header: {\r\n               'Cookie': headerCookie\r\n            },\r\n            method: parameter.method || 'POST',\r\n            success: function(res) {\r\n            if(res.data.code == 3002) {\r\n                    wx.redirectTo({\r\n                        url: '../login/login'\r\n                    })\r\n                } else {\r\n                    parameter.success && parameter.success(res);\r\n                }\r\n\r\n            }3、获得 cookie 并拼接到 URL 中首先在 web-view 页面获取 cookie ,并匹配到需要传递的字段，之后将此字段放到 url 中通过问号传参的方式传递到 H5 中try {\r\n      var value = wx.getStorageSync('cookie');\r\n      if (value) {\r\n        test = value.match(new RegExp(\"(^| )\"+\"jxi-m-sid\"+\"=([^;]*)(;|$)\"))[2] ;\r\n      }\r\n    }url: 'https://www.xxx.com#',\r\n    if(!option.page){\r\n      this.setData({\r\n         //在这里放入传递的字段（如test）\r\n         url: `${this.data.url}?${test}`\r\n      });\r\n    } else {\r\n      this.setData({\r\n         //在这里放入传递的字段,也可以拼接更多的信息（如option.page）\r\n         url: `${this.data.url}${option.page}?${test}`\r\n      });\r\n    }4、获取 cookie 并在 H5 中使用 在 H5 中获取 cookie 值,并带入 cookie ,注意 domain 和 path 的设置，这两个值必须都有：let isDebug = (window.location.href).indexOf('myf') > -1;\r\nlet host = isDebug ? 'jd' : 'jdf';\r\n//获得传递的字段\r\nlet c =window.location.href.split('?')[1];\r\n//设置cookie\r\ndocument.cookie = `jxi-m-sid=${c};domain=${host};path=/`;小程序内嵌 H5 调试解决方案关于调试效果缓存的问题 小程序的更新机制即当小程序进入后台，客户端会维持一段时间的运行状态，超过一定时间后（目前是 5 分钟）会被微信主动销毁。 小程序销毁后再重新启动时如果发现有新版本，将会异步下载新版本的代码包，并同时用客户端本地的包进行启动，即新版本的小程序需要等下一次销毁后再重新启动时才会应用上。内嵌 H5 调试问题 因为微信小程序开发者工具中并没有提供内嵌 H5 的调试工具，所以我们可以采取以下方法调试在 H5 开发的时候，我们可以在微信小程序开发者工具中找到 web-view 传递给 H5 的 URL 链接将此链接黏贴到浏览器中即可像平时开发 H5 一样调试对于手机端 H5 的测试调试可以在 H5 中引入 vconsole 这个插件来调试程序，他可以让我们看到接口情况以及 H5 中的日志。总结看到这里，我们分别从web-view 技术的优缺点web-view 微信小程序配置系列问题web-view 与小程序的通信小程序内嵌 H5 登录实例小程序内嵌 H5 调试解决方案五个方面梳理了关于微信小程序 webview 组件的使用。 当然，微信小程序组件 web-view 还并不完善，其中很难实现一些特殊的交互，比如返回按钮返回的页面只能是上一级不能是任意自定义的页面等问题，这就需要我们更好的沟通以及规划交互设计，同时反馈并等待微信小程序官方的更新和支持。文章来源：京东设计中心"}
{"title": "微信小程序，实现 watch 属性，监听数据变化 ", "author": "Rolan", "pub_time": "2019-1-7 00:05", "content": "在微信小程序实现 watch 属性，监听 data 中的属性，当被监听属性的值改变时，执行我们指定的方法。​​思路Vue 的 computed 和 watch 可以很方便的检测数据的变化，从而做出相应的改变，所以，模仿 vue 肯定是一个不错的选择。与 Vue 一样，我们使用 ES5 的 Object.defineProperty() 方法，劫持对象的 getter/setter ，从而实现给对象赋值时(调用 setter)，执行 watch 对象中相对应的函数，达到监听效果。代码不啰嗦，上代码，真实可用。function observe(obj, key, watchFun, deep, page) {\r\n  let val = obj[key];\r\n\r\n  if (val != null && typeof val === \"object\" && deep) {\r\n    Object.keys(val).forEach((item) => {\r\n      observe(val, item, watchFun, deep, page);\r\n    });\r\n  }\r\n\r\n  Object.defineProperty(obj, key, {\r\n    configurable: true,\r\n    enumerable: true,\r\n    set: function(value) {\r\n      watchFun.call(page, value, val);\r\n      val = value;\r\n\r\n      if (deep) {\r\n        observe(obj, key, watchFun, deep, page);\r\n      }\r\n    },\r\n    get: function() {\r\n      return val;\r\n    }\r\n  });\r\n}\r\n\r\nexport function setWatcher(page) {\r\n  let data = page.data;\r\n  let watch = page.watch;\r\n\r\n  Object.keys(watch).forEach((item) => {\r\n    let targetData = data;\r\n    let keys = item.split(\".\");\r\n\r\n    for (let i = 0; i < keys.length - 1; i++) {\r\n      targetData = targetData[keys[i]];\r\n    }\r\n\r\n    let targetKey = keys[keys.length - 1];\r\n\r\n    let watchFun = watch[item].handler || watch[item];\r\n\r\n    let deep = watch[item].deep;\r\n    observe(targetData, targetKey, watchFun, deep, page);\r\n  });\r\n}\r\n复制代码注意事项：watch 只能监听已存在的属性，数组的 push() ， pop() 等方法并不会触发监听函数。使用import * as watch from \"./watch.js\";\r\n\r\nPage({\r\n  data: {\r\n    name: \"二狗子\"\r\n  },\r\n\r\n  onLoad() {\r\n    watch.setWatcher(this);\r\n  },\r\n\r\n  watch: {\r\n    name: function(newVal, oldVal) {\r\n      console.log(newVal, oldVal);\r\n    }\r\n  }\r\n});\r\n复制代码首先在需要的页面引入在 Page 的 onLoad 钩子设置监听器然后就可以愉快的使用了。"}
{"title": "微信小程序 组件叠加效果（如 Android 中的添加蒙层） ", "author": "Rolan", "pub_time": "2019-1-7 00:21", "content": "实现的效果如下：可以看出这是由image组件和text组件叠加到一块组成的蒙层效果。在小程序中实现这个效果主要用到z-index属性和position属性 z-index的使用必须是双方组件都设置了position属性才会生效。 z-index：表示的组件的层级关系，值越小越在最下方。 position：表示组件的位置，这里可以使用的值为fixed，absolute,使用relative不能实现该效果。 position 的可能值如下图：那么这里我们的的蒙版文字是在图片的上方，所以布局样式可以这么写：重点关注 position和z-index即可。这里的line-height: 100px;也很重要，否则蒙层上的文本是不能居中对齐的。布局<view class='item_view'>    <image class='img-class' src='https://gss2.bdstatic.com/9fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike72%2C5%2C5%2C72%2C24/sign=2f3a8c47f4deb48fef64a98c9176514c/78310a55b319ebc4658560bf8526cffc1e171612.jpg'></image>    <text class='text_num'>+3</text>  </view>样式.item_view{  margin-top: 100px;  text-align: center;  align-items: center;  justify-content: center;}.img-class{  width: 100px;  height: 100px;  z-index: -1;  position: fixed;}.text_num{  width: 100px;  height: 100px;  line-height: 100px;  background: rgb(99, 99, 105);  opacity: 0.5;  font-size: 14px;  color: rgb(248, 248, 244);  z-index: 100;  position: fixed;}本文完，欢迎你的喜欢、或者留言和我讨论~"}
{"title": "微信小程序发送短信验证码完整实例 ", "author": "Rolan", "pub_time": "2019-1-7 00:36", "content": "微信小程序注册完整实例，发送短信验证码，带60秒倒计时功能，无需服务器端。效果图:代码:index.wxml<!--index.wxml-->\r\n<view class=\"container\">\r\n  <view class='row'>\r\n     <input placeholder='请输入姓名' bindinput='bindNameInput'/> \r\n  </view>\r\n  \r\n  <view class='row'>\r\n     <input placeholder='请输入手机号' bindinput='bindPhoneInput'/> \r\n  </view>\r\n  <view class='row'>\r\n     <input placeholder='请输验证码' bindinput='bindCodeInput' style='width:70%;'/> \r\n     <button class='codeBtn' bindtap='getCode' hidden='{{hidden}}' disabled='{{btnDisabled}}'>{{btnValue}}</button>\r\n  </view>\r\n  <view>\r\n     <button class='save' bindtap='save' >保存</button>\r\n  </view>\r\n  \r\n</view>\r\nindex.js//index.js\r\nvar zhenzisms = require('../../utils/zhenzisms.js');\r\n//获取应用实例\r\nconst app = getApp();\r\n \r\nPage({\r\n  data: {\r\n    hidden: true,\r\n    btnValue:'',\r\n    btnDisabled:false,\r\n    name: '',\r\n    phone: '',\r\n    code: '',\r\n    second: 60\r\n  },\r\n  onLoad: function () {\r\n    \r\n  },\r\n  //姓名输入\r\n  bindNameInput(e) {\r\n    this.setData({\r\n      name: e.detail.value\r\n    })\r\n  },\r\n  //手机号输入\r\n  bindPhoneInput(e) {\r\n    console.log(e.detail.value);\r\n    var val = e.detail.value;\r\n    this.setData({\r\n      phone: val\r\n    })\r\n    if(val != ''){\r\n      this.setData({\r\n        hidden: false,\r\n        btnValue: '获取验证码'\r\n      })\r\n    }else{\r\n      this.setData({\r\n        hidden: true\r\n      })\r\n    }\r\n  },\r\n  //验证码输入\r\n  bindCodeInput(e) {\r\n    this.setData({\r\n      code: e.detail.value\r\n    })\r\n  },\r\n  //获取短信验证码\r\n  getCode(e) {\r\n    console.log('获取验证码');\r\n    var that = this;\r\n    zhenzisms.client.init('https://sms_developer.zhenzikj.com', 'appId', 'appSecret');\r\n    zhenzisms.client.send(function (res) {\r\n      if(res.data.code == 0){\r\n        that.timer();\r\n        return ;\r\n      }\r\n      wx.showToast({\r\n        title: res.data.data,\r\n        icon: 'none',\r\n        duration: 2000\r\n      })\r\n    }, '15801636347', '验证码为:3322');\r\n    \r\n  },\r\n  timer: function () {\r\n    let promise = new Promise((resolve, reject) => {\r\n      let setTimer = setInterval(\r\n        () => {\r\n          var second = this.data.second - 1;\r\n          this.setData({\r\n            second: second,\r\n            btnValue: second+'秒',\r\n            btnDisabled: true\r\n          })\r\n          if (this.data.second <= 0) {\r\n            this.setData({\r\n              second: 60,\r\n              btnValue: '获取验证码',\r\n              btnDisabled: false\r\n            })\r\n            resolve(setTimer)\r\n          }\r\n        }\r\n        , 1000)\r\n    })\r\n    promise.then((setTimer) => {\r\n      clearInterval(setTimer)\r\n    })\r\n  },\r\n  //保存\r\n  save(e) {\r\n    console.log('姓名: ' + this.data.name);\r\n    console.log('手机号: ' + this.data.phone);\r\n    console.log('验证码: ' + this.data.code);\r\n \r\n     //省略提交过程\r\n  }\r\n})\r\nindex.wxss/**index.wxss**/\r\npage{\r\n  height: 100%;\r\n  width: 100%;\r\n  background: linear-gradient(#5681d7, #486ec3);\r\n  display: flex;\r\n  flex-direction: column;\r\n}\r\n.container{\r\n  display: flex;\r\n  flex-direction: column;\r\n  justify-content: space-around;\r\n  width: 90%;\r\n  margin: 50rpx auto;\r\n}\r\n \r\n.row{\r\n  position: relative;\r\n  height: 80rpx;\r\n  width: 100%;\r\n  border-radius: 10rpx;\r\n  background: #fff;\r\n  margin-bottom: 20rpx;\r\n  padding-left: 20rpx;\r\n  box-sizing: border-box;\r\n}\r\n.row input{\r\n  width: 100%;\r\n  height:100%;\r\n}\r\n.codeBtn{\r\n  position: absolute;\r\n  right: 0;\r\n  top: 0;\r\n  color: #bbb;\r\n  width: 30%;\r\n  font-size: 26rpx;\r\n  height: 80rpx;\r\n  line-height: 80rpx;\r\n}\r\n.subBtn{\r\n  width: 200rpx;\r\n  height: 80rpx;\r\n  background: #fff;\r\n  color: #000;\r\n  border-radius: 50rpx;\r\n  line-height: 80rpx;\r\n}\r\n完整下载: 下载详情参考: http://smsow.zhenzikj.com/doc..."}
{"title": "小程序云开发实战 --云数据库 ", "author": "Rolan", "pub_time": "2019-1-7 00:52", "content": "以前一直是使用关系型数据库，第一次使用NoSQL，跟大家分享一下我有限的使用心得，希望对像我一样初使用NoSQL的开发者有所帮助。首先说说微信小程序云开发里集成的这个NoSQL，官方并没有说明是哪种NoSQL数据库，但从开发文档和暴露的API，还有官方论坛里的讨论来看应该是一个简化版的MongoDB。需要指出的是微信小程序关于云数据库的开发文档非常的简略，对于像我这样没有太多NoSQL经验的用户，很多时候需要参考MongoDB的相关文档。接下来重点谈谈我在使用这个NoSQL云数据库时最不适应的一个痛点----文档级别的原子操作。我们经常要使用到原子操作，来避免当多个用户同时对同一个field（字段）编辑时发生冲突。我在使用前其实最担心的痛点是有无schema的区别，但是使用下来发现我挺习惯，也挺喜欢无schema的，后文再详说。现在具体来看看MongoDB只支持document（文档）级别的原子操作。对于我来说，这个限制鼓励我尽量把所有关系都放在一个document里。对此我一开始是有点抗拒的，对于从关系型数据库过来的人特别不习惯。而更让我苦恼的是微信小程序云开发集成的这个云数据库是一个简化版MongoDB，只提供了非常有限的原子操作指令（command）。对于一些常用的document级别原子操作，我必须构想自己的解决办法，而没有提供直接对应的command。以下是两个我在实际开发中遇到的这类问题及我的解决办法：1.应用场景：对于一个视频，我需要一个叫total_likes的field（字段），当有用户点击“喜欢”时该field递增1，当有用户取消“喜欢”时该field递减1。痛点：小程序云数据库只提供了递增指令的原子操作，没有提供递减指令。const _ = db.command\r\ndb.collection('video').doc('video-id').update({\r\n  data: {\r\n    total_likes: _.inc(1)\r\n  }\r\n})解决办法：要实现递减的原子操作，只需在递增指令里传入负数，如data: {\r\n  total_likes: _.inc(-1)\r\n}\r\n2.应用场景：对于一个线上课程，我需要一个叫subscribers的field（字段）来记录有多少人订阅了该课程。当有用户点击“订阅”时该字段需记录该用户的id，名字及头像；当有用户取消“订阅”时需把该用户从subscribers字段里删除。痛点：我们很自然的会想到用数组（Array）数据类型来维护subscribers这个字段，虽然小程序云数据库提供了一些针对数组的原子操作，如push，pop，shift和unshfit，可是无法实现取消订阅这个场景的原子操作。解决办法：弃用Array转而使用对象（object）数据类型来维护subscribers这个字段。最终的数据看起来会是这样的：{\r\n    \"subscribers\": {\r\n        \"userID-1\": {\r\n            \"name\": \"小明\",\r\n            \"avatar\": \"https://avatar-1.com\"\r\n        },\r\n        \"userID-2\": {\r\n            \"name\": \"小红\",\r\n            \"avatar\": \"https://avatar-2.com\"\r\n        },\r\n        \"userID-3\": {\r\n            \"name\": \"小李\",\r\n            \"avatar\": \"https://avatar-3.com\"\r\n        },\r\n        ...\r\n    }\r\n}当有用户订阅时的原子操作：const subscriber = \"subscribers.\" + user.id;\r\ndb.collection('class').where({\r\n  _id: 'classID',\r\n}).limit(1).update({\r\n  data: {\r\n    [subscriber]: {\r\n      avatar: user.avatar,\r\n      name: user.name,\r\n    }\r\n  }\r\n})当有用户取消订阅时的原子操作：const subscriber = \"subscribers.\" + user.id;\r\ndb.collection('class').doc('classID').update({\r\n  data: {\r\n    [subscriber]: _.remove()\r\n  }\r\n})前文说到我很喜欢无schema，因为它非常适合快速迭代开发。而且由于云数据库使用的是类似JSON的数据结构，对于全栈开发者，基本上可以实现由前端来定义数据结构。这样的开发流程非常适合小团队，不需要庞大的并行开发，突出沟通效率和对产品需求的随机应变。顺带一提的是微信小程序云开发能力是从基础库2.2.3开始支持的，但如果要支持所有版本的基础库，可以在 app.json / game.json 中增加字段 \"cloud\": true本系列第一章：小程序云开发实战系列01--云环境设置《Meetup丨活动报名组局》是我最近开发的一个活动报名预约工具小程序，这个系列文章主要来自我在开发这款小程序时的一些体会心得。感兴趣的小伙伴可以扫下面的二维码进入我的小程序。"}
{"title": "mpvue开发大型体育项目及总结记 ", "author": "Rolan", "pub_time": "2019-1-8 00:07", "content": "最近接到上头的指示，要做一个体育类的小程序，并且要在元旦之前上线一版，看了下时间，距离元旦只有一个多月，而且除去测试的时间和双休，最多只有三个星期，时间相当的紧迫，而且需求文档都更新到1.3了，这也就意味着安卓和ios的版本迭代已经到了1.3了，而我们小程序要在三个星期内开发完1.0-1.3版本的功能，所以我们的时间相当的紧迫，看了下需求文档和原型图，我整个人大吃一惊，有100多个页面，我顿时懵逼了，产品经理更我说；你们只需做三个模块，最后一个模块不用做，我看了一下最后一个模块，有10几个页面，除去10几个页面还有90多个呀，页面还好，最难的是需求文档的业务逻辑呀，而且这个项目的难度比中小型电商项目类的要难的多，交互相当的频繁和复杂，怎么办呢，一句话，凉拌，毕竟这是boss要求做的项目，只好硬着头皮往下做，不得不从。技术选型因小程序页面多，切交互频繁，如果用原生开发的话，时间来不急，而且页面的交互很多，这样原生小程序就显得那么的吃力了，最终我将技术选型放在了，wepy和mpvue这两个框架上，wepy框架是微信官方维护的，兼容性和扩展性很好，mpvue是美团旗下的，我最终选择了mpvue，原因是mpvue的语法跟Vue的语法是一样的，而且我们的前端同学都会Vue，所以选择mpvue是最好的选择，于是看了一下mpvue的文档和注意点，最终搭建了小程序的项目结构，将任务安排了下去，于是开启了加班的苦日子....技术点1-小程序，安卓，iOS三端数据信息同步，免登陆因项目中的登录方式含有微信登录，所以三端协商，如果用户是微信登录的话，三端统一取， unionid 这个字段，这时肯定有同学要问；为什么不取 openid ，如果做过小程序的人一定知道openid是唯一的标识，微信小程序有一个，那么在安卓，iOS他们也都有自已的openid标识，所以这样是不能达到三端数据信息同步，免登陆的效果的，微信官方介绍了6种获取 unionid 的方法,我们项目最终采用了解密获取的方法，官方文档。import {AchieveOpenid} from '@/http/api.js';\r\n    let that=this;\r\n    wx.login({\r\n        async success(resCode){\r\n            const cache=await AchieveOpenid({    //openid,内部服务器=》腾讯获取到了openid\r\n                code:resCode.code\r\n            });\r\n            that.openid=cache.result.unionid;\r\n            wx.setStorageSync('openId',that.openid);\r\n        }\r\n    })\r\n复制代码注意：这个方法是官方中的wx.login+code2Session方法，也确实可以获取unionid，但是天有不测风云呀，测试组的人员测出了unionid不存在的情况，而且还有几个账号也出现了这种问题，那么我们就开始找原因，最终我们发现，如果用户没有关注过任何的公众号，微信是不会给他返回unionid的，我们找到原因之后，马上换了另外一种方法，那就是解码的方式，也是我们最终的方法。<button class='openpage-authorize' \r\n            open-type=\"getUserInfo\" \r\n            lang=\"zh_CN\" \r\n            @getuserinfo=\"onGotUserInfo\">\r\n    </button>\r\n复制代码//注意我这里只列举解码的代码，有些代码省略了，请熟知。\r\n   import WXBizDataCrypt from \"@/utils/cryptojs/RdWXBizDataCrypt.js\"   //引用解码\r\n    methods:{\r\n         deCode(encryptedData,iv,sessionKey){\r\n         let wxObj=null,data=null;\r\n             wxObj= new WXBizDataCrypt('wx3ea59bf3ff3a9bb8', sessionKey);\r\n             data= wxObj.decryptData(encryptedData,iv);\r\n            this.openid=data.unionId;\r\n            wx.setStorageSync('openId',data.unionId);\r\n        },\r\n        onGotUserInfo(e) {   //通过按钮触发getuserinfo\r\n            if(e.mp.detail.userInfo){\r\n                this.deCode(e.mp.detail.encryptedData,e.mp.detail.iv,this.sessionKey);\r\n            }else{\r\n                toast('请再次授权');\r\n            }\r\n        },\r\n    }\r\n复制代码最终我们可以通过上面的代码获取 unionId ， 解码地址下载 , 注意：解码这一步最好放在服务端解码，不要放在客户端解码，这样会造成信息泄露.....技术点2-在小程序中使用canvas我们可以看到上面两个项目中的案例图片，他们是用canvas画的，第一个是采用微信官方的api，wx.createCanvasContext 不懂得同学可以自已去看 微信官方文档，代码如下const ctx = wx.createCanvasContext('myCanvas');\r\n            ctx.setLineCap('round')\r\n            var gradient1=ctx.createLinearGradient(0,0,170,0);\r\n            gradient1.addColorStop(\"0\",\"#FFF956\");\r\n            gradient1.addColorStop(\"1.0\",\"#FF6C00\");\r\n            var gradient2=ctx.createLinearGradient(0,0,170,0);\r\n            gradient2.addColorStop(\"0\",\"#8156FE\");\r\n            gradient2.addColorStop(\"1.0\",\"#3AFFF1\");\r\n            ctx.setLineWidth(4);\r\n            ctx.beginPath();\r\n            ctx.arc(50, 50, 30,0.75*Math.PI,0.25*Math.PI,false);\r\n            ctx.setStrokeStyle('#4e4f59');\r\n            ctx.stroke()\r\n            ctx.beginPath();\r\n            ctx.arc(50, 50, 38,0.75*Math.PI,0.25*Math.PI,false);\r\n            ctx.setStrokeStyle('#4e4f59');\r\n            ctx.stroke();\r\n            //胜\r\n            ctx.beginPath();\r\n            ctx.arc(50, 50, 30,0.75*Math.PI,(((winarc*1.5+0.75)%2)==0?2:((winarc*1.5+0.75)%2))*Math.PI,false);\r\n            ctx.setStrokeStyle(gradient1)\r\n            ctx.stroke()\r\n            //负\r\n            ctx.beginPath();\r\n            ctx.arc(50, 50, 38,0.75*Math.PI,(((failarc*1.5+0.75)%2)==0?2:((failarc*1.5+0.75)%2))*Math.PI,false)\r\n            ctx.setStrokeStyle(gradient2);\r\n            ctx.stroke()\r\n            ctx.setTextAlign('center');\r\n            ctx.setFontSize(16);\r\n            ctx.setFillStyle('#fff');\r\n            ctx.setTextBaseline('middle');\r\n            ctx.fillText('战绩', 50, 50);\r\n            ctx.draw()\r\n复制代码注意点：如果canva的数据是异步的话，一定要在数据加载完成之后，在让它渲染到视图层中去，如果不这样做的话，canvas会数据不同步，具体的做法可以加一个开关，如下..<canvas canvas-id=\"myCanvas\" class=\"index-header-data-circle-canvas\" v-if='on'></canvas>\r\n复制代码data(){\r\n       return {\r\n           on:false\r\n       }\r\n   }\r\n   async xx(){\r\n        try{\r\n             const data=await xxx();\r\n             this.on=data.code==='000'?true:false;\r\n        }catch (error) {}\r\n   }\r\n   //注意：以上代码只是模拟，仅供查考。\r\n复制代码技术点3-图片上传转化base64图片上传微信小程序给我们提供了api, wx.chooseImage ，上传简单，关键是如何转化base64位呢，我们的舒同学用了如下的写法，看着确实没什么问题，用临时路径作为一个请求的url，把数据返回格式设置成arraybuffer，这个也确实是个办法，在微信开发工具里面也是ok的，但是天有不测风云呀，在真机上请求报错了，那么这种方法pass掉。wx.chooseImage({\r\n      success:res=>{\r\n            wx.request({\r\n                  url:url,\r\n                  responseType: 'arraybuffer', //最关键的参数，设置返回的数据格式为arraybuffer\r\n                  success:res=>{\r\n                        let base64 = wx.arrayBufferToBase64(res.data); \r\n                      }\r\n           })\r\n})\r\n复制代码针对上面的问题，仔细的看了下微信官方文档，最终找到了一个代码少，简单的方法， wx.getFileSystemManager() 这个api可以解决我们上面的问题，微信官方文档，代码如下wx.chooseImage({\r\n                count: 1,\r\n                sizeType: ['original', 'compressed'],\r\n                sourceType: ['album', 'camera'],\r\n                success:(res)=>{\r\n                     wx.getFileSystemManager().readFile({\r\n                                filePath:res.tempFilePaths[0],  //选择图片返回的相对路径\r\n                                encoding: 'base64', \r\n                                success: res => {  \r\n                                     console.log(res.data)\r\n                                }\r\n                    })\r\n                }\r\n              })\r\n复制代码其实除了， wx.getFileSystemManager() 可以解决我们的问题外，还有一种方法，那就是更html5一样的处理方法，通过canvas来画，然后在用canvas的api来转base64， 注意：如果通过canvas来转base64的话，有个bug,那就是在iOS手机上图片会出现旋转90度的问题 小程序可以借鉴 这个同学的方法来解决 ，如果是html5的话可以通过 exif.js 这个库来解决问题。技术点4-对picker的封装小程序中有个picker组件，他支持5中类型，虽然有5中类型但是每个项目的不同，所以对picker的用途就不同，因此我们将对picker进行封装，来达到满足我们项目的需求,我们封装省市，时间日期等组件，我这里就只介绍 省市 组件的封装，其他的组件封装原理同省市组件原理一样的，我这里就不多说了，代码如下。<picker  class=\"pickes\"  mode=\"multiSelector\" \r\n           @change=\"PickerChange\"\r\n           @columnchange=\"PickerColumnChange\" \r\n           :range=\"allList\" \r\n           range-key='provinceName'  \r\n           :value='multiIndex' v-if='show'>\r\n          <div class=\"slot\"></div>\r\n    </picker>\r\n复制代码/**\r\n * @describe 省市选择器\r\n * @rerurn  省，市，省id,市id\r\n */\r\n  import {allCity} from \"@/http/api.js\";\r\n  export default {\r\n      data() {\r\n        return {\r\n            list:[],\r\n            multiIndex: [0, 0], //显示化动的列数\r\n            allList:[],    //存储二维数据\r\n            singleList:[], //存储一维数组\r\n            show:false,    //防止数据没有加载出来\r\n            cityInfo:{},   //存储省，市，省id,市id\r\n        }\r\n      },\r\n      mounted(){\r\n        this.init();\r\n      },\r\n      methods:{\r\n        async init(){   \r\n            try {\r\n                 let child=[],data=null;\r\n                  data=await allCity();  //获取后台返回的城市\r\n                  this.singleList=data.result;\r\n                 child.push(data.result[0]);\r\n                 this.allList.push(data.result,child);\r\n                this.show=true;\r\n            } catch (error) {}\r\n        },\r\n          PickerChange(e) {\r\n             this.cityInfo.provinceId=this.singleList[e.mp.detail.value[0]].provinceId; //省id\r\n             this.cityInfo.provinceName=this.singleList[e.mp.detail.value[0]].provinceName; //省名\r\n             this.cityInfo.cityId=this.singleList[e.mp.detail.value[0]].cityList[e.mp.detail.value[1]].cityId; //城市id\r\n             this.cityInfo.cityName=this.singleList[e.mp.detail.value[0]].cityList[e.mp.detail.value[1]].cityName; //城市名\r\n             this.$emit('cityInfo',this.cityInfo); //将值传给父组件\r\n          },\r\n          PickerColumnChange(e) {\r\n            switch (e.mp.detail.column) {\r\n              case 0:\r\n                this.list = [];\r\n                this.singleList.forEach(item => {\r\n                       if (item.provinceId ==this.singleList[e.mp.detail.value].provinceId) {\r\n                         item.cityList.forEach(item=>{\r\n                           //注意这一步最为重要，给数组添加一个和父对象一样的键值名，这样picker组件可以找的到\r\n                             item.provinceName=item.cityName;  \r\n                         })\r\n                      }\r\n                   });\r\n                this.allList[1]=this.list;\r\n                this.multiIndex[0]=e.mp.detail.value;\r\n                this.multiIndex[1]=0;  //注意这个表示的时选择中省切换的时候，要将省的第一个城市放在第一位\r\n                break;\r\n            }\r\n          },\r\n      }\r\n  }\r\n复制代码技术点5-在小程序使用高德定位因项目中要用到定位功能，而小程序中的的api并不适用项目，所以就选择了高德定位，高德小程序版文档，代码如下//注意我这里只列举定位的代码，有些代码省略了，请熟知。\r\n   \r\n    let _this = this,myAmapFun=null;\r\n     myAmapFun = new amapFile.AMapWX({\r\n        key: \"xxxxx\"   //高德的密钥\r\n    });\r\n    myAmapFun.getRegeo({\r\n        success(data){\r\n            _this.$store.dispatch('cityLocal',data[0].regeocodeData.addressComponent.city);\r\n        },\r\n        fail(err) {\r\n               wx.showModal({\r\n                    title: '提示',\r\n                    content: '定位失败，请手动定位',\r\n                    success (res) {\r\n                        if (res.confirm) {\r\n                        path({url:'/pages/city/main'});\r\n                        }else if (res.cancel) {\r\n                           _this.$store.dispatch('cityLocal','定位失败');\r\n                        }\r\n                    }\r\n                })\r\n        }\r\n    });\r\n复制代码技术点6-对微信小程序节点的运用由于项目用到了城市索引选择功能，所以就采用 wx.createSelectorQuery() 这个api来实现这个功能，代码如下<ul  class=\"slide\">\r\n        <li v-for=\"(item,index) in cityJson.leter\" \r\n            :key=\"index\" \r\n            @tap='touStart(item.letid,item.lettext)'>\r\n            {{item.lettext}}\r\n        </li>\r\n     </ul>\r\n复制代码//注意我这里只列举城市索引选择的代码，有些代码省略了，请熟知。\r\n   onPageScroll(e){\r\n        this.scollTop=e.scrollTop    //同步\r\n    },\r\n    methods:{\r\n         touStart(flag,text){\r\n                 try {\r\n                    wx.createSelectorQuery().select(flag).fields({   //运用微信节点api\r\n                    dataset: true,\r\n                        size: true,\r\n                        rect: true,\r\n                        computedStyle: ['margin', 'backgroundColor']\r\n                        }, (res)=> {\r\n                            wx.pageScrollTo({\r\n                                    scrollTop: this.scollTop+res.top,\r\n                                    duration: 0\r\n                            });\r\n                            this.on=true;\r\n                            this.modalText=text;\r\n                            setTimeout(()=>{\r\n                                  this.on=false;\r\n                            },2000)\r\n                        }).exec() \r\n                 }catch (error) {}\r\n            },\r\n    }\r\n复制代码当然实现上面这个功能也可以用其他的方法，如scroll-view，我这里就不多说了。技术点7-返回上一层页面，刷新页面数据我们可以通过微信中的 wx.navigateBack() 这个api就可以返回上一层页面，但是怎样返回上一层页面并且刷新呢，其实可以通过onShow这个生命周期函数来刷新页面，如果那个页面含有参数的话，最好代码这么写onShow(){\r\n//之所以用try，是因为mpvue官方说，如果要获取地址参数的话，最好在mounted周期里面获取，我们用try可以避免代码终止和报错\r\n     try {   \r\n         let id=this.$root.$mp.query.Id;\r\n         this.init(id);\r\n     }catch (error) {}\r\n}\r\n复制代码结语由于时间的原因，我暂时先介绍这几个在小程序中常见的问题和功能，后面我会陆续介绍，如下技术栈vue的三种ssr方法,以及在项目中的使用react+redux在项目中的使用打造自已的webpack,gulp开发环境koa框架的介绍和使用"}
{"title": "小程序开发采的几个坑 ", "author": "Rolan", "pub_time": "2019-1-8 00:16", "content": "上个月参与了助力小程序的开发，其中也遇到了一些小程序开发过程之中的问题。getMenuButtonBoundingClientRect获取菜单按钮（右上角胶囊按钮）的布局位置信息。坐标信息以屏幕左上角为原点。如果我们使用的是自定义导航模式（ navigationStyle: 'custom' ），一般则需要通过此函数来获取菜单按钮的信息：此函数从官方文档上看是同步的，但是经过实际中发现，它可能是异步的。经常有的时候会获取不到相应的 bottom、top 等信息。video 组件的全屏问题经过测试发现，小程序的 video 组件会在进入全屏播放，然后退出全屏的过程中黑屏。重现步骤： 1.视频进行全屏播放 2.拉动进度条播放 3.页面显示加载中时，点击小屏播放 4.页面显示黑屏，并且卡住不动，一直无法播放经过确认，是微信官方的 Bug：低版本 IOS 兼容性问题因为小程序底层也是通过 webview 来渲染，所以有一些通用的兼容性问题要注意。 比如IOS9、IOS10下面的绝对定位（absolute、fixed）必须要有多个定位(left / top)，如果只写一个定位，比如只写一个 top: 0; ，你会发现在开发者工具和 IOS11以上真机是可以显示的，但是在低版本上却无法显示。"}
{"title": "微信小程序之构建 ", "author": "Rolan", "pub_time": "2019-1-8 00:27", "content": "由于小程序更新迭代速度很快，而且我们的技术栈是 react 全家桶，所以在对比 wepy 和 mpvue 之后，我们选择了直接使用原生小程序。对比图如下：当然直接使用原生的有个显然的缺点：没有了构建。不过这没有关系，缺什么补上即可。需要构建做什么一般来说，我们需要构建主要是用来做这些工作：ES6/7 转 ES5、NPM 包管理、组件化、 CSS 预编译、图片压缩、打包合并等。而这些能力除了CSS 预编译和图片压缩之外，其他的功能小程序默认已经提供了。所以一个小巧的小程序构建只需要支持CSS 预编译和图片压缩即可。Gulp 构建方案既然只涉及到一些任务的处理，那么使用 gulp 是最合适不过的了。对于 CSS 预编译，有 gulp 对应的 sass、less、postcss 插件可选；对于图片压缩，可以使用 gulp 的 imagemini 插件，再装上各种图片的格式对应的压缩库即可。一般来说，运行构建命令，我们都会从一个源目录（src）到一个目标目录（dev/dist），但是小程序的 NPM 能力是不允许 node_modules 在根目录之外的，这就有了冲突。总不能跑个任务拷贝整个 node_modules 到目标目录吧。既然不能使用从一个源目录（src）到一个目标目录（dev/dist），那就只好在源目录就地解决了。源目录解决方案对于图片来说，压缩完了直接替换原图是没什么问题的。对于 CSS 预编译来说，如使用 postcss，从 CSS 文件到 WXSS 文件比较好解决。但是又引出了两个新问题：CSS 文件最好是不要打包发布。最好避免误修改 WXSS 文件，而是直接修改 CSS 文件。第一个我们可以在项目配置文件中设置上传代码的时候过滤 CSS 文件；第二个我们可以在 VSCode 编辑器中隐藏 WXSS 文件，避免误操作。To Base64既然有了构建，当然希望还能把一些缺失的能力补上。如 background 不支持本地图片。对于这个 postcss 也有相关的插件能解决：background-image\r\n代码配置最后贴上相关的代码配置。gulpfile.jsconst gulp = require('gulp');\r\nconst rename = require('gulp-rename');\r\nconst runSequence = require('run-sequence');\r\nconst postcss = require('gulp-postcss');\r\nconst imagemin = require('gulp-imagemin');\r\nconst cache = require('gulp-cache'); // 使用缓存\r\n\r\nconst src = './miniprogram';\r\n\r\n// 使用postcss\r\ngulp.task('css', () => {\r\n  return gulp.src(`${src}/**/*.css`)\r\n    .pipe(postcss())\r\n    .pipe(rename((path) => {\r\n      path.extname = '.wxss';\r\n    }))\r\n    .pipe(gulp.dest((file) => {\r\n      return file.base; // 原目录\r\n    }));\r\n});\r\n\r\ngulp.task('img', () => {\r\n  // 修改你要压缩的图片地址\r\n  return gulp.src(`${src}/**/*.{png,jpe?g,gif,svg}`)\r\n    .pipe(cache(imagemin([\r\n      imagemin.gifsicle({ interlaced: true }),\r\n      imagemin.jpegtran({ progressive: true }),\r\n      imagemin.optipng({ optimizationLevel: 4 }),\r\n      imagemin.svgo({\r\n        plugins: [\r\n          { removeDimensions: true }, // 如果有 viewbox 则不需要 width 和 height\r\n        ],\r\n      }),\r\n    ])))\r\n    .pipe(gulp.dest((file) => {\r\n      return file.base; // 压缩到原目录\r\n    }));\r\n});\r\n\r\ngulp.task('watch', () => {\r\n  gulp.watch(`${src}/**/*.css`, ['css']);\r\n});\r\n\r\ngulp.task('dev', ['css'], () => {\r\n  runSequence('watch');\r\n});postcss.config.jsconst path = require('path');\r\n\r\nmodule.exports = {\r\n  parser: 'postcss-scss',\r\n  plugins: {\r\n    'postcss-partial-import': {\r\n      path: [path.resolve(__dirname, 'src')],\r\n    },\r\n    'postcss-font-base64': {}, // font to base64\r\n    'postcss-advanced-variables': {},\r\n    'postcss-nested': {},\r\n    'postcss-extend-rule': {},\r\n    'postcss-color-function': {},\r\n    'postcss-url': {\r\n      url: 'inline', // inline image to base64\r\n    },\r\n  },\r\n};"}
{"title": "微信小程序登录那些事 ", "author": "Rolan", "pub_time": "2019-1-9 00:06", "content": "最近团队在开发一款小程序，都是新手，一边看文档，一边开发。在开发中会遇到各种问题，今天把小程序登录这块的流程整理下，做个记录。\r\n小程序的登录跟平时自己APP这种登录验证还不太一样，多了一个角色，那就是微信服务器。\r\n\r\n根据微信官方提供的登录流程时序图可以清楚的了解小程序登录需要多少个步骤，下面我们来总结下：\r\n\r\n小程序启动，通过wx.login()获取code\r\n开发者服务器需要提供一个登录的接口，参数就是小程序获取的code\r\n登录接口收到code后，调用微信提供的接口进行code的验证\r\n得到验证结果，成功后能得到一个session_key和openid\r\n生成一个自定义的key, 将session_key和openid跟自定义的key关联起来\r\n将自定义的key返回给小程序\r\n每次请求都带上key, 后端根据key获取openid识别当前用户身份\r\n\r\n首先code是微信给的，如果你随意生成code去验证肯定是无效的，只有微信给的code才有效。code传到开发者自己的服务后，再去问微信：\r\nHi 哥们，我这个code是有效的还是无效的啊？\r\n微信会告诉你是有效还是无效，有效的情况下还会给你一个用户的标识，也就是openid，同时还会有一个session_key，也就是会话的key。session_key的有效期默认是2小时，当用户一直在使用小程序的话会自动刷新，这个是由微信这边来维护的。\r\n注意：\r\n\r\n会话密钥 session_key 是对用户数据进行 加密签名 的密钥。为了应用自身的数据安全，开发者服务器不应该把会话密钥下发到小程序，也不应该对外提供这个密钥。\r\n临时登录凭证 code 只能使用一次\r\n\r\n所以我们要为session_key创建别名，这个别名关联的哪个用户只有我们自己知道，唯一需要做的工作就在这块。\r\n我推荐2种方式来做关联：\r\n第一种：\r\n随机生成key, 关联openid，存入redis中，当请求带入key，直接从redis中获取openid得到当前用户信息，这个其实也就是我们自己去维护了会话信息\r\n第二种：\r\n采用JWT生成token，将openid绑定到token中，将token返回给小程序，请求的时候带上token，通过解析token得到用户信息。\r\n下面我们以第二种方式来进行讲解，会贴上部分代码：\r\n小程序中在app.js中的onLaunch方法中增加获取code方法，并且调用后端的登录接口获取token:\r\nwx.login({\r\n      success: function (res) {\r\n        var code = res.code;\r\n        if (code) {\r\n          console.log('app启动获取用户登录凭证：' + code);\r\n          let params = { \"code\": code };\r\n          let result = config.requestHttp(config.url.userLogin, 'POST', params)\r\n          result.then(res => {\r\n            let data = res.data\r\n            if (data.code == 200) {\r\n              wx.setStorageSync(\"login_token\", data.data.token);\r\n            }\r\n          }).catch(err => {\r\n            console.log(err)\r\n          });\r\n        } else {\r\n          console.log('获取用户登录态失败：' + res.errMsg);\r\n        }\r\n      }\r\n})\r\n复制代码userLogin接口则根据小程序的code去调用微信接口验证：\r\n// 小程序获取SessionKey接口地址\r\nString loginUrl = \"https://api.weixin.qq.com/sns/jscode2session\";\r\nString url = loginUrl + \"?appid=%s&secret=%s&grant_type=%s&js_code=%s\";\r\nurl = String.format(url, appid, appSecret, grantType, param.getCode());\r\nString result = restTemplate.getForObject(url, String.class);\r\nMap<String, Object> map = JsonUtils.toBean(Map.class, result);\r\n// 请求成功\r\nif (map.containsKey(\"session_key\")) {\r\n\tString openid = map.get(\"openid\").toString();\r\n    // 第一次保存到用户表，生成JWT TOKEN返回\r\n}\r\n复制代码小程序端需要将 wx.request()封装成一个通用的方法，所有跟后台交互都用这个方法来调用接口，我们可以在这个方法中设置登录之后获取的Token。这样每次请求都会将Token塞到请求头中，我们在网关中就可以获取这个Token进行解析验证。\r\n//请求封装\r\nfunction requestHttp(url, method, data) {\r\n  //请求头设置\r\n  var header = {\r\n    Authorization: wx.getStorageSync(\"login_token\")\r\n  }\r\n  return new Promise((resolve, reject) => {\r\n    wx.request({\r\n      url: config.home_config + url,\r\n      data: data,\r\n      header: header,\r\n      method: method,\r\n      success: (res => {\r\n        if (res.data.code === 200) {\r\n          resolve(res)\r\n        } else {\r\n          reject(res)\r\n        }\r\n      }),\r\n      fail: (res => {\r\n        reject(res)\r\n      })\r\n    })\r\n  })\r\n}\r\n复制代码Zuul中进行验证：\r\n  RequestContext ctx = RequestContext.getCurrentContext();\r\n  HttpServletRequest request = ctx.getRequest();\r\n  String token = request.getHeader(\"Authorization\");\r\n  if (StringUtils.isBlank(token)) {\r\n    \t\tctx.setSendZuulResponse(false);\r\n            ctx.set(\"isSuccess\", false);\r\n            ctx.setResponseBody(JsonUtils.toJson(Response.fail(\"非法请求【缺少Authorization】\", ResponseCode.NO_AUTH_CODE)));\r\n            ctx.getResponse().setContentType(\"application/json; charset=utf-8\");\r\n            return null;\r\n  }\r\n    \r\n  // 验证Token是否有效\r\n  JWTResult jwResult = JWTUtils.checkToken(token);\r\n  if (!jwResult.isStatus()) {\r\n    \t\tctx.setSendZuulResponse(false);\r\n            ctx.set(\"isSuccess\", false);\r\n            ctx.setResponseBody(JsonUtils.toJson(Response.fail(jwResult.getMsg(), jwResult.getCode())));\r\n            ctx.getResponse().setContentType(\"application/json; charset=utf-8\");\r\n            return null;\r\n   }\r\n   ctx.addZuulRequestHeader(\"loginUserId\", jwResult.getUid());\r\n   return null;\r\n复制代码验证成功后将用户ID设置到请求头中，传递给后端服务使用。\r\n使用JWT必然有一个问题是Token的失效问题，我这边失效时间设置的为2个小时，正常的话用户打开小程序，使用不可能连续超过2个小时，登录的逻辑是在app.js中做的，只要下次进去token就会重新申请。不过这个也可以调整，比如稍微长一点。\r\n核心就是用户的认证交给了微信，只要微信告诉我们认证成功了，我们就可以自己接管会话信息了。"}
{"title": "微信小程序地图(map)组件点击(tap)获取经纬度 ", "author": "Rolan", "pub_time": "2019-1-9 00:23", "content": "微信小程序中使用地图(map)组件，通过点击(tap)获取经纬度，按照官方的回应，暂时是没法做到的，从地图组件API多有残缺判断，怀疑是个实习生干的...做个变通，适用性有限，请大家参考。基本思路就是在地图上铺满一层marker，从而通过点击marker获得经纬度。<map id=\"map\" longitude=\"102.324520\" latitude=\"40.099994\" scale=\"4\" bindcontroltap=\"controltap\"polygons=\"{{polygons}}\" bindregionchange=\"regionchange\" markers=\"{{markers}}\"bindmarkertap=\"markertap\" show-location style=\"width: 100%; height: 700px;\"></map>const app = getApp()\r\n\r\nconst markersize = 30\r\n\r\nfunction range(start, edge, step) {\r\n  for (var ret = [];\r\n    (edge - start) * step > 0; start += step) {\r\n    ret.push(start);\r\n  }\r\n  return ret;\r\n}\r\n\r\nfunction markers(northeast, southwest, scale, width, height) {\r\n\r\n  const markerslng = (northeast.longitude - southwest.longitude) * markersize / width\r\n  const markerslat = (northeast.latitude - southwest.latitude) * markersize / height\r\n\r\n  const maxlon = northeast.longitude\r\n  const minlon = southwest.longitude\r\n  const maxlat = northeast.latitude\r\n  const minlat = southwest.latitude\r\n\r\n  const lons = range(minlon, maxlon, markerslng)\r\n  const lats = range(minlat, maxlat, markerslat)\r\n\r\n  let _markers = []\r\n  lons.forEach((lon, i) => {\r\n    lats.forEach((lat, j) => {\r\n      _markers.push({\r\n        id: lon + ',' + lat,\r\n        latitude: lat,\r\n        longitude: lon,\r\n        iconPath: '/marker.png',\r\n        alpha: 0.1, //将图片设置为透明,通过开发者工具看不出效果,但真机是有效果的\r\n        width: markersize,\r\n        height: markersize\r\n      })\r\n    })\r\n  })\r\n  return _markers\r\n}\r\n\r\nPage({\r\n  data: {\r\n    polygons: [],\r\n    controls: [{\r\n      id: 1,\r\n      position: {\r\n        left: 0,\r\n        top: 300 - 50,\r\n        width: 50,\r\n        height: 50\r\n      },\r\n      clickable: true\r\n    }],\r\n    markers: []\r\n  },\r\n  createMarkers() {\r\n\r\n    this.mapCtx = wx.createMapContext('map')\r\n    const query = wx.createSelectorQuery()\r\n    const map = query.select('#map').boundingClientRect()\r\n\r\n    let that = this\r\n\r\n    that.mapCtx.getRegion({\r\n      success(res1) {\r\n        that.mapCtx.getScale({\r\n          success(res2) {\r\n            query.exec((res) => {\r\n              let width = res[0].width;\r\n              let height = res[0].height;\r\n              let _markers = markers(res1.northeast, res1.southwest, res2.scale, width, height)\r\n              that.data.markers = _markers\r\n              that.setData(that.data)\r\n            })\r\n          }\r\n        })\r\n      }\r\n    })\r\n  },\r\n  regionchange(e) {\r\n    this.createMarkers()\r\n  },\r\n  markertap(e) {\r\n    console.log(e.markerId)\r\n  },\r\n  controltap(e) {\r\n    console.log(e.controlId)\r\n  },\r\n  onReady(e) {\r\n    this.createMarkers()\r\n  }\r\n})效果如图"}
{"title": "记一次微信小程序在安卓的白屏问题 ", "author": "Rolan", "pub_time": "2018-12-25 00:30", "content": "在做小程序的时候，做到了一个限时商品售卖，用到了倒计时，因为这个原因导致了安卓手机上使用小程序时，将小程序放入后台运行一段时间后，再次进入小程序后出现了页面白屏或者点击事件失效的情况，这里记录下1.相关代码文件我这里是使用了自定义组件的形式来渲染的外部的引用的自定义组件的wxml文件/* limitCommodity是一个数组，返回的是商品对象，包含商品价格、商品结束时间、商品图片等 */\r\n<block wx:for=\"{{limitCommodity}}\" wx:key=\"{{item.id}}\">\r\n    <commodityItem class=\"specialContent\" goods=\"{{item}}\" />\r\n</block>自定义组件的js文件Component({\r\n  properties: {\r\n    goods: Object\r\n  },\r\n  data: {\r\n  },\r\n  timer: null,\r\n  /* 在组件实例进入页面节点树时执行，开始定时器 */\r\n  attached: function() {\r\n    if(this.timer) {\r\n      clearInterval(this.timer);\r\n    }\r\n    this.filterTime();\r\n    let that = this;    \r\n    this.timer = setInterval(function () {\r\n      that.filterTime();\r\n    }, 1000)\r\n  },\r\n  /* 在组件实例被从页面节点树移除时执行，将定时器清除 */\r\n  detached: function() {\r\n    clearInterval(this.timer);\r\n    this.timer = null;\r\n  },\r\n  methods: {\r\n    /* 用于将时间戳转换成自定义的时间格式 */\r\n    filterTime() {\r\n      let totalTime = new Date(parseInt(this.data.goods.endtime) * 1000) - new Date();\r\n      let days = parseInt(totalTime / 1000 / 60 / 60 / 24, 10);\r\n      let hours = parseInt(totalTime / 1000 / 60 / 60 % 24, 10);\r\n      let minutes = parseInt(totalTime / 1000 / 60 % 60, 10);\r\n      let seconds = parseInt(totalTime / 1000 % 60, 10);\r\n      let day = days >= 10 ? days : '0' + days;\r\n      day = day == 0 ? '' : day + '天';\r\n      let hour = hours >= 10 ? hours : '0' + hours;\r\n      let minute = minutes >= 10 ? minutes : '0' + minutes;\r\n      let second = seconds >= 10 ? seconds : '0' + seconds;\r\n      this.setData({\r\n        limitTime: day + hour + \":\" + minute + \":\" + second\r\n      })\r\n    },\r\n  }\r\n})2.引起的原因因为在外部引入自定义的组件时，直接就是调用了定时器并且进行了setData操作，这就导致了当在外部引用这个组件时，如果传入的商品数组长度较大时，定时器增多的同时，setData操作也不断的增多setData多了就会导致内存占用多3.改进方法改进方法就是减少setData操作可以再自定义一个组件，用于将整个数组传入然后对商品数组里的时间先进行计算改进后的js文件Component({\r\n  properties: {\r\n    limitCommodity:Array\r\n  },\r\n  data: {\r\n  },\r\n  timeOut:null,\r\n  /* 在组件实例进入页面节点树时执行 */\r\n  attached(){\r\n    this.calculate();\r\n  },\r\n  /* 在组件实例被从页面节点树移除时执行，将定时器清除 */\r\n  detached(){\r\n    clearTimeout(this.timeOut);\r\n    this.timeOut = null;\r\n  },\r\n  methods: {\r\n    filterTime(endtime) {\r\n      let totalTime = new Date(parseInt(endtime) * 1000) - new Date();\r\n      let days = parseInt(totalTime / 1000 / 60 / 60 / 24, 10);\r\n      let hours = parseInt(totalTime / 1000 / 60 / 60 % 24, 10);\r\n      let minutes = parseInt(totalTime / 1000 / 60 % 60, 10);\r\n      let seconds = parseInt(totalTime / 1000 % 60, 10);\r\n      let day = days >= 10 ? days : '0' + days;\r\n      day = day == 0 ? '' : day + '天';\r\n      let hour = hours >= 10 ? hours : '0' + hours;\r\n      let minute = minutes >= 10 ? minutes : '0' + minutes;\r\n      let second = seconds >= 10 ? seconds : '0' + seconds;\r\n      return day + hour + \":\" + minute + \":\" + second\r\n    },\r\n    calculate(){\r\n      let limitCommodity = this.data.limitCommodity;\r\n      for (let i = 0; i < limitCommodity.length;i++){\r\n        limitCommodity[i]['endtime_date'] = this.filterTime(limitCommodity[i]['endtime'])\r\n      }\r\n      this.setData({\r\n        limitCommodity\r\n      })\r\n      this.timeOut = setTimeout(()=>{\r\n        this.calculate();\r\n      },1000);\r\n    }\r\n  }\r\n})改进就是计算时间后再返回时间，而setData的是整个商品列表数组，这样就减少了setData次数正在努力学习中，若对你的学习有帮助，留下你的印记呗（点个赞咯^_^）往期好文推荐：判断iOS和Android及PC端纯css实现瀑布流（multi-column多列及flex布局）实现单行及多行文字超出后加省略号微信小程序之购物车和父子组件传值及calc的注意事项"}
{"title": "使用LeanCloud快速开发一款小程序 ", "author": "Rolan", "pub_time": "2018-12-26 00:23", "content": "开发小程序离不开后台数据，对于独立开发者来说，既要写前端，又要写后端，工作量就会骤然增大。微信提供的云开发无疑是给独立开发者提供了很大的便利，但是由于其数据库不支持联表查询，对于某些场景就不是那么的友好了。当然，市面上有很多的 BaaS 服务提供商，大都类似，今天我们就用其中的一个 LeanCloud 来讲解一下，如何快速使用 LeanCloud 来开发一个小程序。 由于本次重点在 LeanCloud ，所以小程序的开发内容就不是重点。现在开始账号注册先去leancloud.cn官网注册一个账号，然后登录去控制台创建一个新应用。域名配置在微信小程序后台中配置域名白名单，具体需要按照这里说明的来配置，你也可以先跳过这一步，等完全开发完毕后再来配置。可在开发者工具的 详情 > 项目设置 中勾选 不校验安全域名、TLS 版本以及 HTTPS 证书 。SDK 集成下载你熟悉的SDK，目前支持 JS ， WePY ， mpvue ，下载链接在这里，后面以 JS 来说明，其他方式的 SDK 导入以及使用方法参考文档中的说明。初始化 SDK在 app.js 中加入以下代码即可。 appId 和 appKey 可以在控制台中的应用找到。const AV = require('./utils/av-live-query-weapp-min');\r\n\r\nAV.init({\r\n  appId: '换成你自己的appId',\r\n  appKey: '换成你自己的appKey',\r\n});\r\n复制代码查询数据先需要在控制台中的应用下新建一个表，在网页中叫做 Class 。每一张表会默认创建 objectId 、 createdAt 、 updatedAt 、 ACL 四个字段，分别表示 数据索引 ， 创建时间 ， 更新时间、 权限 。你可以添加你想要的字段，目前支持以下几种类型。其中 Object 是 map 对象， GeoPoint 是经纬度信息， Pointer 是另外一张表的表名，做多表联合查询使用的。 假设我们的表名是 T_TODO ，我们可以用以下代码来查询该表下面的数据。new AV.Query('T_TODO')\r\n      .descending('createdAt') // 排序\r\n      .limit(10) // 分页数量\r\n      .skip(10) // 跳过数量\r\n      .find()\r\n      .then(function(results) {\r\n      \t\tthat.setData({todo: results})\r\n      })\r\n      .catch(console.error);\r\n  }\r\n复制代码在你的 WXML 中可以这样写来做数据绑定：<!-- pages/todos/todos.wxml -->\r\n<block wx:for=\"{{todos}}\" wx:for-item=\"todo\" wx:key=\"objectId\">\r\n<text data-id=\"{{todo.objectId}}\">\r\n  {{todo.content}}\r\n</text>\r\n</block>\r\n复制代码是不是很方便。多表查询如果需要多多表查询，先要在一张表中新建一个 Pointer 字段，新建时会让你选择指向的表名，如下图所示：然后在查询是使用 include，就会返回关联表中的所有信息了，如下所示：new AV.Query('T_TODO')\r\n      .descending('createdAt') // 排序\r\n      .limit(10) // 分页数量\r\n      .skip(10) // 跳过数量\r\n      .include('T_POINT_CLASS')\r\n      .find()\r\n      .then(function(results) {\r\n      \t\tthat.setData({todo: results})\r\n      })\r\n      .catch(console.error);\r\n  }\r\n复制代码更新对象小程序中对表中字段做操作后，需要同步更新到服务端，可以使用以下代码来保存对象。// 第一个参数是 className，第二个参数是 objectId\r\n  var todo = AV.Object.createWithoutData('Todo', '5745557f71cfe40068c6abe0');\r\n  // 修改属性\r\n  todo.set('content', '每周工程师会议，本周改为周三下午3点半。');\r\n  // 保存到云端\r\n  todo.save();\r\n复制代码其他更多的操作请查看文档，不过你找不到小程序对应的详细开发文档，只能找到 数据存储开发指南 · JavaScript"}
{"title": "小程序--人脸识别功能（百度ai） ", "author": "Rolan", "pub_time": "2018-12-26 00:32", "content": "文档中心：https://ai.baidu.com/docs#/Begin/a2bbf4b2接入流程1. 按照文档获取AppID、API Key、Secret Key，进行Access Token（用户身份验证和授权的凭证）的生成const getBaiduToken = function () {\r\n    return new Promise((resolve, reject) => {\r\n        //自行获取APIKey、SecretKey\r\n        const apiKey = APIKey;\r\n        const secKey = SecretKey;\r\n        const tokenUrl = `https://aip.baidubce.com/oauth/2.0/token?grant_type=client_credentials&client_id=${apiKey}&client_secret=${secKey}`;\r\n        wx.request({\r\n            url: tokenUrl,\r\n            method: 'POST',\r\n            dataType: \"json\",\r\n            header: {\r\n                'content-type': 'application/json; charset=UTF-8'\r\n            },\r\n            success: function (res) {\r\n                resolve(res);\r\n            },\r\n            fail: function (res) {\r\n                wx.hideLoading();\r\n                wx.showToast({\r\n                    title: '网络错误，请重试！',\r\n                    icon: 'none',\r\n                    duration: 2000\r\n                })\r\n                reject(res);\r\n            },\r\n            complete: function (res) {\r\n                resolve(res);\r\n            }\r\n        })\r\n    })\r\n}2. 选择人脸识别-->人脸检测，人脸识别接口分为V2和V3两个版本，确认在百度云后台获得的是V2还是v3版本接口权限。//封装识别方法\r\nconst getImgIdentify = function(tokenUrl, data){\r\n    return new Promise((resolve, reject) => {\r\n        const detectUrl = `https://aip.baidubce.com/rest/2.0/face/v3/detect?access_token=${tokenUrl}`;\r\n        wx.request({\r\n            url: detectUrl,\r\n            data: data,\r\n            method: 'POST',\r\n            dataType: \"json\",\r\n            header: {\r\n                'content-type': 'Content-Type:application/json; charset=UTF-8'\r\n            },\r\n            success: function (res) {\r\n                resolve(res);\r\n            },\r\n            fail: function (res) {\r\n                wx.hideLoading();\r\n                wx.showToast({\r\n                    title: '网络错误，请重试！',\r\n                    icon: 'none',\r\n                    duration: 2000\r\n                })\r\n                reject(res);\r\n            },\r\n            complete: function (res) {\r\n                resolve(res);\r\n            }\r\n        })\r\n    })\r\n}\r\n3. 调用识别方法getBaiduToken().then((res) => {\r\n    let token = res.data.access_token;\r\n    let data = {\r\n        \"image\": self.data.img,\r\n        \"image_type\":\"URL\",\r\n        \"face_field\":\"ge,beauty,expression,face_shape,gender,glasses,landmark,race,quality,eye_status,emotion,face_type\"\r\n    }\r\n    util.getImgIdentify(token, data).then((res)=>{\r\n        //百度接口返回的结果\r\n        let score = parseInt(res.data.result.face_list[0].beauty);\r\n        self.setData({\r\n            score: score,\r\n        })\r\n    })\r\n})4. 结果如下：哼～一点都不准原文地址：https://github.com/liujianxi/..."}
{"title": "小程序 - 验证码倒计时组件 ", "author": "Rolan", "pub_time": "2018-12-27 00:08", "content": "发送验证码倒计时的方法很常见，在项目里面也经常会多次用到，这时就要把倒计时封装为组件，需要用到的时候方便使用。\r\n\r\n自定义组件\r\n需要封装一个组件，首先要熟悉小程序自定义组件的文档。官方文档在这里\r\n倒计时组件\r\n为了方便描述，我把页面定义为父组件，把倒计时组件定义为子组件吧。\r\n\r\n首先需要清楚子组件与父组件之间事件的响应方法，例如：子组件响应父组件的事件，子组件修改父组件的data属性等。\r\n\r\n小程序没有像Vue里面的watch模式也没有computed计算属性，但是还好小程序properties里有observer，官方文档说observer表示属性值被更改时的响应函数，那这样就好办了。\r\n当子组件倒计时完成之后，需要告诉父组件，子组件已经完成了倒计时，这里可以用到方法传递的e.detail来处理。\r\n\r\n\r\n子组件代码\r\ncountdown.js\r\nComponent({\r\n  /**\r\n   * 组件的属性列表\r\n   */\r\n  properties: {\r\n    // 是否开始倒计时\r\n    start: {\r\n      type: Boolean,\r\n      value: false,\r\n      observer(newVal){\r\n        if (newVal === true) {\r\n          this.countdownFunc()\r\n        }\r\n      }\r\n    }\r\n  },\r\n\r\n  /**\r\n   * 组件的初始数据\r\n   */\r\n  data: {\r\n    timerText: '获取验证码'\r\n  },\r\n\r\n  /**\r\n   * 组件的方法列表\r\n   */\r\n  methods: {\r\n    /**\r\n     * 触发页面点击事件\r\n     */\r\n    _getCountdownEvent(){\r\n      this.triggerEvent(\"getCountdownEvent\")\r\n    },\r\n\r\n    /**\r\n     * 触发页面修改data事件\r\n     */\r\n    _setStartDataEvent() {\r\n      this.triggerEvent(\"setStartDataEvent\", this.data.start)\r\n    },\r\n\r\n    /**\r\n     * 倒计时\r\n     */\r\n    countdownFunc() {\r\n\r\n      this.setData({\r\n        timerText: 60\r\n      })\r\n      let target = this\r\n      let countdownNum = target.data.timerText\r\n\r\n      let timer = setInterval(() => {\r\n        countdownNum--\r\n\r\n        target.setData({\r\n          timerText: countdownNum\r\n        })\r\n\r\n        if (countdownNum == 0) {\r\n          target.setData({\r\n            timerText: '重新发送',\r\n            start: false\r\n          })\r\n\r\n          this._setStartDataEvent() //倒计时为0时，让父组件的start重新设置为false\r\n          \r\n          clearInterval(timer) //清除定时器\r\n        }\r\n\r\n      }, 1000)\r\n    }\r\n  }\r\n})\r\n复制代码显示的倒计时（timerText）可以根据自己需求重新修改。\r\ncountdown.wxml\r\n<view bindtap=\"_getCountdownEvent\">{{timerText}}{{start?'s后重试':''}}</view>\r\n复制代码页面使用\r\n调用组件需要在相应的json文件里面注册，这个我就不说了。\r\n父组件代码\r\nsendRandom.wxml\r\n<countdown id=\"sendRandom\" \r\n    start=\"{{start}}\"\r\n    bind:getCountdownEvent=\"_getCountdownEvent\"\r\n    bind:setStartDataEvent=\"_setStartDataEvent\"\r\n    >\r\n</countdown>\r\n复制代码sendRandom.js\r\nPage({\r\n\r\n  /**\r\n   * 页面的初始数据\r\n   */\r\n  data: {\r\n    start: false\r\n  },\r\n\r\n  /**\r\n   * 点击获取验证码\r\n   */\r\n  _getCountdownEvent(e) {\r\n  \r\n  // todo: 点击获取验证码之后，可以根据自己的需求，通知子组件可以开始倒计时了\r\n  // 如： 向后台请求发送验证码的方法，请求成功之后将start设置为true，表示倒计时开始了。\r\n    \r\n    if (this.data.start === true) {\r\n      return\r\n    }\r\n    this.setData({\r\n      start: true\r\n    })\r\n  },\r\n\r\n  /**\r\n   * 倒计时结束 设置setData为false\r\n   */\r\n  _setStartDataEvent(e){\r\n    if (e.detail === false) {\r\n      this.setData({\r\n        start: false\r\n      })\r\n    }\r\n  }\r\n  \r\n})\r\n复制代码结语\r\n以上是根据自己公司的需求封装的倒计时组件，写得不够优雅，只是想记录一下小程序自定义组件的互相传值和事件响应。如有更好的方法可以提供下思路。"}
{"title": "从入到放弃——快应用踩坑之路 ", "author": "Rolan", "pub_time": "2018-12-27 00:15", "content": "伴随着我司快应用审核通过、上线，此处应该有一篇快应用踩坑经历。我司开发的快应用刚好涉及到音频、视频、Feeds流业务，下面我说分享一下我在开发中遇到的问题。\r\n项目搭建\r\n  hap init <project_name> // 生成一个快应用项目脚手架\r\n  cd project_name\r\n  npm install // 安装依赖\r\n  npm run build // 打包快应用，输出build和dist文件夹\r\n  npm run watch // 监测到变化后自动编译\r\n  npm run server // 在另起一个终端开启server\r\n复制代码如果node版本用的是8以上的话，在运行完npm install后再运行npm run build时可能会报Cannot find module .../webpack.config.js异常，请重新执行一次hap update --force。这是由于高版本的npm在npm install时，会校验并删除了node_modules下部分文件夹，导致报错。而hap update --force会重新复制hap-toolkit文件夹到node_modules\r\n项目发布\r\n由于我们在开发环境下是用的debug签名，而正式发布到应用市场是需要正式签名\r\n创建私钥：\r\n通过openssl命令等工具生成签名文件private.pem、certificate.pem，例如：\r\nopenssl req -newkey rsa:2048 -nodes -keyout private.pem -x509 -days 3650 -out certificate.pem\r\n(密钥长度，1024觉得不够安全的话可以用2048，但是代价也相应增大)\r\n在工程的sign目录下创建release目录，将私钥文件private.pem和证书文件certificate.pem拷贝进去\r\nCountry Name (2 letter code) [XX]:CN   #国家代码（中国）\r\nState or Province Name (full name) []:BeiJing   #省（北京）\r\nLocality Name (eg, city) [Default City]:BeiJing   #市（北京）\r\nOrganization Name (eg, company) [Default Company Ltd]:gdlb  #公司名称\r\nOrganizational Unit Name (eg, section) []:   #可不填\r\nCommon Name (eg, your name or your server's hostname) []: #可不填\r\nEmail Address []: #邮箱\r\nPlease enter the following 'extra' attributes\r\nto be sent with your certificate request\r\nA challenge password []:   #可不填\r\nAn optional company name []:   #可不填\r\n在工程的sign目录下创建release目录，将私钥文件private.pem和证书文件certificate.pem拷贝进去\r\n复制代码自定义根目录配置\r\n开发中可能需要引入js或者css文件等，为了方便通常回会备置相对路径,可以设置 alias （别名），来方便应用；具体的操作是，在 src 目录下建立 config 文件夹，在其中创建 webpack.config.js 文件,毕竟都是是用webpack，就像写vue项目一样。\r\nconst path = require('path')\r\nmodule.exports = {\r\npostHook: function(webpackConf, options){\r\n  webpackConf.resolve.alias = Object.assign(webpackConf.resolve.alias || {}, {\r\n    '@src': path.join(process.cwd(), 'src')\r\n  })\r\n}\r\n}\r\n\r\n复制代码开发中遇到的问题\r\n布局样式\r\n  初写快应用，因为之前是开发过小程序，再到快应用特别不适应。\r\n  1.首页面布局默认的就是flex，其他的浮动布局啥的都没有。\r\n  2.css 习惯连写，突然不能连写很不适应。\r\n  3. 不支position要实现z-index的图层效果请使用stack组件。\r\n  4.大量的css样式不支持，如bulr、box-shadow要实现只能用背景图。\r\n  5.background-image 1030 以下版本不支持网络路径\r\n  6. 华为平台对svg 和 动画有兼容性问题。\r\n  7. border-radius 如果是gif图片不生效。\r\n  8.自定义字体样式 1030+ 才支持font-face定义字体样式。\r\n复制代码组件\r\n\r\nlist-item\r\n\r\n作为使用率最高的组件之一，list-item组件类型不一致时,一定要给type=\"***\"\r\n不同命名来区别，否则也会闪退。\r\n解决方法：\r\n<list-item type=\"{{index}}\">\r\n复制代码\r\nswiper\r\n\r\nswiper也是作为出现频率非常高组件，但是字实际使用中，虽然bug不多，但是开放的功能太少，如vertical设置滑动方向都不支持。\r\n顺便教大家自定义dots(面板指示点)\r\n  <div class=\"swiper-container\">\r\n    <stack>\r\n      <swiper class=\"swiper\" autoplay=\"true\" indicator=\"false\" interval=\"2000\" loop=\"true\" onchange=\"swiperChange\">\r\n        <block for=\"(index, item) in data\">\r\n          <image class=\"wrap-img\" src=\"{{item.image}}\" onclick=\"bindViewTap(item)\" />\r\n        </block>\r\n      </swiper>\r\n      <div class=\"dots\">\r\n        <block for=\"(index, item) in data\">\r\n          <div class=\"dot {{index === swiperCurrent ? 'active' : ''}}\"></div>\r\n        </block>\r\n      </div>\r\n    </stack>\r\n  </div>\r\n  <script>\r\n    export default {\r\n        swiperChange(e) {\r\n            this.swiperCurrent = e.index\r\n        }\r\n    }\r\n  </script>\r\n  利用onchange事件去做修改\r\n复制代码\r\ntabstabs内不能再嵌套tabs，如有此类需求，外部需要div组件模拟选项卡\r\n复制代码\r\nslider\r\n\r\n这个也是一个特别坑爹的组件\r\nslider 组件只有滑动结束后end才有回调，进行中没有回调，改变value值也会触发change事件，无法判断change是人为滑动触发，还是改变数据触发的。官方demo竟然是有时差来区别。\r\n复制代码\r\nweb\r\n\r\n1.web组件使用网页与原生通信时（system.postMessage）。\r\n 当页面发生跳转时，就无法再触发通信，如:\r\n www.xxx.com?id=1跳转到www.xxx.com?id=2\r\n 在华为机型上有更多蜜汁bug.\r\n复制代码\r\nvideo\r\n\r\n    video组件，由于我用到了if渲染后，竟然不能立即调用它的方法，而且还打印是存在的，官方给出答复，可能还没准备就绪。\r\n    this.$forceUpdate()\r\n    /* 使用setTimeout解决蜜汁bug */\r\n    // this.$element(\"video\") && this.$element(\"video\").pause()\r\n    this.$element(\"video\")&&setTimeout(()=>{this.$element(\"video\").pause()},30);\r\n复制代码还有很坑爹的事情，如组件竟然没有onDestroy钩子，据说以后会增加。\r\n接口\r\n\r\n音频接口\r\n\r\n    音频接口特别坑爹。\r\n    1.没有获取当前播放状态的接口，据说1050才会加入。\r\n        audio.ontimeupdate = () => {\r\n          this.isplaying = true\r\n          // 由于快用还没提供获取播放状态的接口,暂时啊这样解决了。\r\n        }\r\n    2.在通知栏中点击关闭音乐触发onpause完之后，ontimeupdate没有立即停止。\r\n        audio.onpause = () => {\r\n          /* 我使用通知栏上的音乐通知栏，直接点击关闭，触发onpause完之后，ontimeupdate没有立即停止，用clearTimeout解决 */\r\n          let globalTime = this.$app.$def.globalTime\r\n          clearTimeout(globalTime)\r\n          globalTime = setTimeout(() => {\r\n            this.isplaying = false\r\n          }, 20)\r\n        }\r\n    3.当页面触发onDestroy，onHide一定要记得销毁不必要的回调。\r\n复制代码\r\n$watch\r\n\r\n此方法尽量避免使用，因为他在1020和1030中是有差异的，在 1030 上的 watcher 的响应确会存在滞后，相比于 1020（牵扯到的代码都是同步逻辑）\r\n复制代码\r\n$forceUpdate()\r\n\r\nthis.$forceUpdate()有点类似与vue的this.$nextTick()，\r\n若开发者期望数据更新时立即执行相应的 DOM 操作，可使用：this.$forceUpdate()；一般不推荐使用\r\n复制代码\r\n被禁用的 new Function，eval\r\n\r\n    eval这些容易注入恶意代码，所以小程序，快应用禁用了。\r\n    其实就是怕你怕你热更新，绕开审核，进行为所欲为的操作。\r\n    但是你确实想用eval，也可以自己实现一个。\r\n    参照-《前端与编译原理——用JS写一个JS解释器》\r\n    https://segmentfault.com/a/1190000017241258"}
{"title": "小程序中富文本解决方案 ", "author": "Rolan", "pub_time": "2018-12-28 00:12", "content": "微信小程序提供的 rich-text 在实际工作上根本不能满足我们的需求。正好项目中需要用到这个，就自己查下资料，网上说 wxParse 这个插件可以使用。好的！就决定使用这个了，但是实际情况并没有想象中那么简单。下面是后台返回的数据，也就是需要处理的数据，看到这些数据真的是很无奈，但没办法还得处理。wxParse 这个插件提供的方法也很简单处理简单的数据还是可以的。只好看他的源码了，并且做了修改。不多说了，直接贴代码了这是修改插件 wxParse.js 里面的方法这是请求数据后的处理这是渲染时的处理这是最终的结果"}
{"title": "使用uni-app快速Vue项目输出到小程序和H5 ", "author": "Rolan", "pub_time": "2018-12-28 00:32", "content": "跨端彻底，直接发行，无需二次开发；通过Tree-Shaking摇出最小化内置组件等优化策略，提升性能这应该是uni-app在H5平台的相对其他小程序框架更友好的地方背景随着微信小程序的火爆及百度、头条小程序的持续推进，跨端开发的需求愈发迫切，业界随之出现了一系列的跨端框架，但对于H5平台跨端支持的都不太彻底：Vue技术栈的小程序框架：对于H5平台支持普遍较弱部分React技术栈的小程序框架：虽支持生成可在H5端运行的代码，但仅仅是代码可运行，离项目直接发行上线的目标还存在一定差距。鉴于客观需求及现状，DCloud前端团队响应开发者彻底跨端的呼声，经过连续奋战，uni-app1.2版本支持发行到H5平台，完整模拟小程序生命周期、事件处理、组件规范等，真正实现“一套代码、多端发行”的目标。https://uniapp.dcloud.io/h5/ (二维码自动识别)本文主要分享，我们在实现uni-app发行到H5平台时，在引擎实现、差异抹平、性能优化方面都做了哪些工作。完整模拟小程序引擎uni-app设计的开发标准是：Vue.js的语法 + 小程序的API + 条件编译扩展平台个性化能力。其中：Vue.js 的语法在微信小程序端，uni-app是在mpvue的基础上增强实现的，在H5端则默认支持；而小程序的API，其实包括三个部分：框架 + 组件（UI）+ 接口（API），这三部分在微信小程序端是内置支持的，而uni-app若要发布到H5平台，则需完整模拟实现小程序运行时环境。如下是一个简易的小程序运行时框架，核心是一个响应的数据绑定系统。为实现小程序、H5两端的完整跨端，uni-app在H5平台完整模拟实现了小程序的逻辑层和视图层，相比业界其它跨端框架，uni-app在H5平台有如下几点实现更完善。页面配置小程序中的导航条、选项卡是通过配置文件生成的，配置后由原生组件进行渲染，uni-app在H5平台同样兼容这些配置，不过会降级通过div控件模拟实现，因此开发者无需单独为H5平台添加导航条或选项卡。生命周期uni-app在H5平台实现了完整的小程序生命周期，为此填了很多坑。举一个详情页互跳的栗子：详情A 打开 详情B，在通常的 web 端 SPA 方案中，会在详情A页面获取B详情的数据，仅会触发详情页A的updated生命周期，不会触发onHide；但在小程序中，则会打开一个新的webview并加载详情B，此时会触发详情A的onHide生命周期，也会触发详情B的onShow生命周期；uni-app完整模拟了小程序的生命周期，详情页之间互相切换时，会触发onHide、onShow等生命周期；这样的实现，即保证了两端兼容性，同时在详情B返回详情A时，详情A已被缓存，无需再次联网加载，也会有更高的性能。事件处理uni-app对于页面事件处理函数支持更为全面，下拉刷新、上拉触底等常用函数均可在H5平台正常复用，无需二次开发。组件规范uni-appH5平台的组件实现，有两个特点：兼容的组件数量更多：比如navigator等组件在H5平台可正常跳转组件属性、嵌套实现更接近小程序实现抹平引擎差异fixed元素遮挡微信小程序是一种 native + web 混合渲染的机制，比如小程序的导航条（navigationBar）、选项卡（tabBar）为原生组件，但H5平台为纯 web 渲染，导航条、选项卡均为 web 实现，这可能引发页面 fixed 元素 和导航条/选项卡位置发生互相遮挡的问题，如下一段 fixed 定位的代码：.fixed{\r\n    position: fixed;\r\n    z-index: 9999;\r\n    bottom: 0px;//底部距离为0\r\n    background-color:peru;\r\n}\r\n在不同平台上运行效果不同，如下图所示：uni-app通过引入css变量解决这类问题，在编译到不同平台时，给css变量设置对应的值。有了css变量，开发者若需处理 fixed 定位的元素，只需像如下方式编写即可：.fixed{\r\n    bottom:var(--window-bottom)\r\n}\r\ncss作用域uni-app在开发时遵循 Vue 单文件组件 (SFC) 规范，编译到微信小程序时会生成对应的 wxml 文件，最终运行时由 webview 渲染，iOS 平台由 WKWebView 渲染，Android 平台由 XWeb 引擎基于 Mobile Chrome 53 内核渲染；uni-app中的不同.vue页面文件( 编译后的.wxml 文件)，在小程序端会由不同的 webview 渲染，故 .vue页面文件中的 css 作用域是天然隔离的，开发者无需在<style> 标签上增加scoped 属性。但H5平台是一套SPA框架，无scoped就会变成全局样式，影响其他页面。uni-app在H5平台做了智能处理，自动增加了scoped。平台性能优化性能一直是 web app 首要关注的焦点，uni-app发行到H5平台时也做了很多性能优化。内置组件按需打包（Tree-Shaking）uni-app有8大类、几十个内置组件，但开发者实际开发时仅会使用其中的一部分组件，比如很多App不会用到map、canvas等组件，若打包时将uni-app整个组件类库都打包进去，则会造成极大的资源浪费，延迟首页渲染速度。uni-app发行到H5平台时采用了摇树优化（Tree-Shaking）策略，将开发者项目中没用到的组件从整个框架中“摇”掉，保证编译后的 JS 文件最小化。具体来说，uni-app编译到H5平台时分为预编译、再编译两个阶段，预编译阶段通过vue-template-compiler分析出来的AST，映射生成项目中使用到的组件清单，然后再基于Webpack插件将使用到的组件编译生成一个最小化的uni-app框架文件。我们以uni-app的两个开源项目模板登录模板、看图模板为例，测试 Tree-Shaking 前后组件框架的大小，效果喜人，数据如下：路由组件按需加载（Lazy-Loading）当打包构建 SPA 应用时，Javascript 包会变得非常大，影响页面加载。虽然开发者基于Vue 的异步组件和 Webpack 的code-splitting 功能，可以实现路由组件的懒加载，但开发者需调整.vue源码及Webpack配置，有一定的学习门槛，且比较繁琐。uni-app在H5平台实现了自动按需加载路由组件，开发者无需调整组件开发方式，仅需关心业务实现即可。其它方面uni-app为提升性能体验，在很多细节上都有特殊设计。比如常见的 SPA 框架一般采用div区域滚动，uni-app为改善用户体验，使用的是body滚动，由此填了很多坑，比如不同页面的background-color，若使用div滚动，则在编译阶段就可完成样式定义，但基于body滚动，就需要在页面前进、后退时动态设置body的背景色。githubuni-app在H5平台的相关代码均已全部开源，详见uni-app，欢迎大家 star 支持."}
